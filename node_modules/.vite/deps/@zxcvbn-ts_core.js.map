{
  "version": 3,
  "sources": ["../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/helper.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/data/dateSplits.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/data/const.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/date/matching.ts", "../../.pnpm/registry.npmmirror.com+fastest-levenshtein@1.0.16/node_modules/fastest-levenshtein/esm/mod.js", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/levenshtein.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/data/l33tTable.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/data/translationKeys.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/unmunger/TrieNode.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/unmunger/l33tTableToTrieNode.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/Options.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/reverse.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/unmunger/getCleanPasswords.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/matching/l33t.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/matching.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/regex/matching.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/scoring/utils.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/bruteforce/scoring.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/date/scoring.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/scoring/uppercase.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/variants/scoring/l33t.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/scoring.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/regex/scoring.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/repeat/scoring.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/sequence/scoring.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/spatial/scoring.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/separator/scoring.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/scoring/estimate.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/scoring/index.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/repeat/matching.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/sequence/matching.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/spatial/matching.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/separator/matching.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/Matching.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/TimeEstimates.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/bruteforce/feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/date/feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/dictionary/feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/regex/feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/repeat/feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/sequence/feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/spatial/feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/matcher/separator/feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/Feedback.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/debounce.ts", "../../.pnpm/registry.npmmirror.com+@zxcvbn-ts+core@3.0.3/node_modules/@zxcvbn-ts/core/src/index.ts"],
  "sourcesContent": ["import { LooseObject, MatchExtended } from './types'\n\nexport const empty = (obj: LooseObject) => Object.keys(obj).length === 0\n\nexport const extend = (listToExtend: any[], list: any[]) =>\n  // eslint-disable-next-line prefer-spread\n  listToExtend.push.apply(listToExtend, list)\n\nexport const translate = (string: string, chrMap: LooseObject) => {\n  let newString = string\n  Object.entries(chrMap).forEach(([key, value]) => {\n    const escapedKey = key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    const regex = new RegExp(escapedKey, 'g')\n    newString = newString.replace(regex, value)\n  })\n\n  return newString\n}\n\n// mod implementation that works for negative numbers\nexport const mod = (n: number, m: number) => ((n % m) + m) % m\n\n// sort on i primary, j secondary\nexport const sorted = (matches: MatchExtended[]) =>\n  matches.sort((m1, m2) => m1.i - m2.i || m1.j - m2.j)\n\nexport const buildRankedDictionary = (orderedList: any[]) => {\n  const result: LooseObject = {}\n  let counter = 1 // rank starts at 1, not 0\n  orderedList.forEach((word) => {\n    result[word] = counter\n    counter += 1\n  })\n  return result\n}\n", "export default {\n  4: [\n    // for length-4 strings, eg 1191 or 9111, two ways to split:\n    [1, 2], // 1 1 91 (2nd split starts at index 1, 3rd at index 2)\n    [2, 3], // 91 1 1\n  ],\n  5: [\n    [1, 3], // 1 11 91\n    [2, 3], // 11 1 91\n    //  [2, 3], // 91 1 11    <- duplicate previous one\n    [2, 4], // 91 11 1    <- New and must be added as bug fix\n  ],\n  6: [\n    [1, 2], // 1 1 1991\n    [2, 4], // 11 11 91\n    [4, 5], // 1991 1 1\n  ],\n  //  1111991\n  7: [\n    [1, 3], // 1 11 1991\n    [2, 3], // 11 1 1991\n    [4, 5], // 1991 1 11\n    [4, 6], // 1991 11 1\n  ],\n  8: [\n    [2, 4], // 11 11 1991\n    [4, 6], // 1991 11 11\n  ],\n}\n", "import dateSplits from './dateSplits'\n\nexport const DATE_MAX_YEAR = 2050\nexport const DATE_MIN_YEAR = 1000\nexport const DATE_SPLITS = dateSplits\nexport const BRUTEFORCE_CARDINALITY = 10\nexport const MIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000\nexport const MIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10\nexport const MIN_SUBMATCH_GUESSES_MULTI_CHAR = 50\nexport const MIN_YEAR_SPACE = 20\n// \\xbf-\\xdf is a range for almost all special uppercase letter like Ä and so on\nexport const START_UPPER = /^[A-Z\\xbf-\\xdf][^A-Z\\xbf-\\xdf]+$/\nexport const END_UPPER = /^[^A-Z\\xbf-\\xdf]+[A-Z\\xbf-\\xdf]$/\n// \\xdf-\\xff is a range for almost all special lowercase letter like ä and so on\nexport const ALL_UPPER = /^[A-Z\\xbf-\\xdf]+$/\nexport const ALL_UPPER_INVERTED = /^[^a-z\\xdf-\\xff]+$/\nexport const ALL_LOWER = /^[a-z\\xdf-\\xff]+$/\nexport const ALL_LOWER_INVERTED = /^[^A-Z\\xbf-\\xdf]+$/\nexport const ONE_LOWER = /[a-z\\xdf-\\xff]/\nexport const ONE_UPPER = /[A-Z\\xbf-\\xdf]/\nexport const ALPHA_INVERTED = /[^A-Za-z\\xbf-\\xdf]/gi\nexport const ALL_DIGIT = /^\\d+$/\nexport const REFERENCE_YEAR = new Date().getFullYear()\nexport const REGEXEN = { recentYear: /19\\d\\d|200\\d|201\\d|202\\d/g }\n/* Separators */\nexport const SEPERATOR_CHARS = [\n  ' ',\n  ',',\n  ';',\n  ':',\n  '|',\n  '/',\n  '\\\\',\n  '_',\n  '.',\n  '-',\n]\nexport const SEPERATOR_CHAR_COUNT = SEPERATOR_CHARS.length\n", "import {\n  DATE_MAX_YEAR,\n  DATE_MIN_YEAR,\n  DATE_SPLITS,\n  REFERENCE_YEAR,\n} from '../../data/const'\nimport { sorted } from '../../helper'\nimport { DateMatch } from '../../types'\n\ninterface DateMatchOptions {\n  password: string\n}\n\n/*\n * -------------------------------------------------------------------------------\n *  date matching ----------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchDate {\n  /*\n   * a \"date\" is recognized as:\n   *   any 3-tuple that starts or ends with a 2- or 4-digit year,\n   *   with 2 or 0 separator chars (1.1.91 or 1191),\n   *   maybe zero-padded (01-01-91 vs 1-1-91),\n   *   a month between 1 and 12,\n   *   a day between 1 and 31.\n   *\n   * note: this isn't true date parsing in that \"feb 31st\" is allowed,\n   * this doesn't check for leap years, etc.\n   *\n   * recipe:\n   * start with regex to find maybe-dates, then attempt to map the integers\n   * onto month-day-year to filter the maybe-dates into dates.\n   * finally, remove matches that are substrings of other matches to reduce noise.\n   *\n   * note: instead of using a lazy or greedy regex to find many dates over the full string,\n   * this uses a ^...$ regex against every substring of the password -- less performant but leads\n   * to every possible date match.\n   */\n  match({ password }: DateMatchOptions) {\n    const matches: DateMatch[] = [\n      ...this.getMatchesWithoutSeparator(password),\n      ...this.getMatchesWithSeparator(password),\n    ]\n\n    const filteredMatches = this.filterNoise(matches)\n    return sorted(filteredMatches)\n  }\n\n  getMatchesWithSeparator(password: string) {\n    const matches: DateMatch[] = []\n    const maybeDateWithSeparator = /^(\\d{1,4})([\\s/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/\n    // # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n    for (let i = 0; i <= Math.abs(password.length - 6); i += 1) {\n      for (let j = i + 5; j <= i + 9; j += 1) {\n        if (j >= password.length) {\n          break\n        }\n        const token = password.slice(i, +j + 1 || 9e9)\n        const regexMatch = maybeDateWithSeparator.exec(token)\n        if (regexMatch != null) {\n          const dmy = this.mapIntegersToDayMonthYear([\n            parseInt(regexMatch[1], 10),\n            parseInt(regexMatch[3], 10),\n            parseInt(regexMatch[4], 10),\n          ])\n          if (dmy != null) {\n            matches.push({\n              pattern: 'date',\n              token,\n              i,\n              j,\n              separator: regexMatch[2],\n              year: dmy.year,\n              month: dmy.month,\n              day: dmy.day,\n            })\n          }\n        }\n      }\n    }\n    return matches\n  }\n\n  // eslint-disable-next-line max-statements\n  getMatchesWithoutSeparator(password: string) {\n    const matches: DateMatch[] = []\n    const maybeDateNoSeparator = /^\\d{4,8}$/\n    const metric = (candidate: DateMatch) =>\n      Math.abs(candidate.year - REFERENCE_YEAR)\n    // # dates without separators are between length 4 '1191' and 8 '11111991'\n    for (let i = 0; i <= Math.abs(password.length - 4); i += 1) {\n      for (let j = i + 3; j <= i + 7; j += 1) {\n        if (j >= password.length) {\n          break\n        }\n        const token = password.slice(i, +j + 1 || 9e9)\n        if (maybeDateNoSeparator.exec(token)) {\n          const candidates: any[] = []\n          const index = token.length\n          const splittedDates = DATE_SPLITS[index as keyof typeof DATE_SPLITS]\n          splittedDates.forEach(([k, l]) => {\n            const dmy = this.mapIntegersToDayMonthYear([\n              parseInt(token.slice(0, k), 10),\n              parseInt(token.slice(k, l), 10),\n              parseInt(token.slice(l), 10),\n            ])\n            if (dmy != null) {\n              candidates.push(dmy)\n            }\n          })\n          if (candidates.length > 0) {\n            /*\n             * at this point: different possible dmy mappings for the same i,j substring.\n             * match the candidate date that likely takes the fewest guesses: a year closest\n             * to 2000.\n             * (scoring.REFERENCE_YEAR).\n             *\n             * ie, considering '111504', prefer 11-15-04 to 1-1-1504\n             * (interpreting '04' as 2004)\n             */\n            let bestCandidate = candidates[0]\n            let minDistance = metric(candidates[0])\n            candidates.slice(1).forEach((candidate) => {\n              const distance = metric(candidate)\n              if (distance < minDistance) {\n                bestCandidate = candidate\n                minDistance = distance\n              }\n            })\n            matches.push({\n              pattern: 'date',\n              token,\n              i,\n              j,\n              separator: '',\n              year: bestCandidate.year,\n              month: bestCandidate.month,\n              day: bestCandidate.day,\n            })\n          }\n        }\n      }\n    }\n    return matches\n  }\n\n  /*\n   * matches now contains all valid date strings in a way that is tricky to capture\n   * with regexes only. while thorough, it will contain some unintuitive noise:\n   *\n   * '2015_06_04', in addition to matching 2015_06_04, will also contain\n   * 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n   *\n   * to reduce noise, remove date matches that are strict substrings of others\n   */\n  filterNoise(matches: DateMatch[]) {\n    return matches.filter((match) => {\n      let isSubmatch = false\n      const matchesLength = matches.length\n      for (let o = 0; o < matchesLength; o += 1) {\n        const otherMatch = matches[o]\n        if (match !== otherMatch) {\n          if (otherMatch.i <= match.i && otherMatch.j >= match.j) {\n            isSubmatch = true\n            break\n          }\n        }\n      }\n      return !isSubmatch\n    })\n  }\n\n  /*\n   * given a 3-tuple, discard if:\n   *   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n   *   middle int is zero\n   *   any int is over the max allowable year\n   *   any int is over two digits but under the min allowable year\n   *   2 integers are over 31, the max allowable day\n   *   2 integers are zero\n   *   all integers are over 12, the max allowable month\n   */\n  // eslint-disable-next-line complexity, max-statements\n  mapIntegersToDayMonthYear(integers: number[]) {\n    if (integers[1] > 31 || integers[1] <= 0) {\n      return null\n    }\n    let over12 = 0\n    let over31 = 0\n    let under1 = 0\n    for (let o = 0, len1 = integers.length; o < len1; o += 1) {\n      const int = integers[o]\n      if ((int > 99 && int < DATE_MIN_YEAR) || int > DATE_MAX_YEAR) {\n        return null\n      }\n      if (int > 31) {\n        over31 += 1\n      }\n      if (int > 12) {\n        over12 += 1\n      }\n      if (int <= 0) {\n        under1 += 1\n      }\n    }\n    if (over31 >= 2 || over12 === 3 || under1 >= 2) {\n      return null\n    }\n    return this.getDayMonth(integers)\n  }\n\n  // eslint-disable-next-line max-statements\n  getDayMonth(integers: number[]) {\n    // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n    const possibleYearSplits: [number, number[]][] = [\n      [integers[2], integers.slice(0, 2)], // year last\n      [integers[0], integers.slice(1, 3)], // year first\n    ]\n    const possibleYearSplitsLength = possibleYearSplits.length\n    for (let j = 0; j < possibleYearSplitsLength; j += 1) {\n      const [y, rest] = possibleYearSplits[j]\n      if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n        const dm = this.mapIntegersToDayMonth(rest)\n        if (dm != null) {\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day,\n          }\n        }\n        /*\n         * for a candidate that includes a four-digit year,\n         * when the remaining integers don't match to a day and month,\n         * it is not a date.\n         */\n        return null\n      }\n    }\n    // given no four-digit year, two digit years are the most flexible int to match, so\n    // try to parse a day-month out of integers[0..1] or integers[1..0]\n    for (let k = 0; k < possibleYearSplitsLength; k += 1) {\n      const [y, rest] = possibleYearSplits[k]\n      const dm = this.mapIntegersToDayMonth(rest)\n      if (dm != null) {\n        return {\n          year: this.twoToFourDigitYear(y),\n          month: dm.month,\n          day: dm.day,\n        }\n      }\n    }\n    return null\n  }\n\n  mapIntegersToDayMonth(integers: number[]) {\n    const temp = [integers, integers.slice().reverse()]\n    for (let i = 0; i < temp.length; i += 1) {\n      const data = temp[i]\n      const day = data[0]\n      const month = data[1]\n      if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {\n        return {\n          day,\n          month,\n        }\n      }\n    }\n    return null\n  }\n\n  twoToFourDigitYear(year: number) {\n    if (year > 99) {\n      return year\n    }\n    if (year > 50) {\n      // 87 -> 1987\n      return year + 1900\n    }\n    // 15 -> 2015\n    return year + 2000\n  }\n}\n\nexport default MatchDate\n", "const peq = new Uint32Array(0x10000);\nconst myers_32 = (a, b) => {\n    const n = a.length;\n    const m = b.length;\n    const lst = 1 << (n - 1);\n    let pv = -1;\n    let mv = 0;\n    let sc = n;\n    let i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] |= 1 << i;\n    }\n    for (i = 0; i < m; i++) {\n        let eq = peq[b.charCodeAt(i)];\n        const xv = eq | mv;\n        eq |= ((eq & pv) + pv) ^ pv;\n        mv |= ~(eq | pv);\n        pv &= eq;\n        if (mv & lst) {\n            sc++;\n        }\n        if (pv & lst) {\n            sc--;\n        }\n        mv = (mv << 1) | 1;\n        pv = (pv << 1) | ~(xv | mv);\n        mv &= xv;\n    }\n    i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] = 0;\n    }\n    return sc;\n};\nconst myers_x = (b, a) => {\n    const n = a.length;\n    const m = b.length;\n    const mhc = [];\n    const phc = [];\n    const hsize = Math.ceil(n / 32);\n    const vsize = Math.ceil(m / 32);\n    for (let i = 0; i < hsize; i++) {\n        phc[i] = -1;\n        mhc[i] = 0;\n    }\n    let j = 0;\n    for (; j < vsize - 1; j++) {\n        let mv = 0;\n        let pv = -1;\n        const start = j * 32;\n        const vlen = Math.min(32, m) + start;\n        for (let k = start; k < vlen; k++) {\n            peq[b.charCodeAt(k)] |= 1 << k;\n        }\n        for (let i = 0; i < n; i++) {\n            const eq = peq[a.charCodeAt(i)];\n            const pb = (phc[(i / 32) | 0] >>> i) & 1;\n            const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n            const xv = eq | mv;\n            const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n            let ph = mv | ~(xh | pv);\n            let mh = pv & xh;\n            if ((ph >>> 31) ^ pb) {\n                phc[(i / 32) | 0] ^= 1 << i;\n            }\n            if ((mh >>> 31) ^ mb) {\n                mhc[(i / 32) | 0] ^= 1 << i;\n            }\n            ph = (ph << 1) | pb;\n            mh = (mh << 1) | mb;\n            pv = mh | ~(xv | ph);\n            mv = ph & xv;\n        }\n        for (let k = start; k < vlen; k++) {\n            peq[b.charCodeAt(k)] = 0;\n        }\n    }\n    let mv = 0;\n    let pv = -1;\n    const start = j * 32;\n    const vlen = Math.min(32, m - start) + start;\n    for (let k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] |= 1 << k;\n    }\n    let score = m;\n    for (let i = 0; i < n; i++) {\n        const eq = peq[a.charCodeAt(i)];\n        const pb = (phc[(i / 32) | 0] >>> i) & 1;\n        const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n        const xv = eq | mv;\n        const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n        let ph = mv | ~(xh | pv);\n        let mh = pv & xh;\n        score += (ph >>> (m - 1)) & 1;\n        score -= (mh >>> (m - 1)) & 1;\n        if ((ph >>> 31) ^ pb) {\n            phc[(i / 32) | 0] ^= 1 << i;\n        }\n        if ((mh >>> 31) ^ mb) {\n            mhc[(i / 32) | 0] ^= 1 << i;\n        }\n        ph = (ph << 1) | pb;\n        mh = (mh << 1) | mb;\n        pv = mh | ~(xv | ph);\n        mv = ph & xv;\n    }\n    for (let k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] = 0;\n    }\n    return score;\n};\nconst distance = (a, b) => {\n    if (a.length < b.length) {\n        const tmp = b;\n        b = a;\n        a = tmp;\n    }\n    if (b.length === 0) {\n        return a.length;\n    }\n    if (a.length <= 32) {\n        return myers_32(a, b);\n    }\n    return myers_x(a, b);\n};\nconst closest = (str, arr) => {\n    let min_distance = Infinity;\n    let min_index = 0;\n    for (let i = 0; i < arr.length; i++) {\n        const dist = distance(str, arr[i]);\n        if (dist < min_distance) {\n            min_distance = dist;\n            min_index = i;\n        }\n    }\n    return arr[min_index];\n};\nexport { closest, distance };\n", "import { distance } from 'fastest-levenshtein'\nimport { LooseObject } from './types'\n\nconst getUsedThreshold = (\n  password: string,\n  entry: string,\n  threshold: number,\n) => {\n  const isPasswordToShort = password.length <= entry.length\n  const isThresholdLongerThanPassword = password.length <= threshold\n  const shouldUsePasswordLength =\n    isPasswordToShort || isThresholdLongerThanPassword\n\n  // if password is too small use the password length divided by 4 while the threshold needs to be at least 1\n  return shouldUsePasswordLength ? Math.ceil(password.length / 4) : threshold\n}\n\nexport interface FindLevenshteinDistanceResult {\n  levenshteinDistance: number\n  levenshteinDistanceEntry: string\n}\n\nconst findLevenshteinDistance = (\n  password: string,\n  rankedDictionary: LooseObject,\n  threshold: number,\n): Partial<FindLevenshteinDistanceResult> => {\n  let foundDistance = 0\n  const found = Object.keys(rankedDictionary).find((entry) => {\n    const usedThreshold = getUsedThreshold(password, entry, threshold)\n    if (Math.abs(password.length - entry.length) > usedThreshold) {\n      return false\n    }\n    const foundEntryDistance = distance(password, entry)\n    const isInThreshold = foundEntryDistance <= usedThreshold\n\n    if (isInThreshold) {\n      foundDistance = foundEntryDistance\n    }\n    return isInThreshold\n  })\n  if (found) {\n    return {\n      levenshteinDistance: foundDistance,\n      levenshteinDistanceEntry: found,\n    }\n  }\n  return {}\n}\n\nexport default findLevenshteinDistance\n", "export default {\n  a: ['4', '@'],\n  b: ['8'],\n  c: ['(', '{', '[', '<'],\n  d: ['6', '|)'],\n  e: ['3'],\n  f: ['#'],\n  g: ['6', '9', '&'],\n  h: ['#', '|-|'],\n  i: ['1', '!', '|'],\n  k: ['<', '|<'],\n  l: ['!', '1', '|', '7'],\n  m: ['^^', 'nn', '2n', '/\\\\\\\\/\\\\\\\\'],\n  n: ['//'],\n  o: ['0', '()'],\n  q: ['9'],\n  u: ['|_|'],\n  s: ['$', '5'],\n  t: ['+', '7'],\n  v: ['<', '>', '/'],\n  w: ['^/', 'uu', 'vv', '2u', '2v', '\\\\\\\\/\\\\\\\\/'],\n  x: ['%', '><'],\n  z: ['2'],\n}\n", "export default {\n  warnings: {\n    straightRow: 'straightRow',\n    keyPattern: 'keyPattern',\n    simpleRepeat: 'simpleRepeat',\n    extendedRepeat: 'extendedRepeat',\n    sequences: 'sequences',\n    recentYears: 'recentYears',\n    dates: 'dates',\n    topTen: 'topTen',\n    topHundred: 'topHundred',\n    common: 'common',\n    similarToCommon: 'similarToCommon',\n    wordByItself: 'wordByItself',\n    namesByThemselves: 'namesByThemselves',\n    commonNames: 'commonNames',\n    userInputs: 'userInputs',\n    pwned: 'pwned',\n  },\n  suggestions: {\n    l33t: 'l33t',\n    reverseWords: 'reverseWords',\n    allUppercase: 'allUppercase',\n    capitalization: 'capitalization',\n    dates: 'dates',\n    recentYears: 'recentYears',\n    associatedYears: 'associatedYears',\n    sequences: 'sequences',\n    repeated: 'repeated',\n    longerKeyboardPattern: 'longerKeyboardPattern',\n    anotherWord: 'anotherWord',\n    useWords: 'useWords',\n    noNeed: 'noNeed',\n    pwned: 'pwned',\n  },\n  timeEstimation: {\n    ltSecond: 'ltSecond',\n    second: 'second',\n    seconds: 'seconds',\n    minute: 'minute',\n    minutes: 'minutes',\n    hour: 'hour',\n    hours: 'hours',\n    day: 'day',\n    days: 'days',\n    month: 'month',\n    months: 'months',\n    year: 'year',\n    years: 'years',\n    centuries: 'centuries',\n  },\n}\n", "export default class TrieNode {\n  constructor(public parents: string[] = []) {}\n\n  // eslint-disable-next-line no-use-before-define\n  children: Map<string, TrieNode> = new Map()\n\n  subs?: string[]\n\n  addSub(key: string, ...subs: string[]): TrieNode {\n    const firstChar = key.charAt(0)\n    if (!this.children.has(firstChar)) {\n      this.children.set(firstChar, new TrieNode([...this.parents, firstChar]))\n    }\n    let cur = this.children.get(firstChar)!\n    for (let i = 1; i < key.length; i += 1) {\n      const c = key.charAt(i)\n      if (!cur.hasChild(c)) {\n        cur.addChild(c)\n      }\n      cur = cur.getChild(c)!\n    }\n    cur.subs = (cur.subs || []).concat(subs)\n    return this\n  }\n\n  getChild(child: string): TrieNode | undefined {\n    return this.children.get(child)\n  }\n\n  isTerminal(): boolean {\n    return !!this.subs\n  }\n\n  addChild(child: string): void {\n    if (!this.hasChild(child)) {\n      this.children.set(child, new TrieNode([...this.parents, child]))\n    }\n  }\n\n  hasChild(child: string): boolean {\n    return this.children.has(child)\n  }\n}\n", "import { OptionsL33tTable } from '../../../../../types'\nimport TrieNode from './TrieNode'\n\nexport default (l33tTable: OptionsL33tTable, triNode: TrieNode) => {\n  Object.entries(l33tTable).forEach(([letter, substitutions]) => {\n    substitutions.forEach((substitution) => {\n      triNode.addSub(substitution, letter)\n    })\n  })\n  return triNode\n}\n", "import { buildRankedDictionary } from './helper'\nimport {\n  TranslationKeys,\n  OptionsType,\n  OptionsDictionary,\n  OptionsL33tTable,\n  OptionsGraph,\n  RankedDictionaries,\n  Matchers,\n  Matcher,\n} from './types'\nimport l33tTable from './data/l33tTable'\nimport translationKeys from './data/translationKeys'\nimport TrieNode from './matcher/dictionary/variants/matching/unmunger/TrieNode'\nimport l33tTableToTrieNode from './matcher/dictionary/variants/matching/unmunger/l33tTableToTrieNode'\n\nexport class Options {\n  matchers: Matchers = {}\n\n  l33tTable: OptionsL33tTable = l33tTable\n\n  trieNodeRoot: TrieNode = l33tTableToTrieNode(l33tTable, new TrieNode())\n\n  dictionary: OptionsDictionary = {\n    userInputs: [],\n  }\n\n  rankedDictionaries: RankedDictionaries = {}\n\n  rankedDictionariesMaxWordSize: Record<string, number> = {}\n\n  translations: TranslationKeys = translationKeys\n\n  graphs: OptionsGraph = {}\n\n  useLevenshteinDistance: boolean = false\n\n  levenshteinThreshold: number = 2\n\n  l33tMaxSubstitutions: number = 512\n\n  maxLength: number = 256\n\n  constructor() {\n    this.setRankedDictionaries()\n  }\n\n  // eslint-disable-next-line max-statements,complexity\n  setOptions(options: OptionsType = {}) {\n    if (options.l33tTable) {\n      this.l33tTable = options.l33tTable\n      this.trieNodeRoot = l33tTableToTrieNode(options.l33tTable, new TrieNode())\n    }\n\n    if (options.dictionary) {\n      this.dictionary = options.dictionary\n\n      this.setRankedDictionaries()\n    }\n\n    if (options.translations) {\n      this.setTranslations(options.translations)\n    }\n\n    if (options.graphs) {\n      this.graphs = options.graphs\n    }\n\n    if (options.useLevenshteinDistance !== undefined) {\n      this.useLevenshteinDistance = options.useLevenshteinDistance\n    }\n\n    if (options.levenshteinThreshold !== undefined) {\n      this.levenshteinThreshold = options.levenshteinThreshold\n    }\n\n    if (options.l33tMaxSubstitutions !== undefined) {\n      this.l33tMaxSubstitutions = options.l33tMaxSubstitutions\n    }\n\n    if (options.maxLength !== undefined) {\n      this.maxLength = options.maxLength\n    }\n  }\n\n  setTranslations(translations: TranslationKeys) {\n    if (this.checkCustomTranslations(translations)) {\n      this.translations = translations\n    } else {\n      throw new Error('Invalid translations object fallback to keys')\n    }\n  }\n\n  checkCustomTranslations(translations: TranslationKeys) {\n    let valid = true\n    Object.keys(translationKeys).forEach((type) => {\n      if (type in translations) {\n        const translationType = type as keyof typeof translationKeys\n        Object.keys(translationKeys[translationType]).forEach((key) => {\n          if (!(key in translations[translationType])) {\n            valid = false\n          }\n        })\n      } else {\n        valid = false\n      }\n    })\n    return valid\n  }\n\n  setRankedDictionaries() {\n    const rankedDictionaries: RankedDictionaries = {}\n    const rankedDictionariesMaxWorkSize: Record<string, number> = {}\n    Object.keys(this.dictionary).forEach((name) => {\n      rankedDictionaries[name] = buildRankedDictionary(this.dictionary[name])\n      rankedDictionariesMaxWorkSize[name] =\n        this.getRankedDictionariesMaxWordSize(this.dictionary[name])\n    })\n    this.rankedDictionaries = rankedDictionaries\n    this.rankedDictionariesMaxWordSize = rankedDictionariesMaxWorkSize\n  }\n\n  getRankedDictionariesMaxWordSize(list: (string | number)[]) {\n    const data = list.map((el) => {\n      if (typeof el !== 'string') {\n        return el.toString().length\n      }\n      return el.length\n    })\n\n    // do not use Math.max(...data) because it can result in max stack size error because every entry will be used as an argument\n    if (data.length === 0) {\n      return 0\n    }\n    return data.reduce((a, b) => Math.max(a, b), -Infinity)\n  }\n\n  buildSanitizedRankedDictionary(list: (string | number)[]) {\n    const sanitizedInputs: string[] = []\n\n    list.forEach((input: string | number | boolean) => {\n      const inputType = typeof input\n      if (\n        inputType === 'string' ||\n        inputType === 'number' ||\n        inputType === 'boolean'\n      ) {\n        sanitizedInputs.push(input.toString().toLowerCase())\n      }\n    })\n\n    return buildRankedDictionary(sanitizedInputs)\n  }\n\n  extendUserInputsDictionary(dictionary: (string | number)[]) {\n    if (!this.dictionary.userInputs) {\n      this.dictionary.userInputs = []\n    }\n\n    const newList = [...this.dictionary.userInputs, ...dictionary]\n    this.rankedDictionaries.userInputs =\n      this.buildSanitizedRankedDictionary(newList)\n    this.rankedDictionariesMaxWordSize.userInputs =\n      this.getRankedDictionariesMaxWordSize(newList)\n  }\n\n  public addMatcher(name: string, matcher: Matcher) {\n    if (this.matchers[name]) {\n      console.info(`Matcher ${name} already exists`)\n    } else {\n      this.matchers[name] = matcher\n    }\n  }\n}\n\nexport const zxcvbnOptions = new Options()\n", "import { DictionaryMatch } from '../../../../types'\nimport { DefaultMatch } from '../../types'\n\n/*\n * -------------------------------------------------------------------------------\n *  Dictionary reverse matching --------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchReverse {\n  defaultMatch: DefaultMatch\n\n  constructor(defaultMatch: DefaultMatch) {\n    this.defaultMatch = defaultMatch\n  }\n\n  match({ password }: { password: string }) {\n    const passwordReversed = password.split('').reverse().join('')\n    return this.defaultMatch({\n      password: passwordReversed,\n    }).map((match: DictionaryMatch) => ({\n      ...match,\n      token: match.token.split('').reverse().join(''), // reverse back\n      reversed: true,\n      // map coordinates back to original string\n      i: password.length - 1 - match.j,\n      j: password.length - 1 - match.i,\n    }))\n  }\n}\n\nexport default MatchReverse\n", "import TrieNode from './TrieNode'\n\ninterface GetAllSubCombosHelperOptions {\n  substr: string\n  buffer: string[]\n  limit: number\n  trieRoot: TrieNode\n}\n\nexport interface PasswordChanges {\n  letter: string\n  substitution: string\n}\n\nexport type IndexedPasswordChanges = PasswordChanges & { i: number }\n\nexport interface PasswordWithSubs {\n  password: string\n  changes: IndexedPasswordChanges[]\n}\n\ninterface HelperOptions {\n  onlyFullSub: boolean\n  isFullSub: boolean\n  index: number\n  subIndex: number\n  changes: IndexedPasswordChanges[]\n}\n\nclass CleanPasswords {\n  private substr: string\n\n  private buffer: string[]\n\n  private limit: number\n\n  private trieRoot: TrieNode\n\n  private finalPasswords: PasswordWithSubs[] = []\n\n  constructor({\n    substr,\n    buffer,\n    limit,\n    trieRoot,\n  }: GetAllSubCombosHelperOptions) {\n    this.substr = substr\n    this.buffer = buffer\n    this.limit = limit\n    this.trieRoot = trieRoot\n  }\n\n  private getAllPossibleSubsAtIndex(index: number) {\n    const nodes: TrieNode[] = []\n    let cur = this.trieRoot\n    for (let i = index; i < this.substr.length; i += 1) {\n      const character = this.substr.charAt(i)\n      cur = cur.getChild(character)!\n      if (!cur) {\n        break\n      }\n      nodes.push(cur)\n    }\n    return nodes\n  }\n\n  // eslint-disable-next-line complexity,max-statements\n  private helper({\n    onlyFullSub,\n    isFullSub,\n    index,\n    subIndex,\n    changes,\n  }: HelperOptions): void {\n    if (this.finalPasswords.length >= this.limit) {\n      return\n    }\n\n    if (index === this.substr.length) {\n      if (onlyFullSub === isFullSub) {\n        this.finalPasswords.push({ password: this.buffer.join(''), changes })\n      }\n      return\n    }\n\n    // first, exhaust all possible substitutions at this index\n    const nodes: TrieNode[] = [...this.getAllPossibleSubsAtIndex(index)]\n\n    let hasSubs = false\n    // iterate backward to get wider substitutions first\n    for (let i = index + nodes.length - 1; i >= index; i -= 1) {\n      const cur = nodes[i - index]\n      if (cur.isTerminal()) {\n        hasSubs = true\n        const subs = cur.subs!\n        // eslint-disable-next-line no-restricted-syntax\n        for (const sub of subs) {\n          this.buffer.push(sub)\n          const newSubs = changes.concat({\n            i: subIndex,\n            letter: sub,\n            substitution: cur.parents.join(''),\n          })\n\n          // recursively build the rest of the string\n          this.helper({\n            onlyFullSub,\n            isFullSub,\n            index: i + 1,\n            subIndex: subIndex + sub.length,\n            changes: newSubs,\n          })\n          // backtrack by ignoring the added postfix\n          this.buffer.pop()\n          if (this.finalPasswords.length >= this.limit) {\n            return\n          }\n        }\n      }\n    }\n    // next, generate all combos without doing a substitution at this index\n    // if a partial substitution is requested or there are no substitutions at this index\n    if (!onlyFullSub || !hasSubs) {\n      const firstChar = this.substr.charAt(index)\n      this.buffer.push(firstChar)\n      this.helper({\n        onlyFullSub,\n        isFullSub: isFullSub && !hasSubs,\n        index: index + 1,\n        subIndex: subIndex + 1,\n        changes,\n      })\n      this.buffer.pop()\n    }\n  }\n\n  getAll() {\n    // only full substitution\n    this.helper({\n      onlyFullSub: true,\n      isFullSub: true,\n      index: 0,\n      subIndex: 0,\n      changes: [],\n    })\n    // only partial substitution\n    this.helper({\n      onlyFullSub: false,\n      isFullSub: true,\n      index: 0,\n      subIndex: 0,\n      changes: [],\n    })\n\n    return this.finalPasswords\n  }\n}\n\nconst getCleanPasswords = (\n  string: string,\n  limit: number,\n  trieRoot: TrieNode,\n): PasswordWithSubs[] => {\n  const helper = new CleanPasswords({\n    substr: string,\n    buffer: [],\n    limit,\n    trieRoot,\n  })\n\n  return helper.getAll()\n}\nexport default getCleanPasswords\n", "import { zxcvbnOptions } from '../../../../Options'\nimport { DictionaryMatch, L33tMatch } from '../../../../types'\nimport { DefaultMatch } from '../../types'\nimport getCleanPasswords, {\n  PasswordChanges,\n  PasswordWithSubs,\n} from './unmunger/getCleanPasswords'\n\nconst getExtras = (\n  passwordWithSubs: PasswordWithSubs,\n  i: number,\n  j: number,\n) => {\n  const previousChanges = passwordWithSubs.changes.filter((changes) => {\n    return changes.i < i\n  })\n  const iUnsubbed = previousChanges.reduce((value, change) => {\n    return value - change.letter.length + change.substitution.length\n  }, i)\n  const usedChanges = passwordWithSubs.changes.filter((changes) => {\n    return changes.i >= i && changes.i <= j\n  })\n  const jUnsubbed = usedChanges.reduce(\n    (value, change) => {\n      return value - change.letter.length + change.substitution.length\n    },\n    j - i + iUnsubbed,\n  )\n  const filtered: PasswordChanges[] = []\n  const subDisplay: string[] = []\n  usedChanges.forEach((value) => {\n    const existingIndex = filtered.findIndex((t) => {\n      return t.letter === value.letter && t.substitution === value.substitution\n    })\n    if (existingIndex < 0) {\n      filtered.push({\n        letter: value.letter,\n        substitution: value.substitution,\n      })\n      subDisplay.push(`${value.substitution} -> ${value.letter}`)\n    }\n  })\n  return {\n    i: iUnsubbed,\n    j: jUnsubbed,\n    subs: filtered,\n    subDisplay: subDisplay.join(', '),\n  }\n}\n\n/*\n * -------------------------------------------------------------------------------\n *  Dictionary l33t matching -----------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchL33t {\n  defaultMatch: DefaultMatch\n\n  constructor(defaultMatch: DefaultMatch) {\n    this.defaultMatch = defaultMatch\n  }\n\n  isAlreadyIncluded(matches: L33tMatch[], newMatch: L33tMatch) {\n    return matches.some((l33tMatch) => {\n      return Object.entries(l33tMatch).every(([key, value]) => {\n        return key === 'subs' || value === newMatch[key]\n      })\n    })\n  }\n\n  match({ password }: { password: string }) {\n    const matches: L33tMatch[] = []\n    const subbedPasswords = getCleanPasswords(\n      password,\n      zxcvbnOptions.l33tMaxSubstitutions,\n      zxcvbnOptions.trieNodeRoot,\n    )\n    let hasFullMatch = false\n    let isFullSubstitution = true\n    subbedPasswords.forEach((subbedPassword) => {\n      if (hasFullMatch) {\n        return\n      }\n      const matchedDictionary = this.defaultMatch({\n        password: subbedPassword.password,\n        useLevenshtein: isFullSubstitution,\n      })\n      // only the first entry has a full substitution\n      isFullSubstitution = false\n      matchedDictionary.forEach((match: DictionaryMatch) => {\n        if (!hasFullMatch) {\n          hasFullMatch = match.i === 0 && match.j === password.length - 1\n        }\n        const extras = getExtras(subbedPassword, match.i, match.j)\n        const token = password.slice(extras.i, +extras.j + 1 || 9e9)\n        const newMatch: L33tMatch = {\n          ...match,\n          l33t: true,\n          token,\n          ...extras,\n        }\n        const alreadyIncluded = this.isAlreadyIncluded(matches, newMatch)\n\n        // only return the matches that contain an actual substitution\n        if (token.toLowerCase() !== match.matchedWord && !alreadyIncluded) {\n          matches.push(newMatch)\n        }\n      })\n    })\n\n    // filter single-character l33t matches to reduce noise.\n    // otherwise '1' matches 'i', '4' matches 'a', both very common English words\n    // with low dictionary rank.\n    return matches.filter((match) => match.token.length > 1)\n  }\n}\n\nexport default MatchL33t\n", "import findLevenshteinDistance, {\n  FindLevenshteinDistanceResult,\n} from '../../levenshtein'\nimport { sorted } from '../../helper'\nimport { zxcvbnOptions } from '../../Options'\nimport { DictionaryNames, DictionaryMatch, L33tMatch } from '../../types'\nimport Reverse from './variants/matching/reverse'\nimport L33t from './variants/matching/l33t'\nimport { DictionaryMatchOptions } from './types'\n\nclass MatchDictionary {\n  l33t: L33t\n\n  reverse: Reverse\n\n  constructor() {\n    this.l33t = new L33t(this.defaultMatch)\n    this.reverse = new Reverse(this.defaultMatch)\n  }\n\n  match({ password }: DictionaryMatchOptions) {\n    const matches = [\n      ...(this.defaultMatch({\n        password,\n      }) as DictionaryMatch[]),\n      ...(this.reverse.match({ password }) as DictionaryMatch[]),\n      ...(this.l33t.match({ password }) as L33tMatch[]),\n    ]\n    return sorted(matches)\n  }\n\n  defaultMatch({ password, useLevenshtein = true }: DictionaryMatchOptions) {\n    const matches: DictionaryMatch[] = []\n    const passwordLength = password.length\n    const passwordLower = password.toLowerCase()\n\n    // eslint-disable-next-line complexity,max-statements\n    Object.keys(zxcvbnOptions.rankedDictionaries).forEach((dictionaryName) => {\n      const rankedDict =\n        zxcvbnOptions.rankedDictionaries[dictionaryName as DictionaryNames]\n      const longestDictionaryWordSize =\n        zxcvbnOptions.rankedDictionariesMaxWordSize[dictionaryName]\n      const searchWidth = Math.min(longestDictionaryWordSize, passwordLength)\n      for (let i = 0; i < passwordLength; i += 1) {\n        const searchEnd = Math.min(i + searchWidth, passwordLength)\n        for (let j = i; j < searchEnd; j += 1) {\n          const usedPassword = passwordLower.slice(i, +j + 1 || 9e9)\n          const isInDictionary = usedPassword in rankedDict\n          let foundLevenshteinDistance: Partial<FindLevenshteinDistanceResult> =\n            {}\n          // only use levenshtein distance on full password to minimize the performance drop\n          // and because otherwise there would be to many false positives\n          const isFullPassword = i === 0 && j === passwordLength - 1\n          if (\n            zxcvbnOptions.useLevenshteinDistance &&\n            isFullPassword &&\n            !isInDictionary &&\n            useLevenshtein\n          ) {\n            foundLevenshteinDistance = findLevenshteinDistance(\n              usedPassword,\n              rankedDict,\n              zxcvbnOptions.levenshteinThreshold,\n            )\n          }\n          const isLevenshteinMatch =\n            Object.keys(foundLevenshteinDistance).length !== 0\n\n          if (isInDictionary || isLevenshteinMatch) {\n            const usedRankPassword = isLevenshteinMatch\n              ? (foundLevenshteinDistance.levenshteinDistanceEntry as string)\n              : usedPassword\n\n            const rank = rankedDict[usedRankPassword]\n            matches.push({\n              pattern: 'dictionary',\n              i,\n              j,\n              token: password.slice(i, +j + 1 || 9e9),\n              matchedWord: usedPassword,\n              rank,\n              dictionaryName: dictionaryName as DictionaryNames,\n              reversed: false,\n              l33t: false,\n              ...foundLevenshteinDistance,\n            })\n          }\n        }\n      }\n    })\n    return matches\n  }\n}\n\nexport default MatchDictionary\n", "import { REGEXEN } from '../../data/const'\nimport { sorted } from '../../helper'\nimport { RegexMatch } from '../../types'\n\ninterface RegexMatchOptions {\n  password: string\n  regexes?: typeof REGEXEN\n}\n\ntype RegexesKeys = keyof typeof REGEXEN\n/*\n * -------------------------------------------------------------------------------\n *  regex matching ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchRegex {\n  match({ password, regexes = REGEXEN }: RegexMatchOptions) {\n    const matches: RegexMatch[] = []\n    Object.keys(regexes).forEach((name) => {\n      const regex = regexes[name as RegexesKeys]\n      regex.lastIndex = 0 // keeps regexMatch stateless\n\n      let regexMatch: RegExpExecArray | null\n      // eslint-disable-next-line no-cond-assign\n      while ((regexMatch = regex.exec(password))) {\n        if (regexMatch) {\n          const token = regexMatch[0]\n          matches.push({\n            pattern: 'regex',\n            token,\n            i: regexMatch.index,\n            j: regexMatch.index + regexMatch[0].length - 1,\n            regexName: name as RegexesKeys,\n            regexMatch,\n          })\n        }\n      }\n    })\n    return sorted(matches)\n  }\n}\n\nexport default MatchRegex\n", "export default {\n  // binomial coefficients\n  // src: http://blog.plover.com/math/choose.html\n  nCk(n: number, k: number) {\n    let count = n\n    if (k > count) {\n      return 0\n    }\n    if (k === 0) {\n      return 1\n    }\n    let coEff = 1\n    for (let i = 1; i <= k; i += 1) {\n      coEff *= count\n      coEff /= i\n      count -= 1\n    }\n    return coEff\n  },\n  log10(n: number) {\n    if (n === 0) return 0\n    return Math.log(n) / Math.log(10) // IE doesn't support Math.log10 :(\n  },\n  log2(n: number) {\n    return Math.log(n) / Math.log(2)\n  },\n  factorial(num: number) {\n    let rval = 1\n    for (let i = 2; i <= num; i += 1) rval *= i\n    return rval\n  },\n}\n", "import {\n  BRUTEFORCE_CARDINALITY,\n  MIN_SUBMATCH_GUESSES_SINGLE_CHAR,\n  MIN_SUBMATCH_GUESSES_MULTI_CHAR,\n} from '../../data/const'\nimport { MatchEstimated, MatchExtended } from '../../types'\n\nexport default ({ token }: MatchExtended | MatchEstimated) => {\n  let guesses = BRUTEFORCE_CARDINALITY ** token.length\n  if (guesses === Number.POSITIVE_INFINITY) {\n    guesses = Number.MAX_VALUE\n  }\n  let minGuesses\n  // small detail: make bruteforce matches at minimum one guess bigger than smallest allowed\n  // submatch guesses, such that non-bruteforce submatches over the same [i..j] take precedence.\n  if (token.length === 1) {\n    minGuesses = MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1\n  } else {\n    minGuesses = MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1\n  }\n\n  return Math.max(guesses, minGuesses)\n}\n", "import { MIN_YEAR_SPACE, REFERENCE_YEAR } from '../../data/const'\nimport { MatchEstimated, MatchExtended } from '../../types'\n\nexport default ({ year, separator }: MatchExtended | MatchEstimated) => {\n  // base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n  const yearSpace = Math.max(Math.abs(year - REFERENCE_YEAR), MIN_YEAR_SPACE)\n\n  let guesses = yearSpace * 365\n  // add factor of 4 for separator selection (one of ~4 choices)\n  if (separator) {\n    guesses *= 4\n  }\n  return guesses\n}\n", "import utils from '../../../../scoring/utils'\nimport {\n  START_UPPER,\n  END_UPPER,\n  ALL_UPPER_INVERTED,\n  ALL_LOWER_INVERTED,\n  ONE_LOWER,\n  ONE_UPPER,\n  ALPHA_INVERTED,\n} from '../../../../data/const'\n\nconst getVariations = (cleanedWord: string) => {\n  const wordArray = cleanedWord.split('')\n  const upperCaseCount = wordArray.filter((char) =>\n    char.match(ONE_UPPER),\n  ).length\n  const lowerCaseCount = wordArray.filter((char) =>\n    char.match(ONE_LOWER),\n  ).length\n\n  let variations = 0\n  const variationLength = Math.min(upperCaseCount, lowerCaseCount)\n  for (let i = 1; i <= variationLength; i += 1) {\n    variations += utils.nCk(upperCaseCount + lowerCaseCount, i)\n  }\n  return variations\n}\n\nexport default (word: string) => {\n  // clean words of non alpha characters to remove the reward effekt to capitalize the first letter https://github.com/dropbox/zxcvbn/issues/232\n  const cleanedWord = word.replace(ALPHA_INVERTED, '')\n  if (\n    cleanedWord.match(ALL_LOWER_INVERTED) ||\n    cleanedWord.toLowerCase() === cleanedWord\n  ) {\n    return 1\n  }\n  // a capitalized word is the most common capitalization scheme,\n  // so it only doubles the search space (uncapitalized + capitalized).\n  // all caps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n  const commonCases = [START_UPPER, END_UPPER, ALL_UPPER_INVERTED]\n  const commonCasesLength = commonCases.length\n  for (let i = 0; i < commonCasesLength; i += 1) {\n    const regex = commonCases[i]\n    if (cleanedWord.match(regex)) {\n      return 2\n    }\n  }\n\n  // otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n  // with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n  // the number of ways to lowercase U+L letters with L lowercase letters or less.\n  return getVariations(cleanedWord)\n}\n", "import utils from '../../../../scoring/utils'\nimport { PasswordChanges } from '../matching/unmunger/getCleanPasswords'\n\nexport interface L33tOptions {\n  l33t: string\n  subs: PasswordChanges[]\n  token: string\n}\n\nexport interface GetCountsOptions {\n  token: string\n  sub: PasswordChanges\n}\n\nconst countSubstring = (string: string, substring: string) => {\n  let count = 0\n  let pos = string.indexOf(substring)\n  while (pos >= 0) {\n    count += 1\n    pos = string.indexOf(substring, pos + substring.length)\n  }\n  return count\n}\n\nconst getCounts = ({ sub, token }: GetCountsOptions) => {\n  // lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n  const tokenLower = token.toLowerCase()\n  // num of subbed chars\n  const subbedCount = countSubstring(tokenLower, sub.substitution)\n\n  // num of unsubbed chars\n  const unsubbedCount = countSubstring(tokenLower, sub.letter)\n  return {\n    subbedCount,\n    unsubbedCount,\n  }\n}\n\nexport default ({ l33t, subs, token }: L33tOptions) => {\n  if (!l33t) {\n    return 1\n  }\n  let variations = 1\n  subs.forEach((sub) => {\n    const { subbedCount, unsubbedCount } = getCounts({ sub, token })\n\n    if (subbedCount === 0 || unsubbedCount === 0) {\n      // for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n      // treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n      // unsubbed.)\n      variations *= 2\n    } else {\n      // this case is similar to capitalization:\n      // with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n      const p = Math.min(unsubbedCount, subbedCount)\n      let possibilities = 0\n      for (let i = 1; i <= p; i += 1) {\n        possibilities += utils.nCk(unsubbedCount + subbedCount, i)\n      }\n      variations *= possibilities\n    }\n  })\n  return variations\n}\n", "import uppercaseVariant from './variants/scoring/uppercase'\nimport l33tVariant from './variants/scoring/l33t'\nimport { MatchEstimated, MatchExtended } from '../../types'\n\nexport interface DictionaryReturn {\n  baseGuesses: number\n  uppercaseVariations: number\n  l33tVariations: number\n  calculation: number\n}\n\nexport default ({\n  rank,\n  reversed,\n  l33t,\n  subs,\n  token,\n  dictionaryName,\n}: MatchExtended | MatchEstimated): DictionaryReturn => {\n  const baseGuesses = rank // keep these as properties for display purposes\n  const uppercaseVariations = uppercaseVariant(token)\n  const l33tVariations = l33tVariant({ l33t, subs, token })\n  const reversedVariations = (reversed && 2) || 1\n  let calculation\n  if (dictionaryName === 'diceware') {\n    // diceware dictionaries are special, so we get a simple scoring of 1/2 of 6^5 (6 digits on 5 dice)\n    // to get fix entropy of ~12.9 bits for every entry https://en.wikipedia.org/wiki/Diceware#:~:text=The%20level%20of,bits\n    calculation = 6 ** 5 / 2\n  } else {\n    calculation =\n      baseGuesses * uppercaseVariations * l33tVariations * reversedVariations\n  }\n  return {\n    baseGuesses,\n    uppercaseVariations,\n    l33tVariations,\n    calculation,\n  }\n}\n", "import { MIN_YEAR_SPACE, REFERENCE_YEAR } from '../../data/const'\nimport { MatchEstimated, MatchExtended } from '../../types'\n\nexport default ({\n  regexName,\n  regexMatch,\n  token,\n}: MatchExtended | MatchEstimated) => {\n  const charClassBases = {\n    alphaLower: 26,\n    alphaUpper: 26,\n    alpha: 52,\n    alphanumeric: 62,\n    digits: 10,\n    symbols: 33,\n  }\n  if (regexName in charClassBases) {\n    return (\n      charClassBases[regexName as keyof typeof charClassBases] ** token.length\n    )\n  }\n  // TODO add more regex types for example special dates like 09.11\n  // eslint-disable-next-line default-case\n  switch (regexName) {\n    case 'recentYear':\n      // conservative estimate of year space: num years from REFERENCE_YEAR.\n      // if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n      return Math.max(\n        Math.abs(parseInt(regexMatch[0], 10) - REFERENCE_YEAR),\n        MIN_YEAR_SPACE,\n      )\n  }\n  return 0\n}\n", "import { MatchEstimated, MatchExtended } from '../../types'\n\nexport default ({ baseGuesses, repeatCount }: MatchExtended | MatchEstimated) =>\n  baseGuesses * repeatCount\n", "import { MatchEstimated, MatchExtended } from '../../types'\n\nexport default ({ token, ascending }: MatchExtended | MatchEstimated) => {\n  const firstChr = token.charAt(0)\n  let baseGuesses = 0\n  const startingPoints = ['a', 'A', 'z', 'Z', '0', '1', '9']\n  // lower guesses for obvious starting points\n  if (startingPoints.includes(firstChr)) {\n    baseGuesses = 4\n  } else if (firstChr.match(/\\d/)) {\n    baseGuesses = 10 // digits\n  } else {\n    // could give a higher base for uppercase,\n    // assigning 26 to both upper and lower sequences is more conservative.\n    baseGuesses = 26\n  }\n  // need to try a descending sequence in addition to every ascending sequence ->\n  // 2x guesses\n  if (!ascending) {\n    baseGuesses *= 2\n  }\n  return baseGuesses * token.length\n}\n", "import utils from '../../scoring/utils'\nimport { zxcvbnOptions } from '../../Options'\nimport { LooseObject, MatchEstimated, MatchExtended } from '../../types'\n\ninterface EstimatePossiblePatternsOptions {\n  token: string\n  graph: string\n  turns: number\n}\n\nconst calcAverageDegree = (graph: LooseObject) => {\n  let average = 0\n  Object.keys(graph).forEach((key) => {\n    const neighbors = graph[key]\n    average += neighbors.filter((entry: string) => !!entry).length\n  })\n  average /= Object.entries(graph).length\n  return average\n}\n\nconst estimatePossiblePatterns = ({\n  token,\n  graph,\n  turns,\n}: EstimatePossiblePatternsOptions) => {\n  const startingPosition = Object.keys(zxcvbnOptions.graphs[graph]).length\n  const averageDegree = calcAverageDegree(zxcvbnOptions.graphs[graph])\n\n  let guesses = 0\n  const tokenLength = token.length\n  // # estimate the number of possible patterns w/ tokenLength or less with turns or less.\n  for (let i = 2; i <= tokenLength; i += 1) {\n    const possibleTurns = Math.min(turns, i - 1)\n    for (let j = 1; j <= possibleTurns; j += 1) {\n      guesses += utils.nCk(i - 1, j - 1) * startingPosition * averageDegree ** j\n    }\n  }\n  return guesses\n}\n\nexport default ({\n  graph,\n  token,\n  shiftedCount,\n  turns,\n}: MatchExtended | MatchEstimated) => {\n  let guesses = estimatePossiblePatterns({ token, graph, turns })\n\n  // add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n  // math is similar to extra guesses of l33t substitutions in dictionary matches.\n  if (shiftedCount) {\n    const unShiftedCount = token.length - shiftedCount\n    if (shiftedCount === 0 || unShiftedCount === 0) {\n      guesses *= 2\n    } else {\n      let shiftedVariations = 0\n      for (let i = 1; i <= Math.min(shiftedCount, unShiftedCount); i += 1) {\n        shiftedVariations += utils.nCk(shiftedCount + unShiftedCount, i)\n      }\n      guesses *= shiftedVariations\n    }\n  }\n  return Math.round(guesses)\n}\n", "import { SEPERATOR_CHAR_COUNT } from '../../data/const'\n\nexport default () => {\n  return SEPERATOR_CHAR_COUNT\n}\n", "import {\n  MIN_SUBMATCH_GUESSES_SINGLE_CHAR,\n  MIN_SUBMATCH_GUESSES_MULTI_CHAR,\n} from '../data/const'\nimport utils from './utils'\nimport { zxcvbnOptions } from '../Options'\nimport {\n  DefaultScoringFunction,\n  LooseObject,\n  MatchEstimated,\n  MatchExtended,\n} from '../types'\nimport bruteforceMatcher from '../matcher/bruteforce/scoring'\nimport dateMatcher from '../matcher/date/scoring'\nimport dictionaryMatcher from '../matcher/dictionary/scoring'\nimport regexMatcher from '../matcher/regex/scoring'\nimport repeatMatcher from '../matcher/repeat/scoring'\nimport sequenceMatcher from '../matcher/sequence/scoring'\nimport spatialMatcher from '../matcher/spatial/scoring'\nimport separatorMatcher from '../matcher/separator/scoring'\n\nconst getMinGuesses = (\n  match: MatchExtended | MatchEstimated,\n  password: string,\n) => {\n  let minGuesses = 1\n  if (match.token.length < password.length) {\n    if (match.token.length === 1) {\n      minGuesses = MIN_SUBMATCH_GUESSES_SINGLE_CHAR\n    } else {\n      minGuesses = MIN_SUBMATCH_GUESSES_MULTI_CHAR\n    }\n  }\n  return minGuesses\n}\n\ntype Matchers = {\n  [key: string]: DefaultScoringFunction\n}\n\nconst matchers: Matchers = {\n  bruteforce: bruteforceMatcher,\n  date: dateMatcher,\n  dictionary: dictionaryMatcher,\n  regex: regexMatcher,\n  repeat: repeatMatcher,\n  sequence: sequenceMatcher,\n  spatial: spatialMatcher,\n  separator: separatorMatcher,\n}\n\nconst getScoring = (name: string, match: MatchExtended | MatchEstimated) => {\n  if (matchers[name]) {\n    return matchers[name](match)\n  }\n  if (\n    zxcvbnOptions.matchers[name] &&\n    'scoring' in zxcvbnOptions.matchers[name]\n  ) {\n    return zxcvbnOptions.matchers[name].scoring(match)\n  }\n  return 0\n}\n\n// ------------------------------------------------------------------------------\n// guess estimation -- one function per match pattern ---------------------------\n// ------------------------------------------------------------------------------\n// eslint-disable-next-line complexity, max-statements\nexport default (match: MatchExtended | MatchEstimated, password: string) => {\n  const extraData: LooseObject = {}\n  // a match's guess estimate doesn't change. cache it.\n  if ('guesses' in match && match.guesses != null) {\n    return match\n  }\n\n  const minGuesses = getMinGuesses(match, password)\n\n  const estimationResult = getScoring(match.pattern, match)\n  let guesses = 0\n  if (typeof estimationResult === 'number') {\n    guesses = estimationResult\n  } else if (match.pattern === 'dictionary') {\n    guesses = estimationResult.calculation\n    extraData.baseGuesses = estimationResult.baseGuesses\n    extraData.uppercaseVariations = estimationResult.uppercaseVariations\n    extraData.l33tVariations = estimationResult.l33tVariations\n  }\n\n  const matchGuesses = Math.max(guesses, minGuesses)\n  return {\n    ...match,\n    ...extraData,\n    guesses: matchGuesses,\n    guessesLog10: utils.log10(matchGuesses),\n  }\n}\n", "import utils from './utils'\nimport estimateGuesses from './estimate'\nimport { MIN_GUESSES_BEFORE_GROWING_SEQUENCE } from '../data/const'\nimport {\n  MatchExtended,\n  BruteForceMatch,\n  MatchEstimated,\n  LooseObject,\n} from '../types'\n\nconst scoringHelper = {\n  password: '',\n  optimal: {} as any,\n  excludeAdditive: false,\n  separatorRegex: undefined as RegExp | null | undefined,\n  fillArray(size: number, valueType: 'object' | 'array') {\n    const result: typeof valueType extends 'array' ? string[] : LooseObject[] =\n      []\n    for (let i = 0; i < size; i += 1) {\n      let value: [] | LooseObject = []\n      if (valueType === 'object') {\n        value = {}\n      }\n      result.push(value)\n    }\n    return result\n  },\n  // helper: make bruteforce match objects spanning i to j, inclusive.\n  makeBruteforceMatch(i: number, j: number): BruteForceMatch {\n    return {\n      pattern: 'bruteforce',\n      token: this.password.slice(i, +j + 1 || 9e9),\n      i,\n      j,\n    }\n  },\n  // helper: considers whether a length-sequenceLength\n  // sequence ending at match m is better (fewer guesses)\n  // than previously encountered sequences, updating state if so.\n  update(match: MatchExtended, sequenceLength: number) {\n    const k = match.j\n    const estimatedMatch = estimateGuesses(match, this.password)\n    let pi = estimatedMatch.guesses as number\n    if (sequenceLength > 1) {\n      // we're considering a length-sequenceLength sequence ending with match m:\n      // obtain the product term in the minimization function by multiplying m's guesses\n      // by the product of the length-(sequenceLength-1)\n      // sequence ending just before m, at m.i - 1.\n      pi *= this.optimal.pi[estimatedMatch.i - 1][sequenceLength - 1]\n    }\n    // calculate the minimization func\n    let g = utils.factorial(sequenceLength) * pi\n    if (!this.excludeAdditive) {\n      g += MIN_GUESSES_BEFORE_GROWING_SEQUENCE ** (sequenceLength - 1)\n    }\n    // update state if new best.\n    // first see if any competing sequences covering this prefix,\n    // with sequenceLength or fewer matches,\n    // fare better than this sequence. if so, skip it and return.\n    let shouldSkip = false\n    Object.keys(this.optimal.g[k]).forEach((competingPatternLength) => {\n      const competingMetricMatch = this.optimal.g[k][competingPatternLength]\n      if (parseInt(competingPatternLength, 10) <= sequenceLength) {\n        if (competingMetricMatch <= g) {\n          shouldSkip = true\n        }\n      }\n    })\n    if (!shouldSkip) {\n      // this sequence might be part of the final optimal sequence.\n      this.optimal.g[k][sequenceLength] = g\n      this.optimal.m[k][sequenceLength] = estimatedMatch\n      this.optimal.pi[k][sequenceLength] = pi\n    }\n  },\n\n  // helper: evaluate bruteforce matches ending at passwordCharIndex.\n  bruteforceUpdate(passwordCharIndex: number) {\n    // see if a single bruteforce match spanning the passwordCharIndex-prefix is optimal.\n    let match = this.makeBruteforceMatch(0, passwordCharIndex)\n    this.update(match, 1)\n\n    for (let i = 1; i <= passwordCharIndex; i += 1) {\n      // generate passwordCharIndex bruteforce matches, spanning from (i=1, j=passwordCharIndex) up to (i=passwordCharIndex, j=passwordCharIndex).\n      // see if adding these new matches to any of the sequences in optimal[i-1]\n      // leads to new bests.\n      match = this.makeBruteforceMatch(i, passwordCharIndex)\n      const tmp = this.optimal.m[i - 1]\n      // eslint-disable-next-line no-loop-func\n      Object.keys(tmp).forEach((sequenceLength) => {\n        const lastMatch = tmp[sequenceLength]\n        // corner: an optimal sequence will never have two adjacent bruteforce matches.\n        // it is strictly better to have a single bruteforce match spanning the same region:\n        // same contribution to the guess product with a lower length.\n        // --> safe to skip those cases.\n        if (lastMatch.pattern !== 'bruteforce') {\n          // try adding m to this length-sequenceLength sequence.\n          this.update(match, parseInt(sequenceLength, 10) + 1)\n        }\n      })\n    }\n  },\n\n  // helper: step backwards through optimal.m starting at the end,\n  // constructing the final optimal match sequence.\n  unwind(passwordLength: number) {\n    const optimalMatchSequence: MatchEstimated[] = []\n    let k = passwordLength - 1\n    // find the final best sequence length and score\n    let sequenceLength = 0\n    // eslint-disable-next-line no-loss-of-precision\n    let g = 2e308\n    const temp = this.optimal.g[k]\n    // safety check for empty passwords\n    if (temp) {\n      Object.keys(temp).forEach((candidateSequenceLength) => {\n        const candidateMetricMatch = temp[candidateSequenceLength]\n        if (candidateMetricMatch < g) {\n          sequenceLength = parseInt(candidateSequenceLength, 10)\n          g = candidateMetricMatch\n        }\n      })\n    }\n    while (k >= 0) {\n      const match: MatchEstimated = this.optimal.m[k][sequenceLength]\n      optimalMatchSequence.unshift(match)\n      k = match.i - 1\n      sequenceLength -= 1\n    }\n    return optimalMatchSequence\n  },\n}\n\nexport default {\n  // ------------------------------------------------------------------------------\n  // search --- most guessable match sequence -------------------------------------\n  // ------------------------------------------------------------------------------\n  //\n  // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n  // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n  // for a length-n password with m candidate matches. l_max is the maximum optimal\n  // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n  // search terminates rapidly.\n  //\n  // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n  // minimizes the following function:\n  //\n  //    g = sequenceLength! * Product(m.guesses for m in sequence) + D^(sequenceLength - 1)\n  //\n  // where sequenceLength is the length of the sequence.\n  //\n  // the factorial term is the number of ways to order sequenceLength patterns.\n  //\n  // the D^(sequenceLength-1) term is another length penalty, roughly capturing the idea that an\n  // attacker will try lower-length sequences first before trying length-sequenceLength sequences.\n  //\n  // for example, consider a sequence that is date-repeat-dictionary.\n  //  - an attacker would need to try other date-repeat-dictionary combinations,\n  //    hence the product term.\n  //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n  //    ..., hence the factorial term.\n  //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n  //    sequences before length-3. assuming at minimum D guesses per pattern type,\n  //    D^(sequenceLength-1) approximates Sum(D^i for i in [1..sequenceLength-1]\n  //\n  // ------------------------------------------------------------------------------\n  mostGuessableMatchSequence(\n    password: string,\n    matches: MatchExtended[],\n    excludeAdditive = false,\n  ) {\n    scoringHelper.password = password\n    scoringHelper.excludeAdditive = excludeAdditive\n    const passwordLength = password.length\n    // partition matches into sublists according to ending index j\n    let matchesByCoordinateJ = scoringHelper.fillArray(\n      passwordLength,\n      'array',\n    ) as any[]\n\n    matches.forEach((match) => {\n      matchesByCoordinateJ[match.j].push(match)\n    })\n    // small detail: for deterministic output, sort each sublist by i.\n    matchesByCoordinateJ = matchesByCoordinateJ.map((match) =>\n      match.sort((m1: MatchExtended, m2: MatchExtended) => m1.i - m2.i),\n    )\n\n    scoringHelper.optimal = {\n      // optimal.m[k][sequenceLength] holds final match in the best length-sequenceLength\n      // match sequence covering the\n      // password prefix up to k, inclusive.\n      // if there is no length-sequenceLength sequence that scores better (fewer guesses) than\n      // a shorter match sequence spanning the same prefix,\n      // optimal.m[k][sequenceLength] is undefined.\n      m: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n      // optimal.pi allows for fast (non-looping) updates to the minimization function.\n      pi: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the overall metric.\n      g: scoringHelper.fillArray(passwordLength, 'object'),\n    }\n\n    for (let k = 0; k < passwordLength; k += 1) {\n      matchesByCoordinateJ[k].forEach((match: MatchExtended) => {\n        if (match.i > 0) {\n          Object.keys(scoringHelper.optimal.m[match.i - 1]).forEach(\n            (sequenceLength) => {\n              scoringHelper.update(match, parseInt(sequenceLength, 10) + 1)\n            },\n          )\n        } else {\n          scoringHelper.update(match, 1)\n        }\n      })\n      scoringHelper.bruteforceUpdate(k)\n    }\n    const optimalMatchSequence = scoringHelper.unwind(passwordLength)\n    const optimalSequenceLength = optimalMatchSequence.length\n    const guesses = this.getGuesses(password, optimalSequenceLength)\n    return {\n      password,\n      guesses,\n      guessesLog10: utils.log10(guesses),\n      sequence: optimalMatchSequence,\n    }\n  },\n\n  getGuesses(password: string, optimalSequenceLength: number) {\n    const passwordLength = password.length\n    let guesses = 0\n    if (password.length === 0) {\n      guesses = 1\n    } else {\n      guesses =\n        scoringHelper.optimal.g[passwordLength - 1][optimalSequenceLength]\n    }\n    return guesses\n  },\n}\n", "import { RepeatMatch } from '../../types'\nimport scoring from '../../scoring'\nimport Matching from '../../Matching'\n\nfunction createRegex({\n  isLazy = false,\n  isAnchored = false,\n  flags = '',\n}): RegExp {\n  return new RegExp(\n    `${isAnchored ? '^' : ''}(.+${isLazy ? '?' : ''})\\\\1+${\n      isAnchored ? '$' : ''\n    }`,\n    flags,\n  )\n}\n\ninterface RepeatMatchOptions {\n  password: string\n  omniMatch: Matching\n}\n/*\n *-------------------------------------------------------------------------------\n * repeats (aaa, abcabcabc) ------------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchRepeat {\n  // eslint-disable-next-line max-statements\n  match({ password, omniMatch }: RepeatMatchOptions) {\n    const matches: (RepeatMatch | Promise<RepeatMatch>)[] = []\n    let lastIndex = 0\n    while (lastIndex < password.length) {\n      const greedyMatch = this.getGreedyMatch(password, lastIndex)\n      const lazyMatch = this.getLazyMatch(password, lastIndex)\n      if (greedyMatch == null) {\n        break\n      }\n      const { match, baseToken } = this.setMatchToken(greedyMatch, lazyMatch)\n\n      if (match) {\n        const j = match.index + match[0].length - 1\n        const baseGuesses = this.getBaseGuesses(baseToken, omniMatch)\n        matches.push(this.normalizeMatch(baseToken, j, match, baseGuesses))\n\n        lastIndex = j + 1\n      }\n    }\n\n    const hasPromises = matches.some((match) => {\n      return match instanceof Promise\n    })\n    if (hasPromises) {\n      return Promise.all(matches)\n    }\n    return matches as RepeatMatch[]\n  }\n\n  // eslint-disable-next-line max-params\n  normalizeMatch(\n    baseToken: string,\n    j: number,\n    match: RegExpExecArray,\n    baseGuesses: number | Promise<number>,\n  ) {\n    const baseMatch: RepeatMatch = {\n      pattern: 'repeat',\n      i: match.index,\n      j,\n      token: match[0],\n      baseToken,\n      baseGuesses: 0,\n      repeatCount: match[0].length / baseToken.length,\n    }\n    if (baseGuesses instanceof Promise) {\n      return baseGuesses.then((resolvedBaseGuesses) => {\n        return {\n          ...baseMatch,\n          baseGuesses: resolvedBaseGuesses,\n        } as RepeatMatch\n      })\n    }\n    return {\n      ...baseMatch,\n      baseGuesses,\n    } as RepeatMatch\n  }\n\n  getGreedyMatch(password: string, lastIndex: number) {\n    const greedy = createRegex({ isLazy: false, flags: 'g' })\n    greedy.lastIndex = lastIndex\n    return greedy.exec(password)\n  }\n\n  getLazyMatch(password: string, lastIndex: number) {\n    const lazy = createRegex({ isLazy: true, flags: 'g' })\n    lazy.lastIndex = lastIndex\n    return lazy.exec(password)\n  }\n\n  setMatchToken(\n    greedyMatch: RegExpExecArray,\n    lazyMatch: RegExpExecArray | null,\n  ) {\n    const lazyAnchored = createRegex({ isLazy: true, isAnchored: true })\n    let match\n    let baseToken = ''\n    if (lazyMatch && greedyMatch[0].length > lazyMatch[0].length) {\n      // greedy beats lazy for 'aabaab'\n      // greedy: [aabaab, aab]\n      // lazy:   [aa,     a]\n      match = greedyMatch\n      // greedy's repeated string might itself be repeated, eg.\n      // aabaab in aabaabaabaab.\n      // run an anchored lazy match on greedy's repeated string\n      // to find the shortest repeated string\n      const temp = lazyAnchored.exec(match[0])\n      if (temp) {\n        baseToken = temp[1]\n      }\n    } else {\n      // lazy beats greedy for 'aaaaa'\n      // greedy: [aaaa,  aa]\n      // lazy:   [aaaaa, a]\n      match = lazyMatch\n      if (match) {\n        baseToken = match[1]\n      }\n    }\n    return {\n      match,\n      baseToken,\n    }\n  }\n\n  getBaseGuesses(baseToken: string, omniMatch: Matching) {\n    const matches = omniMatch.match(baseToken)\n    if (matches instanceof Promise) {\n      return matches.then((resolvedMatches) => {\n        const baseAnalysis = scoring.mostGuessableMatchSequence(\n          baseToken,\n          resolvedMatches,\n        )\n        return baseAnalysis.guesses\n      })\n    }\n    const baseAnalysis = scoring.mostGuessableMatchSequence(baseToken, matches)\n    return baseAnalysis.guesses\n  }\n}\n\nexport default MatchRepeat\n", "import { ALL_UPPER, ALL_LOWER, ALL_DIGIT } from '../../data/const'\nimport { SequenceMatch } from '../../types'\n\ntype UpdateParams = {\n  i: number\n  j: number\n  delta: number\n  password: string\n  result: any[]\n}\n\ninterface SequenceMatchOptions {\n  password: string\n}\n/*\n *-------------------------------------------------------------------------------\n * sequences (abcdef) ------------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchSequence {\n  MAX_DELTA = 5\n\n  // eslint-disable-next-line max-statements\n  match({ password }: SequenceMatchOptions) {\n    /*\n     * Identifies sequences by looking for repeated differences in unicode codepoint.\n     * this allows skipping, such as 9753, and also matches some extended unicode sequences\n     * such as Greek and Cyrillic alphabets.\n     *\n     * for example, consider the input 'abcdb975zy'\n     *\n     * password: a   b   c   d   b    9   7   5   z   y\n     * index:    0   1   2   3   4    5   6   7   8   9\n     * delta:      1   1   1  -2  -41  -2  -2  69   1\n     *\n     * expected result:\n     * [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n     */\n    const result: SequenceMatch[] = []\n    if (password.length === 1) {\n      return []\n    }\n    let i = 0\n    let lastDelta: number | null = null\n    const passwordLength = password.length\n    for (let k = 1; k < passwordLength; k += 1) {\n      const delta = password.charCodeAt(k) - password.charCodeAt(k - 1)\n      if (lastDelta == null) {\n        lastDelta = delta\n      }\n      if (delta !== lastDelta) {\n        const j = k - 1\n        this.update({\n          i,\n          j,\n          delta: lastDelta,\n          password,\n          result,\n        })\n        i = j\n        lastDelta = delta\n      }\n    }\n    this.update({\n      i,\n      j: passwordLength - 1,\n      delta: lastDelta as number,\n      password,\n      result,\n    })\n    return result\n  }\n\n  update({ i, j, delta, password, result }: UpdateParams) {\n    if (j - i > 1 || Math.abs(delta) === 1) {\n      const absoluteDelta = Math.abs(delta)\n      if (absoluteDelta > 0 && absoluteDelta <= this.MAX_DELTA) {\n        const token = password.slice(i, +j + 1 || 9e9)\n        const { sequenceName, sequenceSpace } = this.getSequence(token)\n        return result.push({\n          pattern: 'sequence',\n          i,\n          j,\n          token: password.slice(i, +j + 1 || 9e9),\n          sequenceName,\n          sequenceSpace,\n          ascending: delta > 0,\n        })\n      }\n    }\n    return null\n  }\n\n  getSequence(token: string) {\n    // TODO conservatively stick with roman alphabet size.\n    //  (this could be improved)\n    let sequenceName = 'unicode'\n    let sequenceSpace = 26\n\n    if (ALL_LOWER.test(token)) {\n      sequenceName = 'lower'\n      sequenceSpace = 26\n    } else if (ALL_UPPER.test(token)) {\n      sequenceName = 'upper'\n      sequenceSpace = 26\n    } else if (ALL_DIGIT.test(token)) {\n      sequenceName = 'digits'\n      sequenceSpace = 10\n    }\n    return {\n      sequenceName,\n      sequenceSpace,\n    }\n  }\n}\n\nexport default MatchSequence\n", "import { sorted, extend } from '../../helper'\nimport { zxcvbnOptions } from '../../Options'\nimport { LooseObject, SpatialMatch } from '../../types'\n\ninterface SpatialMatchOptions {\n  password: string\n}\n/*\n * ------------------------------------------------------------------------------\n * spatial match (qwerty/dvorak/keypad and so on) -----------------------------------------\n * ------------------------------------------------------------------------------\n */\nclass MatchSpatial {\n  SHIFTED_RX = /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/\n\n  match({ password }: SpatialMatchOptions) {\n    const matches: SpatialMatch[] = []\n    Object.keys(zxcvbnOptions.graphs).forEach((graphName) => {\n      const graph = zxcvbnOptions.graphs[graphName]\n      extend(matches, this.helper(password, graph, graphName))\n    })\n    return sorted(matches)\n  }\n\n  checkIfShifted(graphName: string, password: string, index: number) {\n    if (\n      !graphName.includes('keypad') &&\n      // initial character is shifted\n      this.SHIFTED_RX.test(password.charAt(index))\n    ) {\n      return 1\n    }\n    return 0\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  helper(password: string, graph: LooseObject, graphName: string) {\n    let shiftedCount\n    const matches: SpatialMatch[] = []\n    let i = 0\n    const passwordLength = password.length\n    while (i < passwordLength - 1) {\n      let j = i + 1\n      let lastDirection = null\n      let turns = 0\n      shiftedCount = this.checkIfShifted(graphName, password, i)\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const prevChar = password.charAt(j - 1)\n        const adjacents = graph[prevChar as keyof typeof graph] || []\n        let found = false\n        let foundDirection = -1\n        let curDirection = -1\n        // consider growing pattern by one character if j hasn't gone over the edge.\n        if (j < passwordLength) {\n          const curChar = password.charAt(j)\n          const adjacentsLength = adjacents.length\n          for (let k = 0; k < adjacentsLength; k += 1) {\n            const adjacent = adjacents[k]\n            curDirection += 1\n            // eslint-disable-next-line max-depth\n            if (adjacent) {\n              const adjacentIndex = adjacent.indexOf(curChar)\n              // eslint-disable-next-line max-depth\n              if (adjacentIndex !== -1) {\n                found = true\n                foundDirection = curDirection\n                // eslint-disable-next-line max-depth\n                if (adjacentIndex === 1) {\n                  // # index 1 in the adjacency means the key is shifted,\n                  // # 0 means unshifted: A vs a, % vs 5, etc.\n                  // # for example, 'q' is adjacent to the entry '2@'.\n                  // # @ is shifted w/ index 1, 2 is unshifted.\n                  shiftedCount += 1\n                }\n                // eslint-disable-next-line max-depth\n                if (lastDirection !== foundDirection) {\n                  // # adding a turn is correct even in the initial\n                  // case when last_direction is null:\n                  // # every spatial pattern starts with a turn.\n                  turns += 1\n                  lastDirection = foundDirection\n                }\n                break\n              }\n            }\n          }\n        }\n        // if the current pattern continued, extend j and try to grow again\n        if (found) {\n          j += 1\n          // otherwise push the pattern discovered so far, if any...\n        } else {\n          // don't consider length 1 or 2 chains.\n          if (j - i > 2) {\n            matches.push({\n              pattern: 'spatial',\n              i,\n              j: j - 1,\n              token: password.slice(i, j),\n              graph: graphName,\n              turns,\n              shiftedCount,\n            })\n          }\n          // ...and then start a new search for the rest of the password.\n          i = j\n          break\n        }\n      }\n    }\n    return matches\n  }\n}\n\nexport default MatchSpatial\n", "import { SEPERATOR_CHARS } from '../../data/const'\nimport { SeparatorMatch } from '../../types'\n\ninterface SeparatorMatchOptions {\n  password: string\n}\n\nconst separatorRegex = new RegExp(`[${SEPERATOR_CHARS.join('')}]`)\n\n/*\n *-------------------------------------------------------------------------------\n * separators (any semi-repeated special character) -----------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchSeparator {\n  static getMostUsedSeparatorChar(password: string): string | undefined {\n    const mostUsedSeperators = [\n      ...password\n        .split('')\n        .filter((c) => separatorRegex.test(c))\n        .reduce((memo, c) => {\n          const m = memo.get(c)\n          if (m) {\n            memo.set(c, m + 1)\n          } else {\n            memo.set(c, 1)\n          }\n          return memo\n        }, new Map())\n        .entries(),\n    ].sort(([_a, a], [_b, b]) => b - a)\n    if (!mostUsedSeperators.length) return undefined\n    const match = mostUsedSeperators[0]\n    // If the special character is only used once, don't treat it like a separator\n    if (match[1] < 2) return undefined\n    return match[0]\n  }\n\n  static getSeparatorRegex(separator: string): RegExp {\n    return new RegExp(`([^${separator}\\n])(${separator})(?!${separator})`, 'g')\n    // negative lookbehind can be added again in a few years when it is more supported by the browsers (currently 2023)\n    // https://github.com/zxcvbn-ts/zxcvbn/issues/202\n    // return new RegExp(`(?<!${separator})(${separator})(?!${separator})`, 'g')\n  }\n\n  // eslint-disable-next-line max-statements\n  match({ password }: SeparatorMatchOptions) {\n    const result: SeparatorMatch[] = []\n\n    if (password.length === 0) return result\n\n    const mostUsedSpecial = MatchSeparator.getMostUsedSeparatorChar(password)\n    if (mostUsedSpecial === undefined) return result\n\n    const isSeparator = MatchSeparator.getSeparatorRegex(mostUsedSpecial)\n\n    // eslint-disable-next-line no-restricted-syntax\n    for (const match of password.matchAll(isSeparator)) {\n      // eslint-disable-next-line no-continue\n      if (match.index === undefined) continue\n\n      // add one to the index because we changed the regex from negative lookbehind to something simple.\n      // this simple approach uses the first character before the separater too but we only need the index of the separater\n      // https://github.com/zxcvbn-ts/zxcvbn/issues/202\n      const i = match.index + 1\n      result.push({\n        pattern: 'separator',\n        token: mostUsedSpecial,\n        i,\n        j: i,\n      })\n    }\n    return result\n  }\n}\n\nexport default MatchSeparator\n", "import { extend, sorted } from './helper'\nimport { MatchExtended, MatchingType } from './types'\nimport dateMatcher from './matcher/date/matching'\nimport dictionaryMatcher from './matcher/dictionary/matching'\nimport regexMatcher from './matcher/regex/matching'\nimport repeatMatcher from './matcher/repeat/matching'\nimport sequenceMatcher from './matcher/sequence/matching'\nimport spatialMatcher from './matcher/spatial/matching'\nimport separatorMatcher from './matcher/separator/matching'\nimport { zxcvbnOptions } from './Options'\n\n/*\n * -------------------------------------------------------------------------------\n *  Omnimatch combine matchers ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\n\ntype Matchers = {\n  [key: string]: MatchingType\n}\n\nclass Matching {\n  readonly matchers: Matchers = {\n    date: dateMatcher,\n    dictionary: dictionaryMatcher,\n    regex: regexMatcher,\n    // @ts-ignore => TODO resolve this type issue. This is because it is possible to be async\n    repeat: repeatMatcher,\n    sequence: sequenceMatcher,\n    spatial: spatialMatcher,\n    separator: separatorMatcher,\n  }\n\n  match(password: string): MatchExtended[] | Promise<MatchExtended[]> {\n    const matches: MatchExtended[] = []\n\n    const promises: Promise<MatchExtended[]>[] = []\n    const matchers = [\n      ...Object.keys(this.matchers),\n      ...Object.keys(zxcvbnOptions.matchers),\n    ]\n    matchers.forEach((key) => {\n      if (!this.matchers[key] && !zxcvbnOptions.matchers[key]) {\n        return\n      }\n      const Matcher = this.matchers[key]\n        ? this.matchers[key]\n        : zxcvbnOptions.matchers[key].Matching\n      const usedMatcher = new Matcher()\n      const result = usedMatcher.match({\n        password,\n        omniMatch: this,\n      })\n\n      if (result instanceof Promise) {\n        result.then((response) => {\n          extend(matches, response)\n        })\n        promises.push(result)\n      } else {\n        extend(matches, result)\n      }\n    })\n    if (promises.length > 0) {\n      return new Promise((resolve, reject) => {\n        Promise.all(promises)\n          .then(() => {\n            resolve(sorted(matches))\n          })\n          .catch((error) => {\n            reject(error)\n          })\n      })\n    }\n    return sorted(matches)\n  }\n}\n\nexport default Matching\n", "import { zxcvbnOptions } from './Options'\nimport { CrackTimesDisplay, CrackTimesSeconds, Score } from './types'\n\nconst SECOND = 1\nconst MINUTE = SECOND * 60\nconst HOUR = MINUTE * 60\nconst DAY = HOUR * 24\nconst MONTH = DAY * 31\nconst YEAR = MONTH * 12\nconst CENTURY = YEAR * 100\n\nconst times = {\n  second: SECOND,\n  minute: MINUTE,\n  hour: HOUR,\n  day: DAY,\n  month: MONTH,\n  year: YEAR,\n  century: CENTURY,\n}\n\n/*\n * -------------------------------------------------------------------------------\n *  Estimates time for an attacker ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass TimeEstimates {\n  translate(displayStr: string, value: number | undefined) {\n    let key = displayStr\n    if (value !== undefined && value !== 1) {\n      key += 's'\n    }\n    const { timeEstimation } = zxcvbnOptions.translations\n    return timeEstimation[key as keyof typeof timeEstimation].replace(\n      '{base}',\n      `${value}`,\n    )\n  }\n\n  estimateAttackTimes(guesses: number) {\n    const crackTimesSeconds: CrackTimesSeconds = {\n      onlineThrottling100PerHour: guesses / (100 / 3600),\n      onlineNoThrottling10PerSecond: guesses / 10,\n      offlineSlowHashing1e4PerSecond: guesses / 1e4,\n      offlineFastHashing1e10PerSecond: guesses / 1e10,\n    }\n    const crackTimesDisplay: CrackTimesDisplay = {\n      onlineThrottling100PerHour: '',\n      onlineNoThrottling10PerSecond: '',\n      offlineSlowHashing1e4PerSecond: '',\n      offlineFastHashing1e10PerSecond: '',\n    }\n    Object.keys(crackTimesSeconds).forEach((scenario) => {\n      const seconds = crackTimesSeconds[scenario as keyof CrackTimesSeconds]\n      crackTimesDisplay[scenario as keyof CrackTimesDisplay] =\n        this.displayTime(seconds)\n    })\n    return {\n      crackTimesSeconds,\n      crackTimesDisplay,\n      score: this.guessesToScore(guesses),\n    }\n  }\n\n  guessesToScore(guesses: number): Score {\n    const DELTA = 5\n    if (guesses < 1e3 + DELTA) {\n      // risky password: \"too guessable\"\n      return 0\n    }\n    if (guesses < 1e6 + DELTA) {\n      // modest protection from throttled online attacks: \"very guessable\"\n      return 1\n    }\n    if (guesses < 1e8 + DELTA) {\n      // modest protection from unthrottled online attacks: \"somewhat guessable\"\n      return 2\n    }\n    if (guesses < 1e10 + DELTA) {\n      // modest protection from offline attacks: \"safely unguessable\"\n      // assuming a salted, slow hash function like bcrypt, scrypt, PBKDF2, argon, etc\n      return 3\n    }\n    // strong protection from offline attacks under same scenario: \"very unguessable\"\n    return 4\n  }\n\n  displayTime(seconds: number) {\n    let displayStr = 'centuries'\n    let base\n    const timeKeys = Object.keys(times)\n    const foundIndex = timeKeys.findIndex(\n      (time) => seconds < times[time as keyof typeof times],\n    )\n    if (foundIndex > -1) {\n      displayStr = timeKeys[foundIndex - 1]\n      if (foundIndex !== 0) {\n        base = Math.round(seconds / times[displayStr as keyof typeof times])\n      } else {\n        displayStr = 'ltSecond'\n      }\n    }\n    return this.translate(displayStr, base)\n  }\n}\n\nexport default TimeEstimates\n", "export default () => {\n  return null\n}\n", "import { zxcvbnOptions } from '../../Options'\n\nexport default () => {\n  return {\n    warning: zxcvbnOptions.translations.warnings.dates,\n    suggestions: [zxcvbnOptions.translations.suggestions.dates],\n  }\n}\n", "import { zxcvbnOptions } from '../../Options'\nimport { MatchEstimated } from '../../types'\nimport { ALL_UPPER_INVERTED, START_UPPER } from '../../data/const'\n\nconst getDictionaryWarningPassword = (\n  match: MatchEstimated,\n  isSoleMatch?: boolean,\n) => {\n  let warning: string | null = null\n  if (isSoleMatch && !match.l33t && !match.reversed) {\n    if (match.rank <= 10) {\n      warning = zxcvbnOptions.translations.warnings.topTen\n    } else if (match.rank <= 100) {\n      warning = zxcvbnOptions.translations.warnings.topHundred\n    } else {\n      warning = zxcvbnOptions.translations.warnings.common\n    }\n  } else if (match.guessesLog10 <= 4) {\n    warning = zxcvbnOptions.translations.warnings.similarToCommon\n  }\n  return warning\n}\n\nconst getDictionaryWarningWikipedia = (\n  match: MatchEstimated,\n  isSoleMatch?: boolean,\n) => {\n  let warning: string | null = null\n  if (isSoleMatch) {\n    warning = zxcvbnOptions.translations.warnings.wordByItself\n  }\n  return warning\n}\n\nconst getDictionaryWarningNames = (\n  match: MatchEstimated,\n  isSoleMatch?: boolean,\n) => {\n  if (isSoleMatch) {\n    return zxcvbnOptions.translations.warnings.namesByThemselves\n  }\n  return zxcvbnOptions.translations.warnings.commonNames\n}\n\nconst getDictionaryWarning = (match: MatchEstimated, isSoleMatch?: boolean) => {\n  let warning: string | null = null\n  const dictName = match.dictionaryName\n  const isAName =\n    dictName === 'lastnames' || dictName.toLowerCase().includes('firstnames')\n  if (dictName === 'passwords') {\n    warning = getDictionaryWarningPassword(match, isSoleMatch)\n  } else if (dictName.includes('wikipedia')) {\n    warning = getDictionaryWarningWikipedia(match, isSoleMatch)\n  } else if (isAName) {\n    warning = getDictionaryWarningNames(match, isSoleMatch)\n  } else if (dictName === 'userInputs') {\n    warning = zxcvbnOptions.translations.warnings.userInputs\n  }\n  return warning\n}\n\nexport default (match: MatchEstimated, isSoleMatch?: boolean) => {\n  const warning = getDictionaryWarning(match, isSoleMatch)\n  const suggestions: string[] = []\n  const word = match.token\n\n  if (word.match(START_UPPER)) {\n    suggestions.push(zxcvbnOptions.translations.suggestions.capitalization)\n  } else if (word.match(ALL_UPPER_INVERTED) && word.toLowerCase() !== word) {\n    suggestions.push(zxcvbnOptions.translations.suggestions.allUppercase)\n  }\n  if (match.reversed && match.token.length >= 4) {\n    suggestions.push(zxcvbnOptions.translations.suggestions.reverseWords)\n  }\n  if (match.l33t) {\n    suggestions.push(zxcvbnOptions.translations.suggestions.l33t)\n  }\n  return {\n    warning,\n    suggestions,\n  }\n}\n", "import { zxcvbnOptions } from '../../Options'\nimport { MatchEstimated } from '../../types'\n\nexport default (match: MatchEstimated) => {\n  if (match.regexName === 'recentYear') {\n    return {\n      warning: zxcvbnOptions.translations.warnings.recentYears,\n      suggestions: [\n        zxcvbnOptions.translations.suggestions.recentYears,\n        zxcvbnOptions.translations.suggestions.associatedYears,\n      ],\n    }\n  }\n  return {\n    warning: null,\n    suggestions: [],\n  }\n}\n", "import { zxcvbnOptions } from '../../Options'\nimport { MatchEstimated } from '../../types'\n\nexport default (match: MatchEstimated) => {\n  let warning = zxcvbnOptions.translations.warnings.extendedRepeat\n  if (match.baseToken.length === 1) {\n    warning = zxcvbnOptions.translations.warnings.simpleRepeat\n  }\n\n  return {\n    warning,\n    suggestions: [zxcvbnOptions.translations.suggestions.repeated],\n  }\n}\n", "import { zxcvbnOptions } from '../../Options'\n\nexport default () => {\n  return {\n    warning: zxcvbnOptions.translations.warnings.sequences,\n    suggestions: [zxcvbnOptions.translations.suggestions.sequences],\n  }\n}\n", "import { zxcvbnOptions } from '../../Options'\nimport { MatchEstimated } from '../../types'\n\nexport default (match: MatchEstimated) => {\n  let warning = zxcvbnOptions.translations.warnings.keyPattern\n  if (match.turns === 1) {\n    warning = zxcvbnOptions.translations.warnings.straightRow\n  }\n  return {\n    warning,\n    suggestions: [zxcvbnOptions.translations.suggestions.longerKeyboardPattern],\n  }\n}\n", "export default () => {\n  // no suggestions\n  return null\n}\n", "import { zxcvbnOptions } from './Options'\nimport { DefaultFeedbackFunction, FeedbackType, MatchEstimated } from './types'\nimport bruteforceMatcher from './matcher/bruteforce/feedback'\nimport dateMatcher from './matcher/date/feedback'\nimport dictionaryMatcher from './matcher/dictionary/feedback'\nimport regexMatcher from './matcher/regex/feedback'\nimport repeatMatcher from './matcher/repeat/feedback'\nimport sequenceMatcher from './matcher/sequence/feedback'\nimport spatialMatcher from './matcher/spatial/feedback'\nimport separatorMatcher from './matcher/separator/feedback'\n\nconst defaultFeedback = {\n  warning: null,\n  suggestions: [],\n}\n\ntype Matchers = {\n  [key: string]: DefaultFeedbackFunction\n}\n/*\n * -------------------------------------------------------------------------------\n *  Generate feedback ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass Feedback {\n  readonly matchers: Matchers = {\n    bruteforce: bruteforceMatcher,\n    date: dateMatcher,\n    dictionary: dictionaryMatcher,\n    regex: regexMatcher,\n    repeat: repeatMatcher,\n    sequence: sequenceMatcher,\n    spatial: spatialMatcher,\n    separator: separatorMatcher,\n  }\n\n  defaultFeedback: FeedbackType = {\n    warning: null,\n    suggestions: [],\n  }\n\n  constructor() {\n    this.setDefaultSuggestions()\n  }\n\n  setDefaultSuggestions() {\n    this.defaultFeedback.suggestions.push(\n      zxcvbnOptions.translations.suggestions.useWords,\n      zxcvbnOptions.translations.suggestions.noNeed,\n    )\n  }\n\n  getFeedback(score: number, sequence: MatchEstimated[]) {\n    if (sequence.length === 0) {\n      return this.defaultFeedback\n    }\n    if (score > 2) {\n      return defaultFeedback\n    }\n    const extraFeedback = zxcvbnOptions.translations.suggestions.anotherWord\n    const longestMatch = this.getLongestMatch(sequence)\n    let feedback = this.getMatchFeedback(longestMatch, sequence.length === 1)\n    if (feedback !== null && feedback !== undefined) {\n      feedback.suggestions.unshift(extraFeedback)\n    } else {\n      feedback = {\n        warning: null,\n        suggestions: [extraFeedback],\n      }\n    }\n    return feedback\n  }\n\n  getLongestMatch(sequence: MatchEstimated[]) {\n    let longestMatch = sequence[0]\n    const slicedSequence = sequence.slice(1)\n    slicedSequence.forEach((match: MatchEstimated) => {\n      if (match.token.length > longestMatch.token.length) {\n        longestMatch = match\n      }\n    })\n    return longestMatch\n  }\n\n  getMatchFeedback(match: MatchEstimated, isSoleMatch: boolean) {\n    if (this.matchers[match.pattern]) {\n      return this.matchers[match.pattern](match, isSoleMatch)\n    }\n    if (\n      zxcvbnOptions.matchers[match.pattern] &&\n      'feedback' in zxcvbnOptions.matchers[match.pattern]\n    ) {\n      return zxcvbnOptions.matchers[match.pattern].feedback(match, isSoleMatch)\n    }\n    return defaultFeedback\n  }\n}\n\nexport default Feedback\n", "export type Procedure = (...args: any[]) => void\n\n/**\n * @link https://davidwalsh.name/javascript-debounce-function\n * @param func needs to implement a function which is debounced\n * @param wait how long do you want to wait till the previous declared function is executed\n * @param isImmediate defines if you want to execute the function on the first execution or the last execution inside the time window. `true` for first and `false` for last.\n */\nexport default <F extends Procedure>(\n  func: F,\n  wait: number,\n  isImmediate?: boolean,\n): ((this: ThisParameterType<F>, ...args: Parameters<F>) => void) => {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n  return function debounce(this: ThisParameterType<F>, ...args: Parameters<F>) {\n    const context = this\n    const later = () => {\n      timeout = undefined\n      if (!isImmediate) {\n        func.apply(context, args)\n      }\n    }\n    const shouldCallNow = isImmediate && !timeout\n    if (timeout !== undefined) {\n      clearTimeout(timeout)\n    }\n    timeout = setTimeout(later, wait)\n    if (shouldCallNow) {\n      return func.apply(context, args)\n    }\n    return undefined\n  }\n}\n", "import Matching from './Matching'\nimport scoring from './scoring'\nimport TimeEstimates from './TimeEstimates'\nimport Feedback from './Feedback'\nimport { zxcvbnOptions, Options } from './Options'\nimport debounce from './debounce'\nimport { MatchExtended, ZxcvbnResult } from './types'\n\nconst time = () => new Date().getTime()\n\nconst createReturnValue = (\n  resolvedMatches: MatchExtended[],\n  password: string,\n  start: number,\n): ZxcvbnResult => {\n  const feedback = new Feedback()\n  const timeEstimates = new TimeEstimates()\n  const matchSequence = scoring.mostGuessableMatchSequence(\n    password,\n    resolvedMatches,\n  )\n  const calcTime = time() - start\n  const attackTimes = timeEstimates.estimateAttackTimes(matchSequence.guesses)\n\n  return {\n    calcTime,\n    ...matchSequence,\n    ...attackTimes,\n    feedback: feedback.getFeedback(attackTimes.score, matchSequence.sequence),\n  }\n}\n\nconst main = (password: string, userInputs?: (string | number)[]) => {\n  if (userInputs) {\n    zxcvbnOptions.extendUserInputsDictionary(userInputs)\n  }\n\n  const matching = new Matching()\n\n  return matching.match(password)\n}\n\nexport const zxcvbn = (password: string, userInputs?: (string | number)[]) => {\n  const start = time()\n  const matches = main(password, userInputs)\n\n  if (matches instanceof Promise) {\n    throw new Error(\n      'You are using a Promised matcher, please use `zxcvbnAsync` for it.',\n    )\n  }\n  return createReturnValue(matches, password, start)\n}\n\nexport const zxcvbnAsync = async (\n  password: string,\n  userInputs?: (string | number)[],\n): Promise<ZxcvbnResult> => {\n  const usedPassword = password.substring(0, zxcvbnOptions.maxLength)\n  const start = time()\n  const matches = await main(usedPassword, userInputs)\n\n  return createReturnValue(matches, usedPassword, start)\n}\n\nexport * from './types'\nexport { zxcvbnOptions, Options, debounce }\n"],
  "mappings": "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",
  "names": ["extend", "listToExtend", "list", "push", "apply", "sorted", "matches", "sort", "m1", "m2", "i", "j", "buildRankedDictionary", "orderedList", "result", "counter", "forEach", "word", "DATE_MAX_YEAR", "DATE_MIN_YEAR", "DATE_SPLITS", "dateSplits", "BRUTEFORCE_CARDINALITY", "MIN_GUESSES_BEFORE_GROWING_SEQUENCE", "MIN_SUBMATCH_GUESSES_SINGLE_CHAR", "MIN_SUBMATCH_GUESSES_MULTI_CHAR", "MIN_YEAR_SPACE", "START_UPPER", "END_UPPER", "ALL_UPPER", "ALL_UPPER_INVERTED", "ALL_LOWER", "ALL_LOWER_INVERTED", "ONE_LOWER", "ONE_UPPER", "ALPHA_INVERTED", "ALL_DIGIT", "REFERENCE_YEAR", "Date", "getFullYear", "REGEXEN", "recentYear", "SEPERATOR_CHARS", "SEPERATOR_CHAR_COUNT", "length", "MatchDate", "match", "password", "matches", "getMatchesWithoutSeparator", "getMatchesWithSeparator", "filteredMatches", "filterNoise", "sorted", "maybeDateWithSeparator", "i", "Math", "abs", "length", "j", "token", "slice", "regexMatch", "exec", "dmy", "mapIntegersToDayMonthYear", "parseInt", "push", "pattern", "separator", "year", "month", "day", "maybeDateNoSeparator", "metric", "candidate", "REFERENCE_YEAR", "candidates", "index", "splittedDates", "DATE_SPLITS", "forEach", "k", "l", "bestCandidate", "minDistance", "distance", "filter", "isSubmatch", "matchesLength", "o", "otherMatch", "integers", "over12", "over31", "under1", "len1", "int", "DATE_MIN_YEAR", "DATE_MAX_YEAR", "getDayMonth", "possibleYearSplits", "possibleYearSplitsLength", "y", "rest", "dm", "mapIntegersToDayMonth", "twoToFourDigitYear", "temp", "reverse", "data", "mv", "pv", "start", "vlen", "getUsedThreshold", "password", "entry", "threshold", "isPasswordToShort", "length", "isThresholdLongerThanPassword", "shouldUsePasswordLength", "Math", "ceil", "findLevenshteinDistance", "rankedDictionary", "foundDistance", "found", "Object", "keys", "find", "usedThreshold", "abs", "foundEntryDistance", "distance", "isInThreshold", "levenshteinDistance", "levenshteinDistanceEntry", "a", "b", "c", "d", "e", "f", "g", "h", "i", "k", "l", "m", "n", "o", "q", "u", "s", "t", "v", "w", "x", "z", "warnings", "straightRow", "keyPattern", "simpleRepeat", "extendedRepeat", "sequences", "recentYears", "dates", "topTen", "topHundred", "common", "similarToCommon", "wordByItself", "namesByThemselves", "commonNames", "userInputs", "pwned", "suggestions", "l33t", "reverseWords", "allUppercase", "capitalization", "associatedYears", "repeated", "longerKeyboardPattern", "anotherWord", "useWords", "noNeed", "timeEstimation", "ltSecond", "second", "seconds", "minute", "minutes", "hour", "hours", "day", "days", "month", "months", "year", "years", "centuries", "TrieNode", "constructor", "parents", "children", "Map", "addSub", "key", "subs", "firstChar", "charAt", "has", "set", "cur", "get", "i", "length", "c", "hasChild", "addChild", "getChild", "concat", "child", "isTerminal", "l33tTable", "triNode", "Object", "entries", "forEach", "letter", "substitutions", "substitution", "addSub", "Options", "constructor", "matchers", "l33tTable", "trieNodeRoot", "l33tTableToTrieNode", "TrieNode", "dictionary", "userInputs", "rankedDictionaries", "rankedDictionariesMaxWordSize", "translations", "translationKeys", "graphs", "useLevenshteinDistance", "levenshteinThreshold", "l33tMaxSubstitutions", "maxLength", "setRankedDictionaries", "setOptions", "options", "setTranslations", "undefined", "checkCustomTranslations", "Error", "valid", "Object", "keys", "forEach", "type", "translationType", "key", "rankedDictionariesMaxWorkSize", "name", "buildRankedDictionary", "getRankedDictionariesMaxWordSize", "list", "data", "map", "el", "toString", "length", "reduce", "a", "b", "Math", "max", "buildSanitizedRankedDictionary", "sanitizedInputs", "input", "inputType", "push", "toLowerCase", "extendUserInputsDictionary", "newList", "addMatcher", "matcher", "console", "info", "zxcvbnOptions", "MatchReverse", "constructor", "defaultMatch", "match", "password", "passwordReversed", "split", "reverse", "join", "map", "token", "reversed", "i", "length", "j", "CleanPasswords", "constructor", "substr", "buffer", "limit", "trieRoot", "finalPasswords", "getAllPossibleSubsAtIndex", "index", "nodes", "cur", "i", "length", "character", "charAt", "getChild", "push", "helper", "onlyFullSub", "isFullSub", "subIndex", "changes", "password", "join", "hasSubs", "isTerminal", "subs", "sub", "newSubs", "concat", "letter", "substitution", "parents", "pop", "firstChar", "getAll", "getCleanPasswords", "string", "getExtras", "passwordWithSubs", "i", "j", "previousChanges", "changes", "filter", "iUnsubbed", "reduce", "value", "change", "letter", "length", "substitution", "usedChanges", "jUnsubbed", "filtered", "subDisplay", "forEach", "existingIndex", "findIndex", "t", "push", "subs", "join", "MatchL33t", "constructor", "defaultMatch", "isAlreadyIncluded", "matches", "newMatch", "some", "l33tMatch", "Object", "entries", "every", "key", "match", "password", "subbedPasswords", "getCleanPasswords", "zxcvbnOptions", "l33tMaxSubstitutions", "trieNodeRoot", "hasFullMatch", "isFullSubstitution", "subbedPassword", "matchedDictionary", "useLevenshtein", "extras", "token", "slice", "l33t", "alreadyIncluded", "toLowerCase", "matchedWord", "MatchDictionary", "constructor", "l33t", "L33t", "defaultMatch", "reverse", "Reverse", "match", "password", "matches", "sorted", "useLevenshtein", "passwordLength", "length", "passwordLower", "toLowerCase", "Object", "keys", "zxcvbnOptions", "rankedDictionaries", "forEach", "dictionaryName", "rankedDict", "longestDictionaryWordSize", "rankedDictionariesMaxWordSize", "searchWidth", "Math", "min", "i", "searchEnd", "j", "usedPassword", "slice", "isInDictionary", "foundLevenshteinDistance", "isFullPassword", "useLevenshteinDistance", "findLevenshteinDistance", "levenshteinThreshold", "isLevenshteinMatch", "usedRankPassword", "levenshteinDistanceEntry", "rank", "push", "pattern", "token", "matchedWord", "reversed", "MatchRegex", "match", "password", "regexes", "REGEXEN", "matches", "Object", "keys", "forEach", "name", "regex", "lastIndex", "regexMatch", "exec", "token", "push", "pattern", "i", "index", "j", "length", "regexName", "sorted", "nCk", "n", "k", "count", "coEff", "i", "log10", "Math", "log", "log2", "factorial", "num", "rval", "token", "guesses", "BRUTEFORCE_CARDINALITY", "length", "Number", "POSITIVE_INFINITY", "MAX_VALUE", "minGuesses", "MIN_SUBMATCH_GUESSES_SINGLE_CHAR", "MIN_SUBMATCH_GUESSES_MULTI_CHAR", "Math", "max", "year", "separator", "yearSpace", "Math", "max", "abs", "REFERENCE_YEAR", "MIN_YEAR_SPACE", "guesses", "getVariations", "cleanedWord", "wordArray", "split", "upperCaseCount", "filter", "char", "match", "ONE_UPPER", "length", "lowerCaseCount", "ONE_LOWER", "variations", "variationLength", "Math", "min", "i", "utils", "nCk", "word", "replace", "ALPHA_INVERTED", "ALL_LOWER_INVERTED", "toLowerCase", "commonCases", "START_UPPER", "END_UPPER", "ALL_UPPER_INVERTED", "commonCasesLength", "regex", "countSubstring", "string", "substring", "count", "pos", "indexOf", "length", "getCounts", "sub", "token", "tokenLower", "toLowerCase", "subbedCount", "substitution", "unsubbedCount", "letter", "l33t", "subs", "variations", "forEach", "p", "Math", "min", "possibilities", "i", "utils", "nCk", "rank", "reversed", "l33t", "subs", "token", "dictionaryName", "baseGuesses", "uppercaseVariations", "uppercaseVariant", "l33tVariations", "l33tVariant", "reversedVariations", "calculation", "regexName", "regexMatch", "token", "charClassBases", "alphaLower", "alphaUpper", "alpha", "alphanumeric", "digits", "symbols", "length", "Math", "max", "abs", "parseInt", "REFERENCE_YEAR", "MIN_YEAR_SPACE", "baseGuesses", "repeatCount", "token", "ascending", "firstChr", "charAt", "baseGuesses", "startingPoints", "includes", "match", "length", "calcAverageDegree", "graph", "average", "Object", "keys", "forEach", "key", "neighbors", "filter", "entry", "length", "entries", "estimatePossiblePatterns", "token", "turns", "startingPosition", "zxcvbnOptions", "graphs", "averageDegree", "guesses", "tokenLength", "i", "possibleTurns", "Math", "min", "j", "utils", "nCk", "shiftedCount", "unShiftedCount", "shiftedVariations", "round", "SEPERATOR_CHAR_COUNT", "getMinGuesses", "match", "password", "minGuesses", "token", "length", "MIN_SUBMATCH_GUESSES_SINGLE_CHAR", "MIN_SUBMATCH_GUESSES_MULTI_CHAR", "matchers", "bruteforce", "bruteforceMatcher", "date", "dateMatcher", "dictionary", "dictionaryMatcher", "regex", "regexMatcher", "repeat", "repeatMatcher", "sequence", "sequenceMatcher", "spatial", "spatialMatcher", "separator", "separatorMatcher", "getScoring", "name", "zxcvbnOptions", "scoring", "extraData", "guesses", "estimationResult", "pattern", "calculation", "baseGuesses", "uppercaseVariations", "l33tVariations", "matchGuesses", "Math", "max", "guessesLog10", "utils", "log10", "scoringHelper", "password", "optimal", "excludeAdditive", "separatorRegex", "undefined", "fillArray", "size", "valueType", "result", "i", "value", "push", "makeBruteforceMatch", "j", "pattern", "token", "slice", "update", "match", "sequenceLength", "k", "estimatedMatch", "estimateGuesses", "pi", "guesses", "g", "utils", "factorial", "MIN_GUESSES_BEFORE_GROWING_SEQUENCE", "shouldSkip", "Object", "keys", "forEach", "competingPatternLength", "competingMetricMatch", "parseInt", "m", "bruteforceUpdate", "passwordCharIndex", "tmp", "lastMatch", "unwind", "passwordLength", "optimalMatchSequence", "temp", "candidateSequenceLength", "candidateMetricMatch", "unshift", "mostGuessableMatchSequence", "matches", "length", "matchesByCoordinateJ", "map", "sort", "m1", "m2", "optimalSequenceLength", "getGuesses", "guessesLog10", "log10", "sequence", "createRegex", "isLazy", "isAnchored", "flags", "RegExp", "MatchRepeat", "match", "password", "omniMatch", "matches", "lastIndex", "length", "greedyMatch", "getGreedyMatch", "lazyMatch", "getLazyMatch", "baseToken", "setMatchToken", "j", "index", "baseGuesses", "getBaseGuesses", "push", "normalizeMatch", "hasPromises", "some", "Promise", "all", "baseMatch", "pattern", "i", "token", "repeatCount", "then", "resolvedBaseGuesses", "greedy", "exec", "lazy", "lazyAnchored", "temp", "resolvedMatches", "baseAnalysis", "scoring", "mostGuessableMatchSequence", "guesses", "MatchSequence", "constructor", "MAX_DELTA", "match", "password", "result", "length", "i", "lastDelta", "passwordLength", "k", "delta", "charCodeAt", "j", "update", "Math", "abs", "absoluteDelta", "token", "slice", "sequenceName", "sequenceSpace", "getSequence", "push", "pattern", "ascending", "ALL_LOWER", "test", "ALL_UPPER", "ALL_DIGIT", "MatchSpatial", "constructor", "SHIFTED_RX", "match", "password", "matches", "Object", "keys", "zxcvbnOptions", "graphs", "forEach", "graphName", "graph", "extend", "helper", "sorted", "checkIfShifted", "index", "includes", "test", "charAt", "shiftedCount", "i", "passwordLength", "length", "j", "lastDirection", "turns", "prevChar", "adjacents", "found", "foundDirection", "curDirection", "curChar", "adjacentsLength", "k", "adjacent", "adjacentIndex", "indexOf", "push", "pattern", "token", "slice", "separatorRegex", "RegExp", "SEPERATOR_CHARS", "join", "MatchSeparator", "getMostUsedSeparatorChar", "password", "mostUsedSeperators", "split", "filter", "c", "test", "reduce", "memo", "m", "get", "set", "Map", "entries", "sort", "_a", "a", "_b", "b", "length", "undefined", "match", "getSeparatorRegex", "separator", "result", "mostUsedSpecial", "isSeparator", "matchAll", "index", "i", "push", "pattern", "token", "j", "Matching", "constructor", "matchers", "date", "dateMatcher", "dictionary", "dictionaryMatcher", "regex", "regexMatcher", "repeat", "repeatMatcher", "sequence", "sequenceMatcher", "spatial", "spatialMatcher", "separator", "separatorMatcher", "match", "password", "matches", "promises", "Object", "keys", "zxcvbnOptions", "forEach", "key", "Matcher", "usedMatcher", "result", "omniMatch", "Promise", "then", "response", "extend", "push", "length", "resolve", "reject", "all", "sorted", "catch", "error", "SECOND", "MINUTE", "HOUR", "DAY", "MONTH", "YEAR", "CENTURY", "times", "second", "minute", "hour", "day", "month", "year", "century", "TimeEstimates", "translate", "displayStr", "value", "key", "undefined", "timeEstimation", "zxcvbnOptions", "translations", "replace", "estimateAttackTimes", "guesses", "crackTimesSeconds", "onlineThrottling100PerHour", "onlineNoThrottling10PerSecond", "offlineSlowHashing1e4PerSecond", "offlineFastHashing1e10PerSecond", "crackTimesDisplay", "Object", "keys", "forEach", "scenario", "seconds", "displayTime", "score", "guessesToScore", "DELTA", "base", "timeKeys", "foundIndex", "findIndex", "time", "Math", "round", "bruteforceMatcher", "dateMatcher", "warning", "zxcvbnOptions", "translations", "warnings", "dates", "suggestions", "getDictionaryWarningPassword", "match", "isSoleMatch", "warning", "l33t", "reversed", "rank", "zxcvbnOptions", "translations", "warnings", "topTen", "topHundred", "common", "guessesLog10", "similarToCommon", "getDictionaryWarningWikipedia", "wordByItself", "getDictionaryWarningNames", "namesByThemselves", "commonNames", "getDictionaryWarning", "dictName", "dictionaryName", "isAName", "toLowerCase", "includes", "userInputs", "dictionaryMatcher", "suggestions", "word", "token", "START_UPPER", "push", "capitalization", "ALL_UPPER_INVERTED", "allUppercase", "length", "reverseWords", "regexMatcher", "match", "regexName", "warning", "zxcvbnOptions", "translations", "warnings", "recentYears", "suggestions", "associatedYears", "repeatMatcher", "match", "warning", "zxcvbnOptions", "translations", "warnings", "extendedRepeat", "baseToken", "length", "simpleRepeat", "suggestions", "repeated", "sequenceMatcher", "warning", "zxcvbnOptions", "translations", "warnings", "sequences", "suggestions", "spatialMatcher", "match", "warning", "zxcvbnOptions", "translations", "warnings", "keyPattern", "turns", "straightRow", "suggestions", "longerKeyboardPattern", "separatorMatcher", "defaultFeedback", "warning", "suggestions", "Feedback", "constructor", "matchers", "bruteforce", "bruteforceMatcher", "date", "dateMatcher", "dictionary", "dictionaryMatcher", "regex", "regexMatcher", "repeat", "repeatMatcher", "sequence", "sequenceMatcher", "spatial", "spatialMatcher", "separator", "separatorMatcher", "setDefaultSuggestions", "push", "zxcvbnOptions", "translations", "useWords", "noNeed", "getFeedback", "score", "length", "extraFeedback", "anotherWord", "longestMatch", "getLongestMatch", "feedback", "getMatchFeedback", "undefined", "unshift", "slicedSequence", "slice", "forEach", "match", "token", "isSoleMatch", "pattern", "func", "wait", "isImmediate", "timeout", "debounce", "args", "context", "later", "undefined", "apply", "shouldCallNow", "clearTimeout", "setTimeout", "time", "Date", "getTime", "createReturnValue", "resolvedMatches", "password", "start", "feedback", "Feedback", "timeEstimates", "TimeEstimates", "matchSequence", "scoring", "mostGuessableMatchSequence", "calcTime", "attackTimes", "estimateAttackTimes", "guesses", "getFeedback", "score", "sequence", "main", "userInputs", "zxcvbnOptions", "extendUserInputsDictionary", "matching", "Matching", "match", "zxcvbn", "matches", "Promise", "Error", "zxcvbnAsync", "usedPassword", "substring", "maxLength"]
}
