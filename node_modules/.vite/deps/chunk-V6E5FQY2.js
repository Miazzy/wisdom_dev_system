import {
  __esm,
  __export
} from "./chunk-AUZ3RYOM.js";

// node_modules/.pnpm/registry.npmmirror.com+min-dash@3.8.1/node_modules/min-dash/dist/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  assign: () => assign,
  bind: () => bind,
  debounce: () => debounce,
  ensureArray: () => ensureArray,
  every: () => every,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex,
  flatten: () => flatten,
  forEach: () => forEach,
  get: () => get,
  groupBy: () => groupBy,
  has: () => has,
  isArray: () => isArray,
  isDefined: () => isDefined,
  isFunction: () => isFunction,
  isNil: () => isNil,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isString: () => isString,
  isUndefined: () => isUndefined,
  keys: () => keys,
  map: () => map,
  matchPattern: () => matchPattern,
  merge: () => merge,
  omit: () => omit,
  pick: () => pick,
  reduce: () => reduce,
  set: () => set,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  throttle: () => throttle,
  unionBy: () => unionBy,
  uniqueBy: () => uniqueBy,
  values: () => values,
  without: () => without
});
function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}
function isUndefined(obj) {
  return obj === void 0;
}
function isDefined(obj) {
  return obj !== void 0;
}
function isNil(obj) {
  return obj == null;
}
function isArray(obj) {
  return nativeToString.call(obj) === "[object Array]";
}
function isObject(obj) {
  return nativeToString.call(obj) === "[object Object]";
}
function isNumber(obj) {
  return nativeToString.call(obj) === "[object Number]";
}
function isFunction(obj) {
  var tag = nativeToString.call(obj);
  return tag === "[object Function]" || tag === "[object AsyncFunction]" || tag === "[object GeneratorFunction]" || tag === "[object AsyncGeneratorFunction]" || tag === "[object Proxy]";
}
function isString(obj) {
  return nativeToString.call(obj) === "[object String]";
}
function ensureArray(obj) {
  if (isArray(obj)) {
    return;
  }
  throw new Error("must supply array");
}
function has(target, key) {
  return nativeHasOwnProperty.call(target, key);
}
function find(collection, matcher) {
  matcher = toMatcher(matcher);
  var match;
  forEach(collection, function(val, key) {
    if (matcher(val, key)) {
      match = val;
      return false;
    }
  });
  return match;
}
function findIndex(collection, matcher) {
  matcher = toMatcher(matcher);
  var idx = isArray(collection) ? -1 : void 0;
  forEach(collection, function(val, key) {
    if (matcher(val, key)) {
      idx = key;
      return false;
    }
  });
  return idx;
}
function filter(collection, matcher) {
  var result = [];
  forEach(collection, function(val, key) {
    if (matcher(val, key)) {
      result.push(val);
    }
  });
  return result;
}
function forEach(collection, iterator) {
  var val, result;
  if (isUndefined(collection)) {
    return;
  }
  var convertKey = isArray(collection) ? toNum : identity;
  for (var key in collection) {
    if (has(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));
      if (result === false) {
        return val;
      }
    }
  }
}
function without(arr, matcher) {
  if (isUndefined(arr)) {
    return [];
  }
  ensureArray(arr);
  matcher = toMatcher(matcher);
  return arr.filter(function(el, idx) {
    return !matcher(el, idx);
  });
}
function reduce(collection, iterator, result) {
  forEach(collection, function(value, idx) {
    result = iterator(result, value, idx);
  });
  return result;
}
function every(collection, matcher) {
  return !!reduce(collection, function(matches, val, key) {
    return matches && matcher(val, key);
  }, true);
}
function some(collection, matcher) {
  return !!find(collection, matcher);
}
function map(collection, fn) {
  var result = [];
  forEach(collection, function(val, key) {
    result.push(fn(val, key));
  });
  return result;
}
function keys(collection) {
  return collection && Object.keys(collection) || [];
}
function size(collection) {
  return keys(collection).length;
}
function values(collection) {
  return map(collection, function(val) {
    return val;
  });
}
function groupBy(collection, extractor) {
  var grouped = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  extractor = toExtractor(extractor);
  forEach(collection, function(val) {
    var discriminator = extractor(val) || "_";
    var group = grouped[discriminator];
    if (!group) {
      group = grouped[discriminator] = [];
    }
    group.push(val);
  });
  return grouped;
}
function uniqueBy(extractor) {
  extractor = toExtractor(extractor);
  var grouped = {};
  for (var _len = arguments.length, collections = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    collections[_key - 1] = arguments[_key];
  }
  forEach(collections, function(c) {
    return groupBy(c, extractor, grouped);
  });
  var result = map(grouped, function(val, key) {
    return val[0];
  });
  return result;
}
function sortBy(collection, extractor) {
  extractor = toExtractor(extractor);
  var sorted = [];
  forEach(collection, function(value, key) {
    var disc = extractor(value, key);
    var entry = {
      d: disc,
      v: value
    };
    for (var idx = 0; idx < sorted.length; idx++) {
      var d = sorted[idx].d;
      if (disc < d) {
        sorted.splice(idx, 0, entry);
        return;
      }
    }
    sorted.push(entry);
  });
  return map(sorted, function(e) {
    return e.v;
  });
}
function matchPattern(pattern) {
  return function(el) {
    return every(pattern, function(val, key) {
      return el[key] === val;
    });
  };
}
function toExtractor(extractor) {
  return isFunction(extractor) ? extractor : function(e) {
    return e[extractor];
  };
}
function toMatcher(matcher) {
  return isFunction(matcher) ? matcher : function(e) {
    return e === matcher;
  };
}
function identity(arg) {
  return arg;
}
function toNum(arg) {
  return Number(arg);
}
function debounce(fn, timeout) {
  var timer;
  var lastArgs;
  var lastThis;
  var lastNow;
  function fire(force) {
    var now = Date.now();
    var scheduledDiff = force ? 0 : lastNow + timeout - now;
    if (scheduledDiff > 0) {
      return schedule(scheduledDiff);
    }
    fn.apply(lastThis, lastArgs);
    clear();
  }
  function schedule(timeout2) {
    timer = setTimeout(fire, timeout2);
  }
  function clear() {
    if (timer) {
      clearTimeout(timer);
    }
    timer = lastNow = lastArgs = lastThis = void 0;
  }
  function flush() {
    if (timer) {
      fire(true);
    }
    clear();
  }
  function callback() {
    lastNow = Date.now();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    lastThis = this;
    if (!timer) {
      schedule(timeout);
    }
  }
  callback.flush = flush;
  callback.cancel = clear;
  return callback;
}
function throttle(fn, interval) {
  var throttling = false;
  return function() {
    if (throttling) {
      return;
    }
    fn.apply(void 0, arguments);
    throttling = true;
    setTimeout(function() {
      throttling = false;
    }, interval);
  };
}
function bind(fn, target) {
  return fn.bind(target);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function assign(target) {
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }
  return _extends.apply(void 0, [target].concat(others));
}
function set(target, path, value) {
  var currentTarget = target;
  forEach(path, function(key, idx) {
    if (typeof key !== "number" && typeof key !== "string") {
      throw new Error("illegal key type: " + _typeof(key) + ". Key should be of type number or string.");
    }
    if (key === "constructor") {
      throw new Error("illegal key: constructor");
    }
    if (key === "__proto__") {
      throw new Error("illegal key: __proto__");
    }
    var nextKey = path[idx + 1];
    var nextTarget = currentTarget[key];
    if (isDefined(nextKey) && isNil(nextTarget)) {
      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
    }
    if (isUndefined(nextKey)) {
      if (isUndefined(value)) {
        delete currentTarget[key];
      } else {
        currentTarget[key] = value;
      }
    } else {
      currentTarget = nextTarget;
    }
  });
  return target;
}
function get(target, path, defaultValue) {
  var currentTarget = target;
  forEach(path, function(key) {
    if (isNil(currentTarget)) {
      currentTarget = void 0;
      return false;
    }
    currentTarget = currentTarget[key];
  });
  return isUndefined(currentTarget) ? defaultValue : currentTarget;
}
function pick(target, properties) {
  var result = {};
  var obj = Object(target);
  forEach(properties, function(prop) {
    if (prop in obj) {
      result[prop] = target[prop];
    }
  });
  return result;
}
function omit(target, properties) {
  var result = {};
  var obj = Object(target);
  forEach(obj, function(prop, key) {
    if (properties.indexOf(key) === -1) {
      result[key] = prop;
    }
  });
  return result;
}
function merge(target) {
  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }
  if (!sources.length) {
    return target;
  }
  forEach(sources, function(source) {
    if (!source || !isObject(source)) {
      return;
    }
    forEach(source, function(sourceVal, key) {
      if (key === "__proto__") {
        return;
      }
      var targetVal = target[key];
      if (isObject(sourceVal)) {
        if (!isObject(targetVal)) {
          targetVal = {};
        }
        target[key] = merge(targetVal, sourceVal);
      } else {
        target[key] = sourceVal;
      }
    });
  });
  return target;
}
var nativeToString, nativeHasOwnProperty, unionBy;
var init_index_esm = __esm({
  "node_modules/.pnpm/registry.npmmirror.com+min-dash@3.8.1/node_modules/min-dash/dist/index.esm.js"() {
    nativeToString = Object.prototype.toString;
    nativeHasOwnProperty = Object.prototype.hasOwnProperty;
    unionBy = uniqueBy;
  }
});

export {
  flatten,
  isUndefined,
  isDefined,
  isNil,
  isArray,
  isObject,
  isNumber,
  isFunction,
  isString,
  has,
  find,
  findIndex,
  filter,
  forEach,
  without,
  reduce,
  every,
  some,
  map,
  keys,
  size,
  values,
  groupBy,
  uniqueBy,
  unionBy,
  sortBy,
  matchPattern,
  debounce,
  bind,
  assign,
  pick,
  omit,
  index_esm_exports,
  init_index_esm
};
//# sourceMappingURL=chunk-V6E5FQY2.js.map
