/* eslint-disable */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/mcs8Client.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/awaitqueue/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/awaitqueue/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AwaitQueue {\n    constructor({ ClosedErrorClass = Error, StoppedErrorClass = Error } = {\n        ClosedErrorClass: Error,\n        StoppedErrorClass: Error\n    }) {\n        // Closed flag.\n        this.closed = false;\n        // Queue of pending tasks.\n        this.pendingTasks = [];\n        // Error class used when rejecting a task due to AwaitQueue being closed.\n        this.ClosedErrorClass = Error;\n        // Error class used when rejecting a task due to AwaitQueue being stopped.\n        this.StoppedErrorClass = Error;\n        this.ClosedErrorClass = ClosedErrorClass;\n        this.StoppedErrorClass = StoppedErrorClass;\n    }\n    /**\n     * The number of ongoing enqueued tasks.\n     */\n    get size() {\n        return this.pendingTasks.length;\n    }\n    /**\n     * Closes the AwaitQueue. Pending tasks will be rejected with ClosedErrorClass\n     * error.\n     */\n    close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        for (const pendingTask of this.pendingTasks) {\n            pendingTask.stopped = true;\n            pendingTask.reject(new this.ClosedErrorClass('AwaitQueue closed'));\n        }\n        // Enpty the pending tasks array.\n        this.pendingTasks.length = 0;\n    }\n    /**\n     * Accepts a task as argument (and an optional task name) and enqueues it after\n     * pending tasks. Once processed, the push() method resolves (or rejects) with\n     * the result returned by the given task.\n     *\n     * The given task must return a Promise or directly a value.\n     */\n    push(task, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.closed)\n                throw new this.ClosedErrorClass('AwaitQueue closed');\n            if (typeof task !== 'function')\n                throw new TypeError('given task is not a function');\n            if (!task.name && name) {\n                try {\n                    Object.defineProperty(task, 'name', { value: name });\n                }\n                catch (error) { }\n            }\n            return new Promise((resolve, reject) => {\n                const pendingTask = {\n                    task,\n                    name,\n                    resolve,\n                    reject,\n                    stopped: false,\n                    enqueuedAt: new Date(),\n                    executedAt: undefined\n                };\n                // Append task to the queue.\n                this.pendingTasks.push(pendingTask);\n                // And run it if this is the only task in the queue.\n                if (this.pendingTasks.length === 1)\n                    this.next();\n            });\n        });\n    }\n    /**\n     * Make ongoing pending tasks reject with the given StoppedErrorClass error.\n     * The AwaitQueue instance is still usable for future tasks added via push()\n     * method.\n     */\n    stop() {\n        if (this.closed)\n            return;\n        for (const pendingTask of this.pendingTasks) {\n            pendingTask.stopped = true;\n            pendingTask.reject(new this.StoppedErrorClass('AwaitQueue stopped'));\n        }\n        // Enpty the pending tasks array.\n        this.pendingTasks.length = 0;\n    }\n    dump() {\n        const now = new Date();\n        return this.pendingTasks.map((pendingTask) => {\n            return {\n                task: pendingTask.task,\n                name: pendingTask.name,\n                enqueuedTime: pendingTask.executedAt\n                    ? pendingTask.executedAt.getTime() - pendingTask.enqueuedAt.getTime()\n                    : now.getTime() - pendingTask.enqueuedAt.getTime(),\n                executingTime: pendingTask.executedAt\n                    ? now.getTime() - pendingTask.executedAt.getTime()\n                    : 0\n            };\n        });\n    }\n    next() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Take the first pending task.\n            const pendingTask = this.pendingTasks[0];\n            if (!pendingTask)\n                return;\n            // Execute it.\n            yield this.executeTask(pendingTask);\n            // Remove the first pending task (the completed one) from the queue.\n            this.pendingTasks.shift();\n            // And continue.\n            this.next();\n        });\n    }\n    executeTask(pendingTask) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If the task is stopped, ignore it.\n            if (pendingTask.stopped)\n                return;\n            pendingTask.executedAt = new Date();\n            try {\n                const result = yield pendingTask.task();\n                // If the task is stopped, ignore it.\n                if (pendingTask.stopped)\n                    return;\n                // Resolve the task with the returned result (if any).\n                pendingTask.resolve(result);\n            }\n            catch (error) {\n                // If the task is stopped, ignore it.\n                if (pendingTask.stopped)\n                    return;\n                // Reject the task with its own error.\n                pendingTask.reject(error);\n            }\n        });\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n\n\n//# sourceURL=webpack:///./node_modules/awaitqueue/lib/index.js?");

/***/ }),

/***/ "./node_modules/blueimp-md5/js/md5.js":
/*!********************************************!*\
  !*** ./node_modules/blueimp-md5/js/md5.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/* global define */\n\n/* eslint-disable strict */\n\n;(function ($) {\n  'use strict'\n\n  /**\n   * Add integers, wrapping at 2^32.\n   * This uses 16-bit operations internally to work around bugs in interpreters.\n   *\n   * @param {number} x First integer\n   * @param {number} y Second integer\n   * @returns {number} Sum\n   */\n  function safeAdd(x, y) {\n    var lsw = (x & 0xffff) + (y & 0xffff)\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n    return (msw << 16) | (lsw & 0xffff)\n  }\n\n  /**\n   * Bitwise rotate a 32-bit number to the left.\n   *\n   * @param {number} num 32-bit number\n   * @param {number} cnt Rotation count\n   * @returns {number} Rotated number\n   */\n  function bitRotateLeft(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt))\n  }\n\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} q q\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ff(a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5gg(a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t)\n  }\n  /**\n   * Basic operation the algorithm uses.\n   *\n   * @param {number} a a\n   * @param {number} b b\n   * @param {number} c c\n   * @param {number} d d\n   * @param {number} x x\n   * @param {number} s s\n   * @param {number} t t\n   * @returns {number} Result\n   */\n  function md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t)\n  }\n\n  /**\n   * Calculate the MD5 of an array of little-endian words, and a bit length.\n   *\n   * @param {Array} x Array of little-endian words\n   * @param {number} len Bit length\n   * @returns {Array<number>} MD5 Array\n   */\n  function binlMD5(x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << len % 32\n    x[(((len + 64) >>> 9) << 4) + 14] = len\n\n    var i\n    var olda\n    var oldb\n    var oldc\n    var oldd\n    var a = 1732584193\n    var b = -271733879\n    var c = -1732584194\n    var d = 271733878\n\n    for (i = 0; i < x.length; i += 16) {\n      olda = a\n      oldb = b\n      oldc = c\n      oldd = d\n\n      a = md5ff(a, b, c, d, x[i], 7, -680876936)\n      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\n      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\n      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\n      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\n      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\n      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\n      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\n      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\n      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\n      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\n      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\n      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\n      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\n      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\n      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\n      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\n      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\n      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\n      b = md5gg(b, c, d, a, x[i], 20, -373897302)\n      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\n      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\n      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\n      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\n      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\n      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\n      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\n      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\n      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\n      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\n      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\n      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\n      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\n      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\n      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\n      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\n      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\n      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\n      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\n      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\n      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\n      d = md5hh(d, a, b, c, x[i], 11, -358537222)\n      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\n      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\n      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\n      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\n      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\n      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\n\n      a = md5ii(a, b, c, d, x[i], 6, -198630844)\n      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\n      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\n      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\n      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\n      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\n      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\n      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\n      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\n      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\n      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\n      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\n      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\n      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\n      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\n      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\n\n      a = safeAdd(a, olda)\n      b = safeAdd(b, oldb)\n      c = safeAdd(c, oldc)\n      d = safeAdd(d, oldd)\n    }\n    return [a, b, c, d]\n  }\n\n  /**\n   * Convert an array of little-endian words to a string\n   *\n   * @param {Array<number>} input MD5 Array\n   * @returns {string} MD5 string\n   */\n  function binl2rstr(input) {\n    var i\n    var output = ''\n    var length32 = input.length * 32\n    for (i = 0; i < length32; i += 8) {\n      output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff)\n    }\n    return output\n  }\n\n  /**\n   * Convert a raw string to an array of little-endian words\n   * Characters >255 have their high-byte silently ignored.\n   *\n   * @param {string} input Raw input string\n   * @returns {Array<number>} Array of little-endian words\n   */\n  function rstr2binl(input) {\n    var i\n    var output = []\n    output[(input.length >> 2) - 1] = undefined\n    for (i = 0; i < output.length; i += 1) {\n      output[i] = 0\n    }\n    var length8 = input.length * 8\n    for (i = 0; i < length8; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32\n    }\n    return output\n  }\n\n  /**\n   * Calculate the MD5 of a raw string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrMD5(s) {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n  }\n\n  /**\n   * Calculates the HMAC-MD5 of a key and some data (raw strings)\n   *\n   * @param {string} key HMAC key\n   * @param {string} data Raw input string\n   * @returns {string} Raw MD5 string\n   */\n  function rstrHMACMD5(key, data) {\n    var i\n    var bkey = rstr2binl(key)\n    var ipad = []\n    var opad = []\n    var hash\n    ipad[15] = opad[15] = undefined\n    if (bkey.length > 16) {\n      bkey = binlMD5(bkey, key.length * 8)\n    }\n    for (i = 0; i < 16; i += 1) {\n      ipad[i] = bkey[i] ^ 0x36363636\n      opad[i] = bkey[i] ^ 0x5c5c5c5c\n    }\n    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n  }\n\n  /**\n   * Convert a raw string to a hex string\n   *\n   * @param {string} input Raw input string\n   * @returns {string} Hex encoded string\n   */\n  function rstr2hex(input) {\n    var hexTab = '0123456789abcdef'\n    var output = ''\n    var x\n    var i\n    for (i = 0; i < input.length; i += 1) {\n      x = input.charCodeAt(i)\n      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)\n    }\n    return output\n  }\n\n  /**\n   * Encode a string as UTF-8\n   *\n   * @param {string} input Input string\n   * @returns {string} UTF8 string\n   */\n  function str2rstrUTF8(input) {\n    return unescape(encodeURIComponent(input))\n  }\n\n  /**\n   * Encodes input string as raw MD5 string\n   *\n   * @param {string} s Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawMD5(s) {\n    return rstrMD5(str2rstrUTF8(s))\n  }\n  /**\n   * Encodes input string as Hex encoded string\n   *\n   * @param {string} s Input string\n   * @returns {string} Hex encoded string\n   */\n  function hexMD5(s) {\n    return rstr2hex(rawMD5(s))\n  }\n  /**\n   * Calculates the raw HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function rawHMACMD5(k, d) {\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n  }\n  /**\n   * Calculates the Hex encoded HMAC-MD5 for the given key and data\n   *\n   * @param {string} k HMAC key\n   * @param {string} d Input string\n   * @returns {string} Raw MD5 string\n   */\n  function hexHMACMD5(k, d) {\n    return rstr2hex(rawHMACMD5(k, d))\n  }\n\n  /**\n   * Calculates MD5 value for a given string.\n   * If a key is provided, calculates the HMAC-MD5 value.\n   * Returns a Hex encoded string unless the raw argument is given.\n   *\n   * @param {string} string Input string\n   * @param {string} [key] HMAC key\n   * @param {boolean} [raw] Raw output switch\n   * @returns {string} MD5 output\n   */\n  function md5(string, key, raw) {\n    if (!key) {\n      if (!raw) {\n        return hexMD5(string)\n      }\n      return rawMD5(string)\n    }\n    if (!raw) {\n      return hexHMACMD5(key, string)\n    }\n    return rawHMACMD5(key, string)\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return md5\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(this)\n\n\n//# sourceURL=webpack:///./node_modules/blueimp-md5/js/md5.js?");

/***/ }),

/***/ "./node_modules/bowser/es5.js":
/*!************************************!*\
  !*** ./node_modules/bowser/es5.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(e,t){ true?module.exports=t():undefined}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=90)}({17:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||\"\"},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||\"\"},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case\"NT\":return\"NT\";case\"XP\":return\"XP\";case\"NT 5.0\":return\"2000\";case\"NT 5.1\":return\"XP\";case\"NT 5.2\":return\"2003\";case\"NT 6.0\":return\"Vista\";case\"NT 6.1\":return\"7\";case\"NT 6.2\":return\"8\";case\"NT 6.3\":return\"8.1\";case\"NT 10.0\":return\"10\";default:return}},e.getMacOSVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return\"Leopard\";case 6:return\"Snow Leopard\";case 7:return\"Lion\";case 8:return\"Mountain Lion\";case 9:return\"Mavericks\";case 10:return\"Yosemite\";case 11:return\"El Capitan\";case 12:return\"Sierra\";case 13:return\"High Sierra\";case 14:return\"Mojave\";case 15:return\"Catalina\";default:return}},e.getAndroidVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?\"Cupcake\":1===t[0]&&t[1]>=6?\"Donut\":2===t[0]&&t[1]<2?\"Eclair\":2===t[0]&&2===t[1]?\"Froyo\":2===t[0]&&t[1]>2?\"Gingerbread\":3===t[0]?\"Honeycomb\":4===t[0]&&t[1]<1?\"Ice Cream Sandwich\":4===t[0]&&t[1]<4?\"Jelly Bean\":4===t[0]&&t[1]>=4?\"KitKat\":5===t[0]?\"Lollipop\":6===t[0]?\"Marshmallow\":7===t[0]?\"Nougat\":8===t[0]?\"Oreo\":9===t[0]?\"Pie\":void 0},e.getVersionPrecision=function(e){return e.split(\".\").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(\".0\");return e.map(n.split(\".\"),(function(e){return new Array(20-e.length).join(\"0\")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];\"object\"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||\"\"},e}();t.default=i,e.exports=t.default},18:function(e,t,r){\"use strict\";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={\"Amazon Silk\":\"amazon_silk\",\"Android Browser\":\"android\",Bada:\"bada\",BlackBerry:\"blackberry\",Chrome:\"chrome\",Chromium:\"chromium\",Electron:\"electron\",Epiphany:\"epiphany\",Firefox:\"firefox\",Focus:\"focus\",Generic:\"generic\",\"Google Search\":\"google_search\",Googlebot:\"googlebot\",\"Internet Explorer\":\"ie\",\"K-Meleon\":\"k_meleon\",Maxthon:\"maxthon\",\"Microsoft Edge\":\"edge\",\"MZ Browser\":\"mz\",\"NAVER Whale Browser\":\"naver\",Opera:\"opera\",\"Opera Coast\":\"opera_coast\",PhantomJS:\"phantomjs\",Puffin:\"puffin\",QupZilla:\"qupzilla\",QQ:\"qq\",QQLite:\"qqlite\",Safari:\"safari\",Sailfish:\"sailfish\",\"Samsung Internet for Android\":\"samsung_internet\",SeaMonkey:\"seamonkey\",Sleipnir:\"sleipnir\",Swing:\"swing\",Tizen:\"tizen\",\"UC Browser\":\"uc\",Vivaldi:\"vivaldi\",\"WebOS Browser\":\"webos\",WeChat:\"wechat\",\"Yandex Browser\":\"yandex\",Roku:\"roku\"};t.BROWSER_MAP={amazon_silk:\"Amazon Silk\",android:\"Android Browser\",bada:\"Bada\",blackberry:\"BlackBerry\",chrome:\"Chrome\",chromium:\"Chromium\",electron:\"Electron\",epiphany:\"Epiphany\",firefox:\"Firefox\",focus:\"Focus\",generic:\"Generic\",googlebot:\"Googlebot\",google_search:\"Google Search\",ie:\"Internet Explorer\",k_meleon:\"K-Meleon\",maxthon:\"Maxthon\",edge:\"Microsoft Edge\",mz:\"MZ Browser\",naver:\"NAVER Whale Browser\",opera:\"Opera\",opera_coast:\"Opera Coast\",phantomjs:\"PhantomJS\",puffin:\"Puffin\",qupzilla:\"QupZilla\",qq:\"QQ Browser\",qqlite:\"QQ Browser Lite\",safari:\"Safari\",sailfish:\"Sailfish\",samsung_internet:\"Samsung Internet for Android\",seamonkey:\"SeaMonkey\",sleipnir:\"Sleipnir\",swing:\"Swing\",tizen:\"Tizen\",uc:\"UC Browser\",vivaldi:\"Vivaldi\",webos:\"WebOS Browser\",wechat:\"WeChat\",yandex:\"Yandex Browser\"};t.PLATFORMS_MAP={tablet:\"tablet\",mobile:\"mobile\",desktop:\"desktop\",tv:\"tv\"};t.OS_MAP={WindowsPhone:\"Windows Phone\",Windows:\"Windows\",MacOS:\"macOS\",iOS:\"iOS\",Android:\"Android\",WebOS:\"WebOS\",BlackBerry:\"BlackBerry\",Bada:\"Bada\",Tizen:\"Tizen\",Linux:\"Linux\",ChromeOS:\"Chrome OS\",PlayStation4:\"PlayStation 4\",Roku:\"Roku\"};t.ENGINE_MAP={EdgeHTML:\"EdgeHTML\",Blink:\"Blink\",Trident:\"Trident\",Presto:\"Presto\",Gecko:\"Gecko\",WebKit:\"WebKit\"}},90:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),\"string\"!=typeof e)throw new Error(\"UserAgent should be a string\");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:\"BROWSER_MAP\",get:function(){return s.BROWSER_MAP}},{key:\"ENGINE_MAP\",get:function(){return s.ENGINE_MAP}},{key:\"OS_MAP\",get:function(){return s.OS_MAP}},{key:\"PLATFORMS_MAP\",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||\"\"===e)throw new Error(\"UserAgent parameter can't be empty\");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||\"\":this.getBrowser().name||\"\"},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||\"\":t||\"\"},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||\"\":t||\"\"},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||\"\":this.getEngine().name||\"\"},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];\"string\"==typeof a?(i[t]=a,s+=1):\"object\"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if(\"string\"==typeof i)return\">\"===e[0]||\"<\"===e[0]?(r=e.substr(1),\"=\"===e[1]?(n=!0,r=e.substr(2)):t=[],\">\"===e[0]?t.push(1):t.push(-1)):\"=\"===e[0]?r=e.substr(1):\"~\"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\\/(\\d+(\\.?_?\\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:\"Googlebot\"},r=i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\\/|opios/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:\"Samsung Internet for Android\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:\"NAVER Whale Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:\"MZ Browser\"},r=i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:\"Focus\"},r=i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:\"Swing\"},r=i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:\"Opera Coast\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\\/\\d+(?:.?_?\\d+)+/i],describe:function(e){var t={name:\"Opera Touch\"},r=i.default.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:\"Yandex Browser\"},r=i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:\"UC Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:\"Maxthon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:\"Epiphany\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:\"Puffin\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:\"Sleipnir\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:\"K-Meleon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:\"WeChat\"},r=i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?\"QQ Browser Lite\":\"QQ Browser\"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:\"Internet Explorer\"},r=i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\\sedg\\//i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:\"Vivaldi\"},r=i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:\"SeaMonkey\"},r=i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:\"Sailfish\"},r=i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:\"Amazon Silk\"},r=i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:\"PhantomJS\"},r=i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:\"SlimerJS\"},r=i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t={name:\"BlackBerry\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:\"WebOS Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:\"Bada\"},r=i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:\"Tizen\"},r=i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:\"QupZilla\"},r=i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:\"Firefox\"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:\"Electron\"},r=i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:\"Miui\"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:\"Chromium\"},r=i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:\"Chrome\"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:\"Google Search\"},r=i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:\"Android Browser\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:\"PlayStation 4\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:\"Safari\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search(\"\\\\(\")?/^(.*)\\/(.*)[ \\t]\\((.*)/:/^(.*)\\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i,e).replace(/[_\\s]/g,\".\"),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i,e).replace(/[_\\s]/g,\".\");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i,e)||i.default.getFirstMatch(/\\bbb(\\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:\"bot\",vendor:\"Google\"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&\"Nova\",r={type:s.PLATFORMS_MAP.mobile,vendor:\"Huawei\"};return t&&(r.model=t),r}},{test:[/nexus\\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Nexus\"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\",model:\"Kindle Fire HD 7\"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:\"Apple\",model:t}}},{test:[/nexus\\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Nexus\"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"blackberry\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"BlackBerry\"}}},{test:function(e){return\"bada\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"windows phone\"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Microsoft\"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(\".\")[0]);return\"android\"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return\"android\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"macos\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:\"Apple\"}}},{test:function(e){return\"windows\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"linux\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"playstation 4\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return\"roku\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return\"microsoft edge\"===e.getBrowserName(!0)},describe:function(e){if(/\\sedg\\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\\/537\\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));\n\n//# sourceURL=webpack:///./node_modules/bowser/es5.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/es5-ext/global.js":
/*!****************************************!*\
  !*** ./node_modules/es5-ext/global.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n\n\n//# sourceURL=webpack:///./node_modules/es5-ext/global.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/h264-profile-level-id/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/h264-profile-level-id/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\")('h264-profile-level-id');\n\n/* eslint-disable no-console */\ndebug.log = console.info.bind(console);\n/* eslint-enable no-console */\n\nconst ProfileConstrainedBaseline = 1;\nconst ProfileBaseline = 2;\nconst ProfileMain = 3;\nconst ProfileConstrainedHigh = 4;\nconst ProfileHigh = 5;\n\nexports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;\nexports.ProfileBaseline = ProfileBaseline;\nexports.ProfileMain = ProfileMain;\nexports.ProfileConstrainedHigh = ProfileConstrainedHigh;\nexports.ProfileHigh = ProfileHigh;\n\n// All values are equal to ten times the level number, except level 1b which is\n// special.\nconst Level1_b = 0;\nconst Level1 = 10;\nconst Level1_1 = 11;\nconst Level1_2 = 12;\nconst Level1_3 = 13;\nconst Level2 = 20;\nconst Level2_1 = 21;\nconst Level2_2 = 22;\nconst Level3 = 30;\nconst Level3_1 = 31;\nconst Level3_2 = 32;\nconst Level4 = 40;\nconst Level4_1 = 41;\nconst Level4_2 = 42;\nconst Level5 = 50;\nconst Level5_1 = 51;\nconst Level5_2 = 52;\n\nexports.Level1_b = Level1_b;\nexports.Level1 = Level1;\nexports.Level1_1 = Level1_1;\nexports.Level1_2 = Level1_2;\nexports.Level1_3 = Level1_3;\nexports.Level2 = Level2;\nexports.Level2_1 = Level2_1;\nexports.Level2_2 = Level2_2;\nexports.Level3 = Level3;\nexports.Level3_1 = Level3_1;\nexports.Level3_2 = Level3_2;\nexports.Level4 = Level4;\nexports.Level4_1 = Level4_1;\nexports.Level4_2 = Level4_2;\nexports.Level5 = Level5;\nexports.Level5_1 = Level5_1;\nexports.Level5_2 = Level5_2;\n\nclass ProfileLevelId\n{\n\tconstructor(profile, level)\n\t{\n\t\tthis.profile = profile;\n\t\tthis.level = level;\n\t}\n}\n\nexports.ProfileLevelId = ProfileLevelId;\n\n// Default ProfileLevelId.\n//\n// TODO: The default should really be profile Baseline and level 1 according to\n// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not\n// break backwards compatibility with older versions of WebRTC where external\n// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1\n// instead. This workaround will only be done in an interim period to allow\n// external clients to update their code.\n//\n// http://crbug/webrtc/6337.\nconst DefaultProfileLevelId =\n\tnew ProfileLevelId(ProfileConstrainedBaseline, Level3_1);\n\n// For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3\n// flag specifies if level 1b or level 1.1 is used.\nconst ConstraintSet3Flag = 0x10;\n\n// Class for matching bit patterns such as \"x1xx0000\" where 'x' is allowed to be\n// either 0 or 1.\nclass BitPattern\n{\n\tconstructor(str)\n\t{\n\t\tthis._mask = ~byteMaskString('x', str);\n\t\tthis._maskedValue = byteMaskString('1', str);\n\t}\n\n\tisMatch(value)\n\t{\n\t\treturn this._maskedValue === (value & this._mask);\n\t}\n}\n\n// Class for converting between profile_idc/profile_iop to Profile.\nclass ProfilePattern\n{\n\tconstructor(profile_idc, profile_iop, profile)\n\t{\n\t\tthis.profile_idc = profile_idc;\n\t\tthis.profile_iop = profile_iop;\n\t\tthis.profile = profile;\n\t}\n}\n\n// This is from https://tools.ietf.org/html/rfc6184#section-8.1.\nconst ProfilePatterns =\n[\n\tnew ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline),\n\tnew ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline),\n\tnew ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain),\n\tnew ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh),\n\tnew ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)\n];\n\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes.\n * Nothing will be returned if the string is not a recognized H264 profile\n * level id.\n *\n * @param {String} str - profile-level-id value as a string of 3 hex bytes.\n *\n * @returns {ProfileLevelId}\n */\nexports.parseProfileLevelId = function(str)\n{\n\t// The string should consist of 3 bytes in hexadecimal format.\n\tif (typeof str !== 'string' || str.length !== 6)\n\t\treturn null;\n\n\tconst profile_level_id_numeric = parseInt(str, 16);\n\n\tif (profile_level_id_numeric === 0)\n\t\treturn null;\n\n\t// Separate into three bytes.\n\tconst level_idc = profile_level_id_numeric & 0xFF;\n\tconst profile_iop = (profile_level_id_numeric >> 8) & 0xFF;\n\tconst profile_idc = (profile_level_id_numeric >> 16) & 0xFF;\n\n\t// Parse level based on level_idc and constraint set 3 flag.\n\tlet level;\n\n\tswitch (level_idc)\n\t{\n\t\tcase Level1_1:\n\t\t{\n\t\t\tlevel = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;\n\t\t\tbreak;\n\t\t}\n\t\tcase Level1:\n\t\tcase Level1_2:\n\t\tcase Level1_3:\n\t\tcase Level2:\n\t\tcase Level2_1:\n\t\tcase Level2_2:\n\t\tcase Level3:\n\t\tcase Level3_1:\n\t\tcase Level3_2:\n\t\tcase Level4:\n\t\tcase Level4_1:\n\t\tcase Level4_2:\n\t\tcase Level5:\n\t\tcase Level5_1:\n\t\tcase Level5_2:\n\t\t{\n\t\t\tlevel = level_idc;\n\t\t\tbreak;\n\t\t}\n\t\t// Unrecognized level_idc.\n\t\tdefault:\n\t\t{\n\t\t\tdebug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Parse profile_idc/profile_iop into a Profile enum.\n\tfor (const pattern of ProfilePatterns)\n\t{\n\t\tif (\n\t\t\tprofile_idc === pattern.profile_idc &&\n\t\t\tpattern.profile_iop.isMatch(profile_iop)\n\t\t)\n\t\t{\n\t\t\treturn new ProfileLevelId(pattern.profile, level);\n\t\t}\n\t}\n\n\tdebug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');\n\n\treturn null;\n};\n\n/**\n * Returns canonical string representation as three hex bytes of the profile\n * level id, or returns nothing for invalid profile level ids.\n *\n * @param {ProfileLevelId} profile_level_id\n *\n * @returns {String}\n */\nexports.profileLevelIdToString = function(profile_level_id)\n{\n\t// Handle special case level == 1b.\n\tif (profile_level_id.level == Level1_b)\n\t{\n\t\tswitch (profile_level_id.profile)\n\t\t{\n\t\t\tcase ProfileConstrainedBaseline:\n\t\t\t{\n\t\t\t\treturn '42f00b';\n\t\t\t}\n\t\t\tcase ProfileBaseline:\n\t\t\t{\n\t\t\t\treturn '42100b';\n\t\t\t}\n\t\t\tcase ProfileMain:\n\t\t\t{\n\t\t\t\treturn '4d100b';\n\t\t\t}\n\t\t\t// Level 1_b is not allowed for other profiles.\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tdebug(\n\t\t\t\t\t'profileLevelIdToString() | Level 1_b not is allowed for profile:%s',\n\t\t\t\t\tprofile_level_id.profile);\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet profile_idc_iop_string;\n\n\tswitch (profile_level_id.profile)\n\t{\n\t\tcase ProfileConstrainedBaseline:\n\t\t{\n\t\t\tprofile_idc_iop_string = '42e0';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileBaseline:\n\t\t{\n\t\t\tprofile_idc_iop_string = '4200';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileMain:\n\t\t{\n\t\t\tprofile_idc_iop_string = '4d00';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileConstrainedHigh:\n\t\t{\n\t\t\tprofile_idc_iop_string = '640c';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileHigh:\n\t\t{\n\t\t\tprofile_idc_iop_string = '6400';\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tdebug(\n\t\t\t\t'profileLevelIdToString() | unrecognized profile:%s',\n\t\t\t\tprofile_level_id.profile);\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tlet levelStr = (profile_level_id.level).toString(16);\n\n\tif (levelStr.length === 1)\n\t\tlevelStr = `0${levelStr}`;\n\n\treturn `${profile_idc_iop_string}${levelStr}`;\n};\n\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes\n * contained in an SDP key-value map. A default profile level id will be\n * returned if the profile-level-id key is missing. Nothing will be returned if\n * the key is present but the string is invalid.\n *\n * @param {Object} [params={}] - Codec parameters object.\n *\n * @returns {ProfileLevelId}\n */\nexports.parseSdpProfileLevelId = function(params = {})\n{\n\tconst profile_level_id = params['profile-level-id'];\n\n\treturn !profile_level_id\n\t\t? DefaultProfileLevelId\n\t\t: exports.parseProfileLevelId(profile_level_id);\n};\n\n/**\n * Returns true if the parameters have the same H264 profile, i.e. the same\n * H264 profile (Baseline, High, etc).\n *\n * @param {Object} [params1={}] - Codec parameters object.\n * @param {Object} [params2={}] - Codec parameters object.\n *\n * @returns {Boolean}\n */\nexports.isSameProfile = function(params1 = {}, params2 = {})\n{\n\tconst profile_level_id_1 = exports.parseSdpProfileLevelId(params1);\n\tconst profile_level_id_2 = exports.parseSdpProfileLevelId(params2);\n\n\t// Compare H264 profiles, but not levels.\n\treturn Boolean(\n\t\tprofile_level_id_1 &&\n\t\tprofile_level_id_2 &&\n\t\tprofile_level_id_1.profile === profile_level_id_2.profile\n\t);\n};\n\n/**\n * Generate codec parameters that will be used as answer in an SDP negotiation\n * based on local supported parameters and remote offered parameters. Both\n * local_supported_params and remote_offered_params represent sendrecv media\n * descriptions, i.e they are a mix of both encode and decode capabilities. In\n * theory, when the profile in local_supported_params represent a strict superset\n * of the profile in remote_offered_params, we could limit the profile in the\n * answer to the profile in remote_offered_params.\n *\n * However, to simplify the code, each supported H264 profile should be listed\n * explicitly in the list of local supported codecs, even if they are redundant.\n * Then each local codec in the list should be tested one at a time against the\n * remote codec, and only when the profiles are equal should this function be\n * called. Therefore, this function does not need to handle profile intersection,\n * and the profile of local_supported_params and remote_offered_params must be\n * equal before calling this function. The parameters that are used when\n * negotiating are the level part of profile-level-id and level-asymmetry-allowed.\n *\n * @param {Object} [local_supported_params={}]\n * @param {Object} [remote_offered_params={}]\n *\n * @returns {String} Canonical string representation as three hex bytes of the\n *   profile level id, or null if no one of the params have profile-level-id.\n *\n * @throws {TypeError} If Profile mismatch or invalid params.\n */\nexports.generateProfileLevelIdForAnswer = function(\n\tlocal_supported_params = {},\n\tremote_offered_params = {}\n)\n{\n\t// If both local and remote params do not contain profile-level-id, they are\n\t// both using the default profile. In this case, don't return anything.\n\tif (\n\t\t!local_supported_params['profile-level-id'] &&\n\t\t!remote_offered_params['profile-level-id']\n\t)\n\t{\n\t\tdebug(\n\t\t\t'generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');\n\n\t\treturn null;\n\t}\n\n\t// Parse profile-level-ids.\n\tconst local_profile_level_id =\n\t\texports.parseSdpProfileLevelId(local_supported_params);\n\tconst remote_profile_level_id =\n\t\texports.parseSdpProfileLevelId(remote_offered_params);\n\n\t// The local and remote codec must have valid and equal H264 Profiles.\n\tif (!local_profile_level_id)\n\t\tthrow new TypeError('invalid local_profile_level_id');\n\n\tif (!remote_profile_level_id)\n\t\tthrow new TypeError('invalid remote_profile_level_id');\n\n\tif (local_profile_level_id.profile !== remote_profile_level_id.profile)\n\t\tthrow new TypeError('H264 Profile mismatch');\n\n\t// Parse level information.\n\tconst level_asymmetry_allowed = (\n\t\tisLevelAsymmetryAllowed(local_supported_params) &&\n\t\tisLevelAsymmetryAllowed(remote_offered_params)\n\t);\n\n\tconst local_level = local_profile_level_id.level;\n\tconst remote_level = remote_profile_level_id.level;\n\tconst min_level = minLevel(local_level, remote_level);\n\n\t// Determine answer level. When level asymmetry is not allowed, level upgrade\n\t// is not allowed, i.e., the level in the answer must be equal to or lower\n\t// than the level in the offer.\n\tconst answer_level = level_asymmetry_allowed ? local_level : min_level;\n\n\tdebug(\n\t\t'generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]',\n\t\tlocal_profile_level_id.profile, answer_level);\n\n\t// Return the resulting profile-level-id for the answer parameters.\n\treturn exports.profileLevelIdToString(\n\t\tnew ProfileLevelId(local_profile_level_id.profile, answer_level));\n};\n\n// Convert a string of 8 characters into a byte where the positions containing\n// character c will have their bit set. For example, c = 'x', str = \"x1xx0000\"\n// will return 0b10110000.\nfunction byteMaskString(c, str)\n{\n\treturn (\n\t\t((str[0] === c) << 7) | ((str[1] === c) << 6) | ((str[2] === c) << 5) |\n\t\t((str[3] === c) << 4)\t| ((str[4] === c) << 3)\t| ((str[5] === c) << 2)\t|\n\t\t((str[6] === c) << 1)\t| ((str[7] === c) << 0)\n\t);\n}\n\n// Compare H264 levels and handle the level 1b case.\nfunction isLessLevel(a, b)\n{\n\tif (a === Level1_b)\n\t\treturn b !== Level1 && b !== Level1_b;\n\n\tif (b === Level1_b)\n\t\treturn a !== Level1;\n\n\treturn a < b;\n}\n\nfunction minLevel(a, b)\n{\n\treturn isLessLevel(a, b) ? a : b;\n}\n\nfunction isLevelAsymmetryAllowed(params = {})\n{\n\tconst level_asymmetry_allowed = params['level-asymmetry-allowed'];\n\n\treturn (\n\t\tlevel_asymmetry_allowed === 1 ||\n\t\tlevel_asymmetry_allowed === '1'\n\t);\n}\n\n\n//# sourceURL=webpack:///./node_modules/h264-profile-level-id/index.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/EnhancedEventEmitter.js":
/*!****************************************************************!*\
  !*** ./node_modules/protoo-client/lib/EnhancedEventEmitter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { EventEmitter } = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst Logger = __webpack_require__(/*! ./Logger */ \"./node_modules/protoo-client/lib/Logger.js\");\n\nclass EnhancedEventEmitter extends EventEmitter\n{\n\tconstructor(logger)\n\t{\n\t\tsuper();\n\t\tthis.setMaxListeners(Infinity);\n\n\t\tthis._logger = logger || new Logger('EnhancedEventEmitter');\n\t}\n\n\tsafeEmit(event, ...args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.emit(event, ...args);\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tthis._logger.error(\n\t\t\t\t'safeEmit() | event listener threw an error [event:%s]:%o',\n\t\t\t\tevent, error);\n\t\t}\n\t}\n\n\tasync safeEmitAsPromise(event, ...args)\n\t{\n\t\treturn new Promise((resolve, reject) =>\n\t\t{\n\t\t\tthis.safeEmit(event, ...args, resolve, reject);\n\t\t});\n\t}\n}\n\nmodule.exports = EnhancedEventEmitter;\n\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/EnhancedEventEmitter.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/Logger.js":
/*!**************************************************!*\
  !*** ./node_modules/protoo-client/lib/Logger.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n\nconst APP_NAME = 'protoo-client';\n\nclass Logger\n{\n\tconstructor(prefix)\n\t{\n\t\tif (prefix)\n\t\t{\n\t\t\tthis._debug = debug(`${APP_NAME}:${prefix}`);\n\t\t\tthis._warn = debug(`${APP_NAME}:WARN:${prefix}`);\n\t\t\tthis._error = debug(`${APP_NAME}:ERROR:${prefix}`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._debug = debug(APP_NAME);\n\t\t\tthis._warn = debug(`${APP_NAME}:WARN`);\n\t\t\tthis._error = debug(`${APP_NAME}:ERROR`);\n\t\t}\n\n\t\t/* eslint-disable no-console */\n\t\tthis._debug.log = console.info.bind(console);\n\t\tthis._warn.log = console.warn.bind(console);\n\t\tthis._error.log = console.error.bind(console);\n\t\t/* eslint-enable no-console */\n\t}\n\n\tget debug()\n\t{\n\t\treturn this._debug;\n\t}\n\n\tget warn()\n\t{\n\t\treturn this._warn;\n\t}\n\n\tget error()\n\t{\n\t\treturn this._error;\n\t}\n}\n\nmodule.exports = Logger;\n\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/Logger.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/Message.js":
/*!***************************************************!*\
  !*** ./node_modules/protoo-client/lib/Message.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Logger = __webpack_require__(/*! ./Logger */ \"./node_modules/protoo-client/lib/Logger.js\");\nconst { generateRandomNumber } = __webpack_require__(/*! ./utils */ \"./node_modules/protoo-client/lib/utils.js\");\n\nconst logger = new Logger('Message');\n\nclass Message\n{\n\tstatic parse(raw)\n\t{\n\t\tlet object;\n\t\tconst message = {};\n\n\t\ttry\n\t\t{\n\t\t\tobject = JSON.parse(raw);\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.error('parse() | invalid JSON: %s', error);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof object !== 'object' || Array.isArray(object))\n\t\t{\n\t\t\tlogger.error('parse() | not an object');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Request.\n\t\tif (object.request)\n\t\t{\n\t\t\tmessage.request = true;\n\n\t\t\tif (typeof object.method !== 'string')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid method field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof object.id !== 'number')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid id field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.id = object.id;\n\t\t\tmessage.method = object.method;\n\t\t\tmessage.data = object.data || {};\n\t\t}\n\t\t// Response.\n\t\telse if (object.response)\n\t\t{\n\t\t\tmessage.response = true;\n\n\t\t\tif (typeof object.id !== 'number')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid id field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.id = object.id;\n\n\t\t\t// Success.\n\t\t\tif (object.ok)\n\t\t\t{\n\t\t\t\tmessage.ok = true;\n\t\t\t\tmessage.data = object.data || {};\n\t\t\t}\n\t\t\t// Error.\n\t\t\telse\n\t\t\t{\n\t\t\t\tmessage.ok = false;\n\t\t\t\tmessage.errorCode = object.errorCode;\n\t\t\t\tmessage.errorReason = object.errorReason;\n\t\t\t}\n\t\t}\n\t\t// Notification.\n\t\telse if (object.notification)\n\t\t{\n\t\t\tmessage.notification = true;\n\n\t\t\tif (typeof object.method !== 'string')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid method field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.method = object.method;\n\t\t\tmessage.data = object.data || {};\n\t\t}\n\t\t// Invalid.\n\t\telse\n\t\t{\n\t\t\tlogger.error('parse() | missing request/response field');\n\n\t\t\treturn;\n\t\t}\n\n\t\treturn message;\n\t}\n\n\tstatic createRequest(method, data)\n\t{\n\t\tconst request =\n\t\t{\n\t\t\trequest : true,\n\t\t\tid      : generateRandomNumber(),\n\t\t\tmethod  : method,\n\t\t\tdata    : data || {}\n\t\t};\n\n\t\treturn request;\n\t}\n\n\tstatic createSuccessResponse(request, data)\n\t{\n\t\tconst response =\n\t\t{\n\t\t\tresponse : true,\n\t\t\tid       : request.id,\n\t\t\tok       : true,\n\t\t\tdata     : data || {}\n\t\t};\n\n\t\treturn response;\n\t}\n\n\tstatic createErrorResponse(request, errorCode, errorReason)\n\t{\n\t\tconst response =\n\t\t{\n\t\t\tresponse    : true,\n\t\t\tid          : request.id,\n\t\t\tok          : false,\n\t\t\terrorCode   : errorCode,\n\t\t\terrorReason : errorReason\n\t\t};\n\n\t\treturn response;\n\t}\n\n\tstatic createNotification(method, data)\n\t{\n\t\tconst notification =\n\t\t{\n\t\t\tnotification : true,\n\t\t\tmethod       : method,\n\t\t\tdata         : data || {}\n\t\t};\n\n\t\treturn notification;\n\t}\n}\n\nmodule.exports = Message;\n\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/Message.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/Peer.js":
/*!************************************************!*\
  !*** ./node_modules/protoo-client/lib/Peer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Logger = __webpack_require__(/*! ./Logger */ \"./node_modules/protoo-client/lib/Logger.js\");\nconst EnhancedEventEmitter = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./node_modules/protoo-client/lib/EnhancedEventEmitter.js\");\nconst Message = __webpack_require__(/*! ./Message */ \"./node_modules/protoo-client/lib/Message.js\");\n\nconst logger = new Logger('Peer');\n\nclass Peer extends EnhancedEventEmitter\n{\n\t/**\n\t * @param {protoo.Transport} transport\n\t *\n\t * @emits open\n\t * @emits {currentAttempt: Number} failed\n\t * @emits disconnected\n\t * @emits close\n\t * @emits {request: protoo.Request, accept: Function, reject: Function} request\n\t * @emits {notification: protoo.Notification} notification\n\t */\n\tconstructor(transport)\n\t{\n\t\tsuper(logger);\n\n\t\tlogger.debug('constructor()');\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// Transport.\n\t\t// @type {protoo.Transport}\n\t\tthis._transport = transport;\n\n\t\t// Connected flag.\n\t\t// @type {Boolean}\n\t\tthis._connected = false;\n\n\t\t// Custom data object.\n\t\t// @type {Object}\n\t\tthis._data = {};\n\n\t\t// Map of pending sent request objects indexed by request id.\n\t\t// @type {Map<Number, Object>}\n\t\tthis._sents = new Map();\n\n\t\t// Handle transport.\n\t\tthis._handleTransport();\n\t}\n\n\t/**\n\t * Whether the Peer is closed.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\t/**\n\t * Whether the Peer is connected.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget connected()\n\t{\n\t\treturn this._connected;\n\t}\n\n\t/**\n\t * App custom data.\n\t *\n\t * @returns {Object}\n\t */\n\tget data()\n\t{\n\t\treturn this._data;\n\t}\n\n\t/**\n\t * Invalid setter.\n\t */\n\tset data(data) // eslint-disable-line no-unused-vars\n\t{\n\t\tthrow new Error('cannot override data object');\n\t}\n\n\t/**\n\t * Close this Peer and its Transport.\n\t */\n\tclose()\n\t{\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tlogger.debug('close()');\n\n\t\tthis._closed = true;\n\t\tthis._connected = false;\n\n\t\t// Close Transport.\n\t\tthis._transport.close();\n\n\t\t// Close every pending sent.\n\t\tfor (const sent of this._sents.values())\n\t\t{\n\t\t\tsent.close();\n\t\t}\n\n\t\t// Emit 'close' event.\n\t\tthis.safeEmit('close');\n\t}\n\n\t/**\n\t * Send a protoo request to the server-side Room.\n\t *\n\t * @param {String} method\n\t * @param {Object} [data]\n\t *\n\t * @async\n\t * @returns {Object} The response data Object if a success response is received.\n\t */\n\tasync request(method, data = undefined)\n\t{\n\t\tconst request = Message.createRequest(method, data);\n\n\t\tthis._logger.debug('request() [method:%s, id:%s]', method, request.id);\n\n\t\t// This may throw.\n\t\tawait this._transport.send(request);\n\n\t\treturn new Promise((pResolve, pReject) =>\n\t\t{\n\t\t\tconst timeout = 1500 * (15 + (0.1 * this._sents.size));\n\t\t\tconst sent =\n\t\t\t{\n\t\t\t\tid      : request.id,\n\t\t\t\tmethod  : request.method,\n\t\t\t\tresolve : (data2) =>\n\t\t\t\t{\n\t\t\t\t\tif (!this._sents.delete(request.id))\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tclearTimeout(sent.timer);\n\t\t\t\t\tpResolve(data2);\n\t\t\t\t},\n\t\t\t\treject : (error) =>\n\t\t\t\t{\n\t\t\t\t\tif (!this._sents.delete(request.id))\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tclearTimeout(sent.timer);\n\t\t\t\t\tpReject(error);\n\t\t\t\t},\n\t\t\t\ttimer : setTimeout(() =>\n\t\t\t\t{\n\t\t\t\t\tif (!this._sents.delete(request.id))\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tpReject(new Error('request timeout'));\n\t\t\t\t}, timeout),\n\t\t\t\tclose : () =>\n\t\t\t\t{\n\t\t\t\t\tclearTimeout(sent.timer);\n\t\t\t\t\tpReject(new Error('peer closed'));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Add sent stuff to the map.\n\t\t\tthis._sents.set(request.id, sent);\n\t\t});\n\t}\n\n\t/**\n\t * Send a protoo notification to the server-side Room.\n\t *\n\t * @param {String} method\n\t * @param {Object} [data]\n\t *\n\t * @async\n\t */\n\tasync notify(method, data = undefined)\n\t{\n\t\tconst notification = Message.createNotification(method, data);\n\n\t\tthis._logger.debug('notify() [method:%s]', method);\n\n\t\t// This may throw.\n\t\tawait this._transport.send(notification);\n\t}\n\n\t_handleTransport()\n\t{\n\t\tif (this._transport.closed)\n\t\t{\n\t\t\tthis._closed = true;\n\n\t\t\tsetTimeout(() =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tthis._connected = false;\n\n\t\t\t\tthis.safeEmit('close');\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis._transport.on('open', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('emit \"open\"');\n\n\t\t\tthis._connected = true;\n\n\t\t\tthis.safeEmit('open');\n\t\t});\n\n\t\tthis._transport.on('disconnected', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('emit \"disconnected\"');\n\n\t\t\tthis._connected = false;\n\n\t\t\tthis.safeEmit('disconnected');\n\t\t});\n\n\t\tthis._transport.on('failed', (currentAttempt) =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('emit \"failed\" [currentAttempt:%s]', currentAttempt);\n\n\t\t\tthis._connected = false;\n\n\t\t\tthis.safeEmit('failed', currentAttempt);\n\t\t});\n\n\t\tthis._transport.on('close', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tthis._closed = true;\n\n\t\t\tlogger.debug('emit \"close\"');\n\n\t\t\tthis._connected = false;\n\n\t\t\tthis.safeEmit('close');\n\t\t});\n\n\t\tthis._transport.on('message', (message) =>\n\t\t{\n\t\t\tif (message.request)\n\t\t\t\tthis._handleRequest(message);\n\t\t\telse if (message.response)\n\t\t\t\tthis._handleResponse(message);\n\t\t\telse if (message.notification)\n\t\t\t\tthis._handleNotification(message);\n\t\t});\n\t}\n\n\t_handleRequest(request)\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.emit('request',\n\t\t\t\t// Request.\n\t\t\t\trequest,\n\t\t\t\t// accept() function.\n\t\t\t\t(data) =>\n\t\t\t\t{\n\t\t\t\t\tconst response = Message.createSuccessResponse(request, data);\n\n\t\t\t\t\tthis._transport.send(response)\n\t\t\t\t\t\t.catch(() => {});\n\t\t\t\t},\n\t\t\t\t// reject() function.\n\t\t\t\t(errorCode, errorReason) =>\n\t\t\t\t{\n\t\t\t\t\tif (errorCode instanceof Error)\n\t\t\t\t\t{\n\t\t\t\t\t\terrorReason = errorCode.message;\n\t\t\t\t\t\terrorCode = 500;\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeof errorCode === 'number' && errorReason instanceof Error)\n\t\t\t\t\t{\n\t\t\t\t\t\terrorReason = errorReason.message;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst response =\n\t\t\t\t\t\tMessage.createErrorResponse(request, errorCode, errorReason);\n\n\t\t\t\t\tthis._transport.send(response)\n\t\t\t\t\t\t.catch(() => {});\n\t\t\t\t});\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tconst response = Message.createErrorResponse(request, 500, String(error));\n\n\t\t\tthis._transport.send(response)\n\t\t\t\t.catch(() => {});\n\t\t}\n\t}\n\n\t_handleResponse(response)\n\t{\n\t\tconst sent = this._sents.get(response.id);\n\n\t\tif (!sent)\n\t\t{\n\t\t\tlogger.error(\n\t\t\t\t'received response does not match any sent request [id:%s]', response.id);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (response.ok)\n\t\t{\n\t\t\tsent.resolve(response.data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst error = new Error(response.errorReason);\n\n\t\t\terror.code = response.errorCode;\n\t\t\tsent.reject(error);\n\t\t}\n\t}\n\n\t_handleNotification(notification)\n\t{\n\t\tthis.safeEmit('notification', notification);\n\t}\n}\n\nmodule.exports = Peer;\n\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/Peer.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/protoo-client/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { version } = __webpack_require__(/*! ../package.json */ \"./node_modules/protoo-client/package.json\");\nconst Peer = __webpack_require__(/*! ./Peer */ \"./node_modules/protoo-client/lib/Peer.js\");\nconst WebSocketTransport = __webpack_require__(/*! ./transports/WebSocketTransport */ \"./node_modules/protoo-client/lib/transports/WebSocketTransport.js\");\n\n/**\n * Expose mediasoup-client version.\n *\n * @type {String}\n */\nexports.version = version;\n\n/**\n * Expose Peer class.\n *\n * @type {Class}\n */\nexports.Peer = Peer;\n\n/**\n * Expose WebSocketTransport class.\n *\n * @type {Class}\n */\nexports.WebSocketTransport = WebSocketTransport;\n\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/index.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/transports/WebSocketTransport.js":
/*!*************************************************************************!*\
  !*** ./node_modules/protoo-client/lib/transports/WebSocketTransport.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const W3CWebSocket = __webpack_require__(/*! websocket */ \"./node_modules/websocket/lib/browser.js\").w3cwebsocket;\nconst retry = __webpack_require__(/*! retry */ \"./node_modules/retry/index.js\");\nconst Logger = __webpack_require__(/*! ../Logger */ \"./node_modules/protoo-client/lib/Logger.js\");\nconst EnhancedEventEmitter = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./node_modules/protoo-client/lib/EnhancedEventEmitter.js\");\nconst Message = __webpack_require__(/*! ../Message */ \"./node_modules/protoo-client/lib/Message.js\");\n\nconst WS_SUBPROTOCOL = 'protoo';\nconst DEFAULT_RETRY_OPTIONS =\n{\n\tretries    : 10,\n\tfactor     : 2,\n\tminTimeout : 1 * 1000,\n\tmaxTimeout : 8 * 1000\n};\n\nconst logger = new Logger('WebSocketTransport');\n\nclass WebSocketTransport extends EnhancedEventEmitter\n{\n\t/**\n\t * @param {String} url - WebSocket URL.\n\t * @param {Object} [options] - Options for WebSocket-Node.W3CWebSocket and retry.\n\t */\n\tconstructor(url, options)\n\t{\n\t\tsuper(logger);\n\n\t\tlogger.debug('constructor() [url:%s, options:%o]', url, options);\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// WebSocket URL.\n\t\t// @type {String}\n\t\tthis._url = url;\n\n\t\t// Options.\n\t\t// @type {Object}\n\t\tthis._options = options || {};\n\n\t\t// WebSocket instance.\n\t\t// @type {WebSocket}\n\t\tthis._ws = null;\n\n\t\t// Run the WebSocket.\n\t\tthis._runWebSocket();\n\t}\n\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\tclose()\n\t{\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tlogger.debug('close()');\n\n\t\t// Don't wait for the WebSocket 'close' event, do it now.\n\t\tthis._closed = true;\n\t\tthis.safeEmit('close');\n\n\t\ttry\n\t\t{\n\t\t\tthis._ws.onopen = null;\n\t\t\tthis._ws.onclose = null;\n\t\t\tthis._ws.onerror = null;\n\t\t\tthis._ws.onmessage = null;\n\t\t\tthis._ws.close();\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.error('close() | error closing the WebSocket: %o', error);\n\t\t}\n\t}\n\n\tasync send(message)\n\t{\n\t\tif (this._closed)\n\t\t\tthrow new Error('transport closed');\n\n\t\ttry\n\t\t{\n\t\t\tthis._ws.send(JSON.stringify(message));\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.warn('send() failed:%o', error);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t_runWebSocket()\n\t{\n\t\tconst operation =\n\t\t\tretry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);\n\n\t\tlet wasConnected = false;\n\n\t\toperation.attempt((currentAttempt) =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t{\n\t\t\t\toperation.stop();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug('_runWebSocket() [currentAttempt:%s]', currentAttempt);\n\n\t\t\tthis._ws = new W3CWebSocket(\n\t\t\t\tthis._url,\n\t\t\t\tWS_SUBPROTOCOL,\n\t\t\t\tthis._options.origin,\n\t\t\t\tthis._options.headers,\n\t\t\t\tthis._options.requestOptions,\n\t\t\t\tthis._options.clientConfig);\n\n\t\t\tthis._ws.onopen = () =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\twasConnected = true;\n\n\t\t\t\t// Emit 'open' event.\n\t\t\t\tthis.safeEmit('open');\n\t\t\t};\n\n\t\t\tthis._ws.onclose = (event) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'WebSocket \"close\" event [wasClean:%s, code:%s, reason:\"%s\"]',\n\t\t\t\t\tevent.wasClean, event.code, event.reason);\n\n\t\t\t\t// Don't retry if code is 4000 (closed by the server).\n\t\t\t\tif (event.code !== 4000)\n\t\t\t\t{\n\t\t\t\t\t// If it was not connected, try again.\n\t\t\t\t\tif (!wasConnected)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.safeEmit('failed', currentAttempt);\n\n\t\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tif (operation.retry(true))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// If it was connected, start from scratch.\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toperation.stop();\n\n\t\t\t\t\t\tthis.safeEmit('disconnected');\n\n\t\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tthis._runWebSocket();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._closed = true;\n\n\t\t\t\t// Emit 'close' event.\n\t\t\t\tthis.safeEmit('close');\n\t\t\t};\n\n\t\t\tthis._ws.onerror = () =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tlogger.error('WebSocket \"error\" event');\n\t\t\t};\n\n\t\t\tthis._ws.onmessage = (event) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tconst message = Message.parse(event.data);\n\n\t\t\t\tif (!message)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (this.listenerCount('message') === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'no listeners for WebSocket \"message\" event, ignoring received message');\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Emit 'message' event.\n\t\t\t\tthis.safeEmit('message', message);\n\t\t\t};\n\t\t});\n\t}\n}\n\nmodule.exports = WebSocketTransport;\n\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/transports/WebSocketTransport.js?");

/***/ }),

/***/ "./node_modules/protoo-client/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/protoo-client/lib/utils.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Generates a random positive integer.\n *\n * @returns {Number}\n */\nexports.generateRandomNumber = function()\n{\n\treturn Math.round(Math.random() * 10000000);\n};\n\n\n//# sourceURL=webpack:///./node_modules/protoo-client/lib/utils.js?");

/***/ }),

/***/ "./node_modules/protoo-client/package.json":
/*!*************************************************!*\
  !*** ./node_modules/protoo-client/package.json ***!
  \*************************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, dependencies, deprecated, description, devDependencies, engines, homepage, keywords, license, main, name, optionalDependencies, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_from\\\":\\\"protoo-client@^4.0.3\\\",\\\"_id\\\":\\\"protoo-client@4.0.6\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-ZqImkKHpeJhSlgvyI6QAfZNc/aXcCgmmocMx4S1w2lAaxXtckxxeDtcVNtkOISUWm/mbC+BrmYPXoGMkfhkKOQ==\\\",\\\"_location\\\":\\\"/protoo-client\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"range\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"protoo-client@^4.0.3\\\",\\\"name\\\":\\\"protoo-client\\\",\\\"escapedName\\\":\\\"protoo-client\\\",\\\"rawSpec\\\":\\\"^4.0.3\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"^4.0.3\\\"},\\\"_requiredBy\\\":[\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/protoo-client/-/protoo-client-4.0.6.tgz\\\",\\\"_shasum\\\":\\\"02a89f997ee5a4f385dab7be938dda1a2c5158e4\\\",\\\"_spec\\\":\\\"protoo-client@^4.0.3\\\",\\\"_where\\\":\\\"E:\\\\\\\\mcs8\\\\\\\\mcs8_mediaServer\\\\\\\\trunk\\\\\\\\mcs8MediaClient\\\",\\\"author\\\":{\\\"name\\\":\\\"Iñaki Baz Castillo\\\",\\\"email\\\":\\\"ibc@aliax.net\\\"},\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/ibc/protoo/issues\\\"},\\\"bundleDependencies\\\":false,\\\"dependencies\\\":{\\\"debug\\\":\\\"^4.3.1\\\",\\\"events\\\":\\\"^3.2.0\\\",\\\"retry\\\":\\\"^0.12.0\\\",\\\"websocket\\\":\\\"^1.0.33\\\"},\\\"deprecated\\\":false,\\\"description\\\":\\\"protoo JavaScript client module\\\",\\\"devDependencies\\\":{\\\"eslint\\\":\\\"^5.16.0\\\"},\\\"engines\\\":{\\\"node\\\":\\\">=8.0.0\\\"},\\\"homepage\\\":\\\"https://protoo.versatica.com\\\",\\\"keywords\\\":[\\\"nodejs\\\",\\\"browser\\\",\\\"websocket\\\"],\\\"license\\\":\\\"MIT\\\",\\\"main\\\":\\\"lib/index.js\\\",\\\"name\\\":\\\"protoo-client\\\",\\\"optionalDependencies\\\":{\\\"websocket\\\":\\\"^1.0.33\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/ibc/protoo.git\\\"},\\\"scripts\\\":{\\\"lint\\\":\\\"eslint -c .eslintrc.js lib\\\"},\\\"version\\\":\\\"4.0.6\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/protoo-client/package.json?");

/***/ }),

/***/ "./node_modules/retry/index.js":
/*!*************************************!*\
  !*** ./node_modules/retry/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/retry */ \"./node_modules/retry/lib/retry.js\");\n\n//# sourceURL=webpack:///./node_modules/retry/index.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry.js":
/*!*****************************************!*\
  !*** ./node_modules/retry/lib/retry.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var RetryOperation = __webpack_require__(/*! ./retry_operation */ \"./node_modules/retry/lib/retry_operation.js\");\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && options.forever,\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry_operation.js":
/*!***************************************************!*\
  !*** ./node_modules/retry/lib/retry_operation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts;\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(this._errors.length - 1, this._errors.length);\n      this._timeouts = this._cachedTimeouts.slice(0);\n      timeout = this._timeouts.shift();\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  var timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry_operation.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{\n    // o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  // k: [{}], // outdated thing ignored\n  t: [{\n    // t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{\n    // c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{\n    // b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{\n    // m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    {\n      // a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding)\n          ? 'rtpmap:%d %s/%s/%s'\n          : o.rate\n            ? 'rtpmap:%d %s/%s'\n            : 'rtpmap:%d %s';\n      }\n    },\n    {\n      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      // a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    {\n      // a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    {\n      // a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null)\n          ? 'rtcp:%d %s IP%d %s'\n          : 'rtcp:%d';\n      }\n    },\n    {\n      // a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%s trr-int %d'\n    },\n    {\n      // a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null)\n          ? 'rtcp-fb:%s %s %s'\n          : 'rtcp-fb:%s %s';\n      }\n    },\n    {\n      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      // a=extmap:1/recvonly URI-gps-string\n      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],\n      format: function (o) {\n        return (\n          'extmap:%d' +\n          (o.direction ? '/%s' : '%v') +\n          (o['encrypt-uri'] ? ' %s' : '%v') +\n          ' %s' +\n          (o.config ? ' %s' : '')\n        );\n      }\n    },\n    {\n      // a=extmap-allow-mixed\n      name: 'extmapAllowMixed',\n      reg: /^(extmap-allow-mixed)/\n    },\n    {\n      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null)\n          ? 'crypto:%d %s %s %s'\n          : 'crypto:%d %s %s';\n      }\n    },\n    {\n      // a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    {\n      // a=connection:new\n      name: 'connectionType',\n      reg: /^connection:(new|existing)/,\n      format: 'connection:%s'\n    },\n    {\n      // a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    {\n      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    {\n      // a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'ptime:%d'\n    },\n    {\n      // a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n      format: 'maxptime:%d'\n    },\n    {\n      // a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    {\n      // a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    {\n      // a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    {\n      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    {\n      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    {\n      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    {\n      // a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    {\n      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    {\n      // a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    {\n      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    {\n      // a=ssrc-group:FEC 1 2\n      // a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    {\n      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    {\n      // a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    {\n      // a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    {\n      // a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    {\n      // a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null)\n          ? 'sctpmap:%s %s %s'\n          : 'sctpmap:%s %s';\n      }\n    },\n    {\n      // a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    {\n      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    {\n      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      // a=imageattr:* send [x=800,y=640] recv *\n      // a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        // a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        // recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      // a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        // a=simulcast:\n        '^simulcast:' +\n        // send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        // space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        // end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    {\n      // old simulcast draft 03 (implemented by Firefox)\n      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      // a=simulcast: recv pt=97;98 send pt=97\n      // a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      // a=framerate:25\n      // a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    {\n      // RFC4570\n      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    {\n      // a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    },\n    {\n      // a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name: 'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name: 'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    },\n    {\n      // RFC7273\n      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n      push:'tsRefClocks',\n      reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n      names: ['clksrc', 'clksrcExt'],\n      format: function (o) {\n        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');\n      }\n    },\n    {\n      // RFC7273\n      // a=mediaclk:direct=963214424\n      name:'mediaClk',\n      reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],\n      format: function (o) {\n        var str = 'mediaclk:';\n        str += (o.id != null ? 'id=%s %s' : '%v%s');\n        str += (o.mediaClockValue != null ? '=%s' : '');\n        str += (o.rateNumerator != null ? ' rate=%s' : '');\n        str += (o.rateDenominator != null ? '/%s' : '');\n        return str;\n      }\n    },\n    {\n      // a=keywds:keywords\n      name: 'keywords',\n      reg: /^keywds:(.+)$/,\n      format: 'keywds:%s'\n    },\n    {\n      // a=content:main\n      name: 'content',\n      reg: /^content:(.+)/,\n      format: 'content:%s'\n    },\n    // BFCP https://tools.ietf.org/html/rfc4583\n    {\n      // a=floorctrl:c-s\n      name: 'bfcpFloorCtrl',\n      reg: /^floorctrl:(c-only|s-only|c-s)/,\n      format: 'floorctrl:%s'\n    },\n    {\n      // a=confid:1\n      name: 'bfcpConfId',\n      reg: /^confid:(\\d+)/,\n      format: 'confid:%s'\n    },\n    {\n      // a=userid:1\n      name: 'bfcpUserId',\n      reg: /^userid:(\\d+)/,\n      format: 'userid:%s'\n    },\n    {\n      // a=floorid:1\n      name: 'bfcpFloorId',\n      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n      names: ['id', 'mStream'],\n      format: 'floorid:%s mstrm:%s'\n    },\n    {\n      // any a= that we don't understand is kept verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/grammar.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! ./parser */ \"./node_modules/sdp-transform/lib/parser.js\");\nvar writer = __webpack_require__(/*! ./writer */ \"./node_modules/sdp-transform/lib/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/index.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.toString().split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/parser.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n\n//# sourceURL=webpack:///./node_modules/sdp-transform/lib/writer.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = __webpack_require__(/*! es5-ext/global */ \"./node_modules/es5-ext/global.js\");\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = __webpack_require__(/*! ./version */ \"./node_modules/websocket/lib/version.js\");\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n\n\n//# sourceURL=webpack:///./node_modules/websocket/lib/browser.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ../package.json */ \"./node_modules/websocket/package.json\").version;\n\n\n//# sourceURL=webpack:///./node_modules/websocket/lib/version.js?");

/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, browser, bugs, bundleDependencies, config, contributors, dependencies, deprecated, description, devDependencies, directories, engines, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_from\\\":\\\"websocket@^1.0.33\\\",\\\"_id\\\":\\\"websocket@1.0.34\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-PRDso2sGwF6kM75QykIesBijKSVceR6jL2G8NGYyq2XrItNC2P5/qL5XeR056GhA+Ly7JMFvJb9I312mJfmqnQ==\\\",\\\"_location\\\":\\\"/websocket\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"range\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"websocket@^1.0.33\\\",\\\"name\\\":\\\"websocket\\\",\\\"escapedName\\\":\\\"websocket\\\",\\\"rawSpec\\\":\\\"^1.0.33\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"^1.0.33\\\"},\\\"_requiredBy\\\":[\\\"/protoo-client\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/websocket/-/websocket-1.0.34.tgz\\\",\\\"_shasum\\\":\\\"2bdc2602c08bf2c82253b730655c0ef7dcab3111\\\",\\\"_spec\\\":\\\"websocket@^1.0.33\\\",\\\"_where\\\":\\\"E:\\\\\\\\mcs8\\\\\\\\mcs8_mediaServer\\\\\\\\trunk\\\\\\\\mcs8MediaClient\\\\\\\\node_modules\\\\\\\\protoo-client\\\",\\\"author\\\":{\\\"name\\\":\\\"Brian McKelvey\\\",\\\"email\\\":\\\"theturtle32@gmail.com\\\",\\\"url\\\":\\\"https://github.com/theturtle32\\\"},\\\"browser\\\":\\\"lib/browser.js\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/theturtle32/WebSocket-Node/issues\\\"},\\\"bundleDependencies\\\":false,\\\"config\\\":{\\\"verbose\\\":false},\\\"contributors\\\":[{\\\"name\\\":\\\"Iñaki Baz Castillo\\\",\\\"email\\\":\\\"ibc@aliax.net\\\",\\\"url\\\":\\\"http://dev.sipdoc.net\\\"}],\\\"dependencies\\\":{\\\"bufferutil\\\":\\\"^4.0.1\\\",\\\"debug\\\":\\\"^2.2.0\\\",\\\"es5-ext\\\":\\\"^0.10.50\\\",\\\"typedarray-to-buffer\\\":\\\"^3.1.5\\\",\\\"utf-8-validate\\\":\\\"^5.0.2\\\",\\\"yaeti\\\":\\\"^0.0.6\\\"},\\\"deprecated\\\":false,\\\"description\\\":\\\"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\\\",\\\"devDependencies\\\":{\\\"buffer-equal\\\":\\\"^1.0.0\\\",\\\"gulp\\\":\\\"^4.0.2\\\",\\\"gulp-jshint\\\":\\\"^2.0.4\\\",\\\"jshint\\\":\\\"^2.0.0\\\",\\\"jshint-stylish\\\":\\\"^2.2.1\\\",\\\"tape\\\":\\\"^4.9.1\\\"},\\\"directories\\\":{\\\"lib\\\":\\\"./lib\\\"},\\\"engines\\\":{\\\"node\\\":\\\">=4.0.0\\\"},\\\"homepage\\\":\\\"https://github.com/theturtle32/WebSocket-Node\\\",\\\"keywords\\\":[\\\"websocket\\\",\\\"websockets\\\",\\\"socket\\\",\\\"networking\\\",\\\"comet\\\",\\\"push\\\",\\\"RFC-6455\\\",\\\"realtime\\\",\\\"server\\\",\\\"client\\\"],\\\"license\\\":\\\"Apache-2.0\\\",\\\"main\\\":\\\"index\\\",\\\"name\\\":\\\"websocket\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/theturtle32/WebSocket-Node.git\\\"},\\\"scripts\\\":{\\\"gulp\\\":\\\"gulp\\\",\\\"test\\\":\\\"tape test/unit/*.js\\\"},\\\"version\\\":\\\"1.0.34\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/websocket/package.json?");

/***/ }),

/***/ "./src/Consumer.ts":
/*!*************************!*\
  !*** ./src/Consumer.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst logger = new Logger_1.Logger('Consumer');\r\nclass Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {\r\n        super();\r\n        this._closed = false;\r\n        logger.debug('constructor()');\r\n        this._id = id;\r\n        this._localId = localId;\r\n        this._producerId = producerId;\r\n        this._rtpReceiver = rtpReceiver;\r\n        this._track = track;\r\n        this._rtpParameters = rtpParameters;\r\n        this._paused = !track.enabled;\r\n        this._appData = appData;\r\n        this._onTrackEnded = this._onTrackEnded.bind(this);\r\n        this._handleTrack();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get localId() {\r\n        return this._localId;\r\n    }\r\n    get producerId() {\r\n        return this._producerId;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get kind() {\r\n        return this._track.kind;\r\n    }\r\n    get rtpReceiver() {\r\n        return this._rtpReceiver;\r\n    }\r\n    get track() {\r\n        return this._track;\r\n    }\r\n    get rtpParameters() {\r\n        return this._rtpParameters;\r\n    }\r\n    get paused() {\r\n        return this._paused;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._destroyTrack();\r\n        this.emit('@close');\r\n    }\r\n    transportClosed() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('transportClosed()');\r\n        this._closed = true;\r\n        this._destroyTrack();\r\n        this.safeEmit('transportclose');\r\n    }\r\n    getStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            return this.safeEmitAsPromise('@getstats');\r\n        });\r\n    }\r\n    pause() {\r\n        logger.debug('pause()');\r\n        if (this._closed) {\r\n            logger.error('pause() | Consumer closed');\r\n            return;\r\n        }\r\n        this._paused = true;\r\n        this._track.enabled = false;\r\n    }\r\n    resume() {\r\n        logger.debug('resume()');\r\n        if (this._closed) {\r\n            logger.error('resume() | Consumer closed');\r\n            return;\r\n        }\r\n        this._paused = false;\r\n        this._track.enabled = true;\r\n    }\r\n    _onTrackEnded() {\r\n        logger.debug('track \"ended\" event');\r\n        this.safeEmit('trackended');\r\n    }\r\n    _handleTrack() {\r\n        this._track.addEventListener('ended', this._onTrackEnded);\r\n    }\r\n    _destroyTrack() {\r\n        try {\r\n            this._track.removeEventListener('ended', this._onTrackEnded);\r\n            this._track.stop();\r\n        }\r\n        catch (error) { }\r\n    }\r\n}\r\nexports.Consumer = Consumer;\r\n\n\n//# sourceURL=webpack:///./src/Consumer.ts?");

/***/ }),

/***/ "./src/DataConsumer.ts":
/*!*****************************!*\
  !*** ./src/DataConsumer.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst logger = new Logger_1.Logger('DataConsumer');\r\nclass DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {\r\n        super();\r\n        this._closed = false;\r\n        logger.debug('constructor()');\r\n        this._id = id;\r\n        this._dataProducerId = dataProducerId;\r\n        this._dataChannel = dataChannel;\r\n        this._sctpStreamParameters = sctpStreamParameters;\r\n        this._appData = appData;\r\n        this._handleDataChannel();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get dataProducerId() {\r\n        return this._dataProducerId;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get sctpStreamParameters() {\r\n        return this._sctpStreamParameters;\r\n    }\r\n    get readyState() {\r\n        return this._dataChannel.readyState;\r\n    }\r\n    get label() {\r\n        return this._dataChannel.label;\r\n    }\r\n    get protocol() {\r\n        return this._dataChannel.protocol;\r\n    }\r\n    get binaryType() {\r\n        return this._dataChannel.binaryType;\r\n    }\r\n    set binaryType(binaryType) {\r\n        this._dataChannel.binaryType = binaryType;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._dataChannel.close();\r\n        this.emit('@close');\r\n    }\r\n    transportClosed() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('transportClosed()');\r\n        this._closed = true;\r\n        this._dataChannel.close();\r\n        this.safeEmit('transportclose');\r\n    }\r\n    _handleDataChannel() {\r\n        this._dataChannel.addEventListener('open', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.debug('DataChannel \"open\" event');\r\n            this.safeEmit('open');\r\n        });\r\n        this._dataChannel.addEventListener('error', (event) => {\r\n            if (this._closed)\r\n                return;\r\n            let { error } = event;\r\n            if (!error)\r\n                error = new Error('unknown DataChannel error');\r\n            if (error.errorDetail === 'sctp-failure') {\r\n                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\r\n            }\r\n            else {\r\n                logger.error('DataChannel \"error\" event: %o', error);\r\n            }\r\n            this.safeEmit('error', error);\r\n        });\r\n        this._dataChannel.addEventListener('close', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.warn('DataChannel \"close\" event');\r\n            this._closed = true;\r\n            this.emit('@close');\r\n            this.safeEmit('close');\r\n        });\r\n        this._dataChannel.addEventListener('message', (event) => {\r\n            if (this._closed)\r\n                return;\r\n            this.safeEmit('message', event.data);\r\n        });\r\n    }\r\n}\r\nexports.DataConsumer = DataConsumer;\r\n\n\n//# sourceURL=webpack:///./src/DataConsumer.ts?");

/***/ }),

/***/ "./src/DataProducer.ts":
/*!*****************************!*\
  !*** ./src/DataProducer.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst logger = new Logger_1.Logger('DataProducer');\r\nclass DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ id, dataChannel, sctpStreamParameters, appData }) {\r\n        super();\r\n        this._closed = false;\r\n        logger.debug('constructor()');\r\n        this._id = id;\r\n        this._dataChannel = dataChannel;\r\n        this._sctpStreamParameters = sctpStreamParameters;\r\n        this._appData = appData;\r\n        this._handleDataChannel();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get sctpStreamParameters() {\r\n        return this._sctpStreamParameters;\r\n    }\r\n    get readyState() {\r\n        return this._dataChannel.readyState;\r\n    }\r\n    get label() {\r\n        return this._dataChannel.label;\r\n    }\r\n    get protocol() {\r\n        return this._dataChannel.protocol;\r\n    }\r\n    get bufferedAmount() {\r\n        return this._dataChannel.bufferedAmount;\r\n    }\r\n    get bufferedAmountLowThreshold() {\r\n        return this._dataChannel.bufferedAmountLowThreshold;\r\n    }\r\n    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {\r\n        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._dataChannel.close();\r\n        this.emit('@close');\r\n    }\r\n    transportClosed() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('transportClosed()');\r\n        this._closed = true;\r\n        this._dataChannel.close();\r\n        this.safeEmit('transportclose');\r\n    }\r\n    send(data) {\r\n        logger.debug('send()');\r\n        if (this._closed)\r\n            throw new errors_1.InvalidStateError('closed');\r\n        this._dataChannel.send(data);\r\n    }\r\n    _handleDataChannel() {\r\n        this._dataChannel.addEventListener('open', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.debug('DataChannel \"open\" event');\r\n            this.safeEmit('open');\r\n        });\r\n        this._dataChannel.addEventListener('error', (event) => {\r\n            if (this._closed)\r\n                return;\r\n            let { error } = event;\r\n            if (!error)\r\n                error = new Error('unknown DataChannel error');\r\n            if (error.errorDetail === 'sctp-failure') {\r\n                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);\r\n            }\r\n            else {\r\n                logger.error('DataChannel \"error\" event: %o', error);\r\n            }\r\n            this.safeEmit('error', error);\r\n        });\r\n        this._dataChannel.addEventListener('close', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.warn('DataChannel \"close\" event');\r\n            this._closed = true;\r\n            this.emit('@close');\r\n            this.safeEmit('close');\r\n        });\r\n        this._dataChannel.addEventListener('message', () => {\r\n            if (this._closed)\r\n                return;\r\n            logger.warn('DataChannel \"message\" event in a DataProducer, message discarded');\r\n        });\r\n        this._dataChannel.addEventListener('bufferedamountlow', () => {\r\n            if (this._closed)\r\n                return;\r\n            this.safeEmit('bufferedamountlow');\r\n        });\r\n    }\r\n}\r\nexports.DataProducer = DataProducer;\r\n\n\n//# sourceURL=webpack:///./src/DataProducer.ts?");

/***/ }),

/***/ "./src/Device.ts":
/*!***********************!*\
  !*** ./src/Device.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bowser = __importStar(__webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst ortc = __importStar(__webpack_require__(/*! ./ortc */ \"./src/ortc.ts\"));\r\nconst Transport_1 = __webpack_require__(/*! ./Transport */ \"./src/Transport.ts\");\r\nconst Chrome74_1 = __webpack_require__(/*! ./handlers/Chrome74 */ \"./src/handlers/Chrome74.ts\");\r\nconst Chrome70_1 = __webpack_require__(/*! ./handlers/Chrome70 */ \"./src/handlers/Chrome70.ts\");\r\nconst Chrome67_1 = __webpack_require__(/*! ./handlers/Chrome67 */ \"./src/handlers/Chrome67.ts\");\r\nconst Chrome55_1 = __webpack_require__(/*! ./handlers/Chrome55 */ \"./src/handlers/Chrome55.ts\");\r\nconst Firefox60_1 = __webpack_require__(/*! ./handlers/Firefox60 */ \"./src/handlers/Firefox60.ts\");\r\nconst Safari12_1 = __webpack_require__(/*! ./handlers/Safari12 */ \"./src/handlers/Safari12.ts\");\r\nconst Safari11_1 = __webpack_require__(/*! ./handlers/Safari11 */ \"./src/handlers/Safari11.ts\");\r\nconst Edge11_1 = __webpack_require__(/*! ./handlers/Edge11 */ \"./src/handlers/Edge11.ts\");\r\nconst ReactNative_1 = __webpack_require__(/*! ./handlers/ReactNative */ \"./src/handlers/ReactNative.ts\");\r\nconst logger = new Logger_1.Logger('Device');\r\nfunction detectDevice() {\r\n    if (typeof navigator === 'object' && navigator.product === 'ReactNative') {\r\n        if (typeof RTCPeerConnection === 'undefined') {\r\n            logger.warn('this._detectDevice() | unsupported ReactNative without RTCPeerConnection');\r\n            return undefined;\r\n        }\r\n        logger.debug('this._detectDevice() | ReactNative handler chosen');\r\n        return 'ReactNative';\r\n    }\r\n    else if (typeof navigator === 'object' && typeof navigator.userAgent === 'string') {\r\n        const ua = navigator.userAgent;\r\n        const browser = bowser.getParser(ua);\r\n        const engine = browser.getEngine();\r\n        if (browser.satisfies({ chrome: '>=74', chromium: '>=74' })) {\r\n            return 'Chrome74';\r\n        }\r\n        else if (browser.satisfies({ chrome: '>=70', chromium: '>=70' })) {\r\n            return 'Chrome70';\r\n        }\r\n        else if (browser.satisfies({ chrome: '>=67', chromium: '>=67' })) {\r\n            return 'Chrome67';\r\n        }\r\n        else if (browser.satisfies({ chrome: '>=55', chromium: '>=55' })) {\r\n            return 'Chrome55';\r\n        }\r\n        else if (browser.satisfies({ firefox: '>=60' })) {\r\n            return 'Firefox60';\r\n        }\r\n        else if (browser.satisfies({ safari: '>=12.0' }) &&\r\n            typeof RTCRtpTransceiver !== 'undefined' &&\r\n            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {\r\n            return 'Safari12';\r\n        }\r\n        else if (browser.satisfies({ safari: '>=11' })) {\r\n            return 'Safari11';\r\n        }\r\n        else if (browser.satisfies({ 'microsoft edge': '>=11' }) &&\r\n            browser.satisfies({ 'microsoft edge': '<=18' })) {\r\n            return 'Edge11';\r\n        }\r\n        else if (engine.name && engine.name.toLowerCase() === 'blink') {\r\n            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\\w+)/i);\r\n            if (match) {\r\n                const version = Number(match[1]);\r\n                if (version >= 74) {\r\n                    return 'Chrome74';\r\n                }\r\n                else if (version >= 70) {\r\n                    return 'Chrome70';\r\n                }\r\n                else if (version >= 67) {\r\n                    return 'Chrome67';\r\n                }\r\n                else {\r\n                    return 'Chrome55';\r\n                }\r\n            }\r\n            else {\r\n                return 'Chrome74';\r\n            }\r\n        }\r\n        else {\r\n            logger.warn('this._detectDevice() | browser not supported [name:%s, version:%s]', browser.getBrowserName(), browser.getBrowserVersion());\r\n            return undefined;\r\n        }\r\n    }\r\n    else {\r\n        logger.warn('this._detectDevice() | unknown device');\r\n        return undefined;\r\n    }\r\n}\r\nexports.detectDevice = detectDevice;\r\nclass Device {\r\n    constructor({ handlerName, handlerFactory, Handler } = {}) {\r\n        this._loaded = false;\r\n        logger.debug('constructor()');\r\n        if (Handler) {\r\n            logger.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead');\r\n            if (typeof Handler === 'string')\r\n                handlerName = Handler;\r\n            else\r\n                throw new TypeError('non string Handler option no longer supported, use handlerFactory instead');\r\n        }\r\n        if (handlerName && handlerFactory) {\r\n            throw new TypeError('just one of handlerName or handlerInterface can be given');\r\n        }\r\n        if (handlerFactory) {\r\n            this._handlerFactory = handlerFactory;\r\n        }\r\n        else {\r\n            if (handlerName) {\r\n                logger.debug('constructor() | handler given: %s', handlerName);\r\n            }\r\n            else {\r\n                handlerName = detectDevice();\r\n                if (handlerName)\r\n                    logger.debug('constructor() | detected handler: %s', handlerName);\r\n                else\r\n                    throw new errors_1.UnsupportedError('device not supported');\r\n            }\r\n            switch (handlerName) {\r\n                case 'Chrome74':\r\n                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();\r\n                    break;\r\n                case 'Chrome70':\r\n                    this._handlerFactory = Chrome70_1.Chrome70.createFactory();\r\n                    break;\r\n                case 'Chrome67':\r\n                    this._handlerFactory = Chrome67_1.Chrome67.createFactory();\r\n                    break;\r\n                case 'Chrome55':\r\n                    this._handlerFactory = Chrome55_1.Chrome55.createFactory();\r\n                    break;\r\n                case 'Firefox60':\r\n                    this._handlerFactory = Firefox60_1.Firefox60.createFactory();\r\n                    break;\r\n                case 'Safari12':\r\n                    this._handlerFactory = Safari12_1.Safari12.createFactory();\r\n                    break;\r\n                case 'Safari11':\r\n                    this._handlerFactory = Safari11_1.Safari11.createFactory();\r\n                    break;\r\n                case 'Edge11':\r\n                    this._handlerFactory = Edge11_1.Edge11.createFactory();\r\n                    break;\r\n                case 'ReactNative':\r\n                    this._handlerFactory = ReactNative_1.ReactNative.createFactory();\r\n                    break;\r\n                default:\r\n                    throw new TypeError(`unknown handlerName \"${handlerName}\"`);\r\n            }\r\n        }\r\n        const handler = this._handlerFactory();\r\n        this._handlerName = handler.name;\r\n        handler.close();\r\n        this._extendedRtpCapabilities = undefined;\r\n        this._recvRtpCapabilities = undefined;\r\n        this._canProduceByKind =\r\n            {\r\n                audio: false,\r\n                video: false\r\n            };\r\n        this._sctpCapabilities = undefined;\r\n    }\r\n    get handlerName() {\r\n        return this._handlerName;\r\n    }\r\n    get loaded() {\r\n        return this._loaded;\r\n    }\r\n    get rtpCapabilities() {\r\n        if (!this._loaded)\r\n            throw new errors_1.InvalidStateError('not loaded');\r\n        return this._recvRtpCapabilities;\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const handler = this._handlerFactory();\r\n            return yield handler.getNativeRtpCapabilities();\r\n        });\r\n    }\r\n    get sctpCapabilities() {\r\n        if (!this._loaded)\r\n            throw new errors_1.InvalidStateError('not loaded');\r\n        return this._sctpCapabilities;\r\n    }\r\n    load({ routerRtpCapabilities }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);\r\n            let handler;\r\n            try {\r\n                if (this._loaded)\r\n                    throw new errors_1.InvalidStateError('already loaded');\r\n                ortc.validateRtpCapabilities(routerRtpCapabilities);\r\n                handler = this._handlerFactory();\r\n                const nativeRtpCapabilities = yield handler.getNativeRtpCapabilities();\r\n                logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);\r\n                ortc.validateRtpCapabilities(nativeRtpCapabilities);\r\n                this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);\r\n                logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);\r\n                this._canProduceByKind.audio =\r\n                    ortc.canSend('audio', this._extendedRtpCapabilities);\r\n                this._canProduceByKind.video =\r\n                    ortc.canSend('video', this._extendedRtpCapabilities);\r\n                this._recvRtpCapabilities =\r\n                    ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);\r\n                ortc.validateRtpCapabilities(this._recvRtpCapabilities);\r\n                logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);\r\n                this._sctpCapabilities = yield handler.getNativeSctpCapabilities();\r\n                logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);\r\n                ortc.validateSctpCapabilities(this._sctpCapabilities);\r\n                logger.debug('load() succeeded');\r\n                this._loaded = true;\r\n                handler.close();\r\n            }\r\n            catch (error) {\r\n                if (handler)\r\n                    handler.close();\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    canProduce(kind) {\r\n        if (!this._loaded)\r\n            throw new errors_1.InvalidStateError('not loaded');\r\n        else if (kind !== 'audio' && kind !== 'video')\r\n            throw new TypeError(`invalid kind \"${kind}\"`);\r\n        return this._canProduceByKind[kind];\r\n    }\r\n    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\r\n        logger.debug('createSendTransport()');\r\n        return this._createTransport({\r\n            direction: 'send',\r\n            id: id,\r\n            iceParameters: iceParameters,\r\n            iceCandidates: iceCandidates,\r\n            dtlsParameters: dtlsParameters,\r\n            sctpParameters: sctpParameters,\r\n            iceServers: iceServers,\r\n            iceTransportPolicy: iceTransportPolicy,\r\n            additionalSettings: additionalSettings,\r\n            proprietaryConstraints: proprietaryConstraints,\r\n            appData: appData\r\n        });\r\n    }\r\n    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\r\n        logger.debug('createRecvTransport()');\r\n        return this._createTransport({\r\n            direction: 'recv',\r\n            id: id,\r\n            iceParameters: iceParameters,\r\n            iceCandidates: iceCandidates,\r\n            dtlsParameters: dtlsParameters,\r\n            sctpParameters: sctpParameters,\r\n            iceServers: iceServers,\r\n            iceTransportPolicy: iceTransportPolicy,\r\n            additionalSettings: additionalSettings,\r\n            proprietaryConstraints: proprietaryConstraints,\r\n            appData: appData\r\n        });\r\n    }\r\n    _createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {\r\n        if (!this._loaded)\r\n            throw new errors_1.InvalidStateError('not loaded');\r\n        else if (typeof id !== 'string')\r\n            throw new TypeError('missing id');\r\n        else if (typeof iceParameters !== 'object')\r\n            throw new TypeError('missing iceParameters');\r\n        else if (!Array.isArray(iceCandidates))\r\n            throw new TypeError('missing iceCandidates');\r\n        else if (typeof dtlsParameters !== 'object')\r\n            throw new TypeError('missing dtlsParameters');\r\n        else if (sctpParameters && typeof sctpParameters !== 'object')\r\n            throw new TypeError('wrong sctpParameters');\r\n        else if (appData && typeof appData !== 'object')\r\n            throw new TypeError('if given, appData must be an object');\r\n        const transport = new Transport_1.Transport({\r\n            direction,\r\n            id,\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            iceServers,\r\n            iceTransportPolicy,\r\n            additionalSettings,\r\n            proprietaryConstraints,\r\n            appData,\r\n            handlerFactory: this._handlerFactory,\r\n            extendedRtpCapabilities: this._extendedRtpCapabilities,\r\n            canProduceByKind: this._canProduceByKind\r\n        });\r\n        return transport;\r\n    }\r\n}\r\nexports.Device = Device;\r\n\n\n//# sourceURL=webpack:///./src/Device.ts?");

/***/ }),

/***/ "./src/EnhancedEventEmitter.ts":
/*!*************************************!*\
  !*** ./src/EnhancedEventEmitter.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst logger = new Logger_1.Logger('EnhancedEventEmitter');\r\nclass EnhancedEventEmitter extends events_1.EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this.setMaxListeners(Infinity);\r\n    }\r\n    safeEmit(event, ...args) {\r\n        const numListeners = this.listenerCount(event);\r\n        try {\r\n            return this.emit(event, ...args);\r\n        }\r\n        catch (error) {\r\n            logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);\r\n            return Boolean(numListeners);\r\n        }\r\n    }\r\n    safeEmitAsPromise(event, ...args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return new Promise((resolve, reject) => (this.safeEmit(event, ...args, resolve, reject)));\r\n        });\r\n    }\r\n}\r\nexports.EnhancedEventEmitter = EnhancedEventEmitter;\r\n\n\n//# sourceURL=webpack:///./src/EnhancedEventEmitter.ts?");

/***/ }),

/***/ "./src/Logger.ts":
/*!***********************!*\
  !*** ./src/Logger.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\"));\r\nconst APP_NAME = 'mediasoup-client';\r\nclass Logger {\r\n    constructor(prefix) {\r\n        if (prefix) {\r\n            this._debug = debug_1.default(`${APP_NAME}:${prefix}`);\r\n            this._warn = debug_1.default(`${APP_NAME}:WARN:${prefix}`);\r\n            this._error = debug_1.default(`${APP_NAME}:ERROR:${prefix}`);\r\n        }\r\n        else {\r\n            this._debug = debug_1.default(APP_NAME);\r\n            this._warn = debug_1.default(`${APP_NAME}:WARN`);\r\n            this._error = debug_1.default(`${APP_NAME}:ERROR`);\r\n        }\r\n        this._debug.log = console.info.bind(console);\r\n        this._warn.log = console.warn.bind(console);\r\n        this._error.log = console.error.bind(console);\r\n    }\r\n    get debug() {\r\n        return this._debug;\r\n    }\r\n    get warn() {\r\n        return this._warn;\r\n    }\r\n    get error() {\r\n        return this._error;\r\n    }\r\n}\r\nexports.Logger = Logger;\r\n\n\n//# sourceURL=webpack:///./src/Logger.ts?");

/***/ }),

/***/ "./src/Producer.ts":
/*!*************************!*\
  !*** ./src/Producer.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst logger = new Logger_1.Logger('Producer');\r\nclass Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {\r\n        super();\r\n        this._closed = false;\r\n        logger.debug('constructor()');\r\n        this._id = id;\r\n        this._localId = localId;\r\n        this._rtpSender = rtpSender;\r\n        this._track = track;\r\n        this._kind = track.kind;\r\n        this._rtpParameters = rtpParameters;\r\n        this._paused = disableTrackOnPause ? !track.enabled : false;\r\n        this._maxSpatialLayer = undefined;\r\n        this._stopTracks = stopTracks;\r\n        this._disableTrackOnPause = disableTrackOnPause;\r\n        this._zeroRtpOnPause = zeroRtpOnPause;\r\n        this._appData = appData;\r\n        this._onTrackEnded = this._onTrackEnded.bind(this);\r\n        this._handleTrack();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get localId() {\r\n        return this._localId;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get kind() {\r\n        return this._kind;\r\n    }\r\n    get rtpSender() {\r\n        return this._rtpSender;\r\n    }\r\n    get track() {\r\n        return this._track;\r\n    }\r\n    get rtpParameters() {\r\n        return this._rtpParameters;\r\n    }\r\n    get paused() {\r\n        return this._paused;\r\n    }\r\n    get maxSpatialLayer() {\r\n        return this._maxSpatialLayer;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._destroyTrack();\r\n        this.emit('@close');\r\n    }\r\n    transportClosed() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('transportClosed()');\r\n        this._closed = true;\r\n        this._destroyTrack();\r\n        this.safeEmit('transportclose');\r\n    }\r\n    getStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            return this.safeEmitAsPromise('@getstats');\r\n        });\r\n    }\r\n    pause() {\r\n        logger.debug('pause()');\r\n        if (this._closed) {\r\n            logger.error('pause() | Producer closed');\r\n            return;\r\n        }\r\n        this._paused = true;\r\n        if (this._track && this._disableTrackOnPause) {\r\n            this._track.enabled = false;\r\n        }\r\n        if (this._zeroRtpOnPause) {\r\n            this.safeEmitAsPromise('@replacetrack', null)\r\n                .catch(() => { });\r\n        }\r\n    }\r\n    resume() {\r\n        logger.debug('resume()');\r\n        if (this._closed) {\r\n            logger.error('resume() | Producer closed');\r\n            return;\r\n        }\r\n        this._paused = false;\r\n        if (this._track && this._disableTrackOnPause) {\r\n            this._track.enabled = true;\r\n        }\r\n        if (this._zeroRtpOnPause) {\r\n            this.safeEmitAsPromise('@replacetrack', this._track)\r\n                .catch(() => { });\r\n        }\r\n    }\r\n    replaceTrack({ track }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('replaceTrack() [track:%o]', track);\r\n            if (this._closed) {\r\n                if (track && this._stopTracks) {\r\n                    try {\r\n                        track.stop();\r\n                    }\r\n                    catch (error) { }\r\n                }\r\n                throw new errors_1.InvalidStateError('closed');\r\n            }\r\n            else if (track && track.readyState === 'ended') {\r\n                throw new errors_1.InvalidStateError('track ended');\r\n            }\r\n            if (track === this._track) {\r\n                logger.debug('replaceTrack() | same track, ignored');\r\n                return;\r\n            }\r\n            if (!this._zeroRtpOnPause || !this._paused) {\r\n                yield this.safeEmitAsPromise('@replacetrack', track);\r\n            }\r\n            this._destroyTrack();\r\n            this._track = track;\r\n            if (this._track && this._disableTrackOnPause) {\r\n                if (!this._paused)\r\n                    this._track.enabled = true;\r\n                else if (this._paused)\r\n                    this._track.enabled = false;\r\n            }\r\n            this._handleTrack();\r\n        });\r\n    }\r\n    setMaxSpatialLayer(spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (this._kind !== 'video')\r\n                throw new errors_1.UnsupportedError('not a video Producer');\r\n            else if (typeof spatialLayer !== 'number')\r\n                throw new TypeError('invalid spatialLayer');\r\n            if (spatialLayer === this._maxSpatialLayer)\r\n                return;\r\n            yield this.safeEmitAsPromise('@setmaxspatiallayer', spatialLayer);\r\n            this._maxSpatialLayer = spatialLayer;\r\n        });\r\n    }\r\n    setRtpEncodingParameters(params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (typeof params !== 'object')\r\n                throw new TypeError('invalid params');\r\n            yield this.safeEmitAsPromise('@setrtpencodingparameters', params);\r\n        });\r\n    }\r\n    _onTrackEnded() {\r\n        logger.debug('track \"ended\" event');\r\n        this.safeEmit('trackended');\r\n    }\r\n    _handleTrack() {\r\n        if (!this._track)\r\n            return;\r\n        this._track.addEventListener('ended', this._onTrackEnded);\r\n    }\r\n    _destroyTrack() {\r\n        if (!this._track)\r\n            return;\r\n        try {\r\n            this._track.removeEventListener('ended', this._onTrackEnded);\r\n            if (this._stopTracks)\r\n                this._track.stop();\r\n        }\r\n        catch (error) { }\r\n    }\r\n}\r\nexports.Producer = Producer;\r\n\n\n//# sourceURL=webpack:///./src/Producer.ts?");

/***/ }),

/***/ "./src/Transport.ts":
/*!**************************!*\
  !*** ./src/Transport.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst awaitqueue_1 = __webpack_require__(/*! awaitqueue */ \"./node_modules/awaitqueue/lib/index.js\");\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nconst errors_1 = __webpack_require__(/*! ./errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ./utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ./ortc */ \"./src/ortc.ts\"));\r\nconst Producer_1 = __webpack_require__(/*! ./Producer */ \"./src/Producer.ts\");\r\nconst Consumer_1 = __webpack_require__(/*! ./Consumer */ \"./src/Consumer.ts\");\r\nconst DataProducer_1 = __webpack_require__(/*! ./DataProducer */ \"./src/DataProducer.ts\");\r\nconst DataConsumer_1 = __webpack_require__(/*! ./DataConsumer */ \"./src/DataConsumer.ts\");\r\nconst logger = new Logger_1.Logger('Transport');\r\nclass Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {\r\n        super();\r\n        this._closed = false;\r\n        this._connectionState = 'new';\r\n        this._producers = new Map();\r\n        this._consumers = new Map();\r\n        this._dataProducers = new Map();\r\n        this._dataConsumers = new Map();\r\n        this._probatorConsumerCreated = false;\r\n        this._awaitQueue = new awaitqueue_1.AwaitQueue({ ClosedErrorClass: errors_1.InvalidStateError });\r\n        logger.debug('constructor() [id:%s, direction:%s]', id, direction);\r\n        this._id = id;\r\n        this._direction = direction;\r\n        this._extendedRtpCapabilities = extendedRtpCapabilities;\r\n        this._canProduceByKind = canProduceByKind;\r\n        this._maxSctpMessageSize =\r\n            sctpParameters ? sctpParameters.maxMessageSize : null;\r\n        additionalSettings = utils.clone(additionalSettings);\r\n        delete additionalSettings.iceServers;\r\n        delete additionalSettings.iceTransportPolicy;\r\n        delete additionalSettings.bundlePolicy;\r\n        delete additionalSettings.rtcpMuxPolicy;\r\n        delete additionalSettings.sdpSemantics;\r\n        this._handler = handlerFactory();\r\n        this._handler.run({\r\n            direction,\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            iceServers,\r\n            iceTransportPolicy,\r\n            additionalSettings,\r\n            proprietaryConstraints,\r\n            extendedRtpCapabilities\r\n        });\r\n        this._appData = appData;\r\n        this._handleHandler();\r\n    }\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    get closed() {\r\n        return this._closed;\r\n    }\r\n    get direction() {\r\n        return this._direction;\r\n    }\r\n    get handler() {\r\n        return this._handler;\r\n    }\r\n    get connectionState() {\r\n        return this._connectionState;\r\n    }\r\n    get appData() {\r\n        return this._appData;\r\n    }\r\n    set appData(appData) {\r\n        throw new Error('cannot override appData object');\r\n    }\r\n    close() {\r\n        if (this._closed)\r\n            return;\r\n        logger.debug('close()');\r\n        this._closed = true;\r\n        this._awaitQueue.close();\r\n        this._handler.close();\r\n        for (const producer of this._producers.values()) {\r\n            producer.transportClosed();\r\n        }\r\n        this._producers.clear();\r\n        for (const consumer of this._consumers.values()) {\r\n            consumer.transportClosed();\r\n        }\r\n        this._consumers.clear();\r\n        for (const dataProducer of this._dataProducers.values()) {\r\n            dataProducer.transportClosed();\r\n        }\r\n        this._dataProducers.clear();\r\n        for (const dataConsumer of this._dataConsumers.values()) {\r\n            dataConsumer.transportClosed();\r\n        }\r\n        this._dataConsumers.clear();\r\n    }\r\n    getStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            return this._handler.getTransportStats();\r\n        });\r\n    }\r\n    restartIce({ iceParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (!iceParameters)\r\n                throw new TypeError('missing iceParameters');\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.restartIce(iceParameters); }));\r\n        });\r\n    }\r\n    updateIceServers({ iceServers } = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (!Array.isArray(iceServers))\r\n                throw new TypeError('missing iceServers');\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.updateIceServers(iceServers); }));\r\n        });\r\n    }\r\n    produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('produce() [track:%o]', track);\r\n            if (!track)\r\n                throw new TypeError('missing track');\r\n            else if (this._direction !== 'send')\r\n                throw new errors_1.UnsupportedError('not a sending Transport');\r\n            else if (!this._canProduceByKind[track.kind])\r\n                throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);\r\n            else if (track.readyState === 'ended')\r\n                throw new errors_1.InvalidStateError('track ended');\r\n            else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\r\n                throw new TypeError('no \"connect\" listener set into this transport');\r\n            else if (this.listenerCount('produce') === 0)\r\n                throw new TypeError('no \"produce\" listener set into this transport');\r\n            else if (appData && typeof appData !== 'object')\r\n                throw new TypeError('if given, appData must be an object');\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                let normalizedEncodings;\r\n                if (encodings && !Array.isArray(encodings)) {\r\n                    throw TypeError('encodings must be an array');\r\n                }\r\n                else if (encodings && encodings.length === 0) {\r\n                    normalizedEncodings = undefined;\r\n                }\r\n                else if (encodings) {\r\n                    normalizedEncodings = encodings\r\n                        .map((encoding) => {\r\n                        const normalizedEncoding = { active: true };\r\n                        if (encoding.active === false)\r\n                            normalizedEncoding.active = false;\r\n                        if (typeof encoding.dtx === 'boolean')\r\n                            normalizedEncoding.dtx = encoding.dtx;\r\n                        if (typeof encoding.scalabilityMode === 'string')\r\n                            normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\r\n                        if (typeof encoding.scaleResolutionDownBy === 'number')\r\n                            normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\r\n                        if (typeof encoding.maxBitrate === 'number')\r\n                            normalizedEncoding.maxBitrate = encoding.maxBitrate;\r\n                        if (typeof encoding.maxFramerate === 'number')\r\n                            normalizedEncoding.maxFramerate = encoding.maxFramerate;\r\n                        if (typeof encoding.adaptivePtime === 'boolean')\r\n                            normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\r\n                        if (typeof encoding.priority === 'string')\r\n                            normalizedEncoding.priority = encoding.priority;\r\n                        if (typeof encoding.networkPriority === 'string')\r\n                            normalizedEncoding.networkPriority = encoding.networkPriority;\r\n                        return normalizedEncoding;\r\n                    });\r\n                }\r\n                const { localId, rtpParameters, rtpSender } = yield this._handler.send({\r\n                    track,\r\n                    encodings: normalizedEncodings,\r\n                    codecOptions,\r\n                    codec\r\n                });\r\n                try {\r\n                    ortc.validateRtpParameters(rtpParameters);\r\n                    const { id } = yield this.safeEmitAsPromise('produce', {\r\n                        kind: track.kind,\r\n                        rtpParameters,\r\n                        appData\r\n                    });\r\n                    const producer = new Producer_1.Producer({\r\n                        id,\r\n                        localId,\r\n                        rtpSender,\r\n                        track,\r\n                        rtpParameters,\r\n                        stopTracks,\r\n                        disableTrackOnPause,\r\n                        zeroRtpOnPause,\r\n                        appData\r\n                    });\r\n                    this._producers.set(producer.id, producer);\r\n                    this._handleProducer(producer);\r\n                    return producer;\r\n                }\r\n                catch (error) {\r\n                    this._handler.stopSending(localId)\r\n                        .catch(() => { });\r\n                    throw error;\r\n                }\r\n            }))\r\n                .catch((error) => {\r\n                if (stopTracks) {\r\n                    try {\r\n                        track.stop();\r\n                    }\r\n                    catch (error2) { }\r\n                }\r\n                throw error;\r\n            });\r\n        });\r\n    }\r\n    consume({ id, producerId, kind, rtpParameters, appData = {} }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('consume()');\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (this._direction !== 'recv')\r\n                throw new errors_1.UnsupportedError('not a receiving Transport');\r\n            else if (typeof id !== 'string')\r\n                throw new TypeError('missing id');\r\n            else if (typeof producerId !== 'string')\r\n                throw new TypeError('missing producerId');\r\n            else if (kind !== 'audio' && kind !== 'video')\r\n                throw new TypeError(`invalid kind '${kind}'`);\r\n            else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\r\n                throw new TypeError('no \"connect\" listener set into this transport');\r\n            else if (appData && typeof appData !== 'object')\r\n                throw new TypeError('if given, appData must be an object');\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                const { localId, rtpReceiver, track } = yield this._handler.receive({ trackId: id, kind, rtpParameters });\r\n                const consumer = new Consumer_1.Consumer({\r\n                    id,\r\n                    localId,\r\n                    producerId,\r\n                    rtpReceiver,\r\n                    track,\r\n                    rtpParameters,\r\n                    appData\r\n                });\r\n                this._consumers.set(consumer.id, consumer);\r\n                this._handleConsumer(consumer);\r\n                if (!this._probatorConsumerCreated && kind === 'video') {\r\n                    try {\r\n                        const probatorRtpParameters = ortc.generateProbatorRtpParameters(consumer.rtpParameters);\r\n                        yield this._handler.receive({\r\n                            trackId: 'probator',\r\n                            kind: 'video',\r\n                            rtpParameters: probatorRtpParameters\r\n                        });\r\n                        logger.debug('consume() | Consumer for RTP probation created');\r\n                        this._probatorConsumerCreated = true;\r\n                    }\r\n                    catch (error) {\r\n                        logger.error('consume() | failed to create Consumer for RTP probation:%o', error);\r\n                    }\r\n                }\r\n                return consumer;\r\n            }));\r\n        });\r\n    }\r\n    produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, priority = 'low', label = '', protocol = '', appData = {} } = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('produceData()');\r\n            if (this._direction !== 'send')\r\n                throw new errors_1.UnsupportedError('not a sending Transport');\r\n            else if (!this._maxSctpMessageSize)\r\n                throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\r\n            else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\r\n                throw new TypeError('no \"connect\" listener set into this transport');\r\n            else if (this.listenerCount('producedata') === 0)\r\n                throw new TypeError('no \"producedata\" listener set into this transport');\r\n            else if (appData && typeof appData !== 'object')\r\n                throw new TypeError('if given, appData must be an object');\r\n            if (maxPacketLifeTime || maxRetransmits)\r\n                ordered = false;\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                const { dataChannel, sctpStreamParameters } = yield this._handler.sendDataChannel({\r\n                    ordered,\r\n                    maxPacketLifeTime,\r\n                    maxRetransmits,\r\n                    priority,\r\n                    label,\r\n                    protocol\r\n                });\r\n                ortc.validateSctpStreamParameters(sctpStreamParameters);\r\n                const { id } = yield this.safeEmitAsPromise('producedata', {\r\n                    sctpStreamParameters,\r\n                    label,\r\n                    protocol,\r\n                    appData\r\n                });\r\n                const dataProducer = new DataProducer_1.DataProducer({ id, dataChannel, sctpStreamParameters, appData });\r\n                this._dataProducers.set(dataProducer.id, dataProducer);\r\n                this._handleDataProducer(dataProducer);\r\n                return dataProducer;\r\n            }));\r\n        });\r\n    }\r\n    consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {} }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('consumeData()');\r\n            if (this._closed)\r\n                throw new errors_1.InvalidStateError('closed');\r\n            else if (this._direction !== 'recv')\r\n                throw new errors_1.UnsupportedError('not a receiving Transport');\r\n            else if (!this._maxSctpMessageSize)\r\n                throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\r\n            else if (typeof id !== 'string')\r\n                throw new TypeError('missing id');\r\n            else if (typeof dataProducerId !== 'string')\r\n                throw new TypeError('missing dataProducerId');\r\n            else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\r\n                throw new TypeError('no \"connect\" listener set into this transport');\r\n            else if (appData && typeof appData !== 'object')\r\n                throw new TypeError('if given, appData must be an object');\r\n            ortc.validateSctpStreamParameters(sctpStreamParameters);\r\n            return this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                const { dataChannel } = yield this._handler.receiveDataChannel({\r\n                    sctpStreamParameters,\r\n                    label,\r\n                    protocol\r\n                });\r\n                const dataConsumer = new DataConsumer_1.DataConsumer({\r\n                    id,\r\n                    dataProducerId,\r\n                    dataChannel,\r\n                    sctpStreamParameters,\r\n                    appData\r\n                });\r\n                this._dataConsumers.set(dataConsumer.id, dataConsumer);\r\n                this._handleDataConsumer(dataConsumer);\r\n                return dataConsumer;\r\n            }));\r\n        });\r\n    }\r\n    _handleHandler() {\r\n        const handler = this._handler;\r\n        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {\r\n            if (this._closed) {\r\n                errback(new errors_1.InvalidStateError('closed'));\r\n                return;\r\n            }\r\n            this.safeEmit('connect', { dtlsParameters }, callback, errback);\r\n        });\r\n        handler.on('@connectionstatechange', (connectionState) => {\r\n            if (connectionState === this._connectionState)\r\n                return;\r\n            logger.debug('connection state changed to %s', connectionState);\r\n            this._connectionState = connectionState;\r\n            if (!this._closed)\r\n                this.safeEmit('connectionstatechange', connectionState);\r\n        });\r\n    }\r\n    _handleProducer(producer) {\r\n        producer.on('@close', () => {\r\n            this._producers.delete(producer.id);\r\n            if (this._closed)\r\n                return;\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.stopSending(producer.localId); }))\r\n                .catch((error) => logger.warn('producer.close() failed:%o', error));\r\n        });\r\n        producer.on('@replacetrack', (track, callback, errback) => {\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.replaceTrack(producer.localId, track); }))\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                return (this._handler.setMaxSpatialLayer(producer.localId, spatialLayer));\r\n            }))\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n        producer.on('@setrtpencodingparameters', (params, callback, errback) => {\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () {\r\n                return (this._handler.setRtpEncodingParameters(producer.localId, params));\r\n            }))\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n        producer.on('@getstats', (callback, errback) => {\r\n            if (this._closed)\r\n                return errback(new errors_1.InvalidStateError('closed'));\r\n            this._handler.getSenderStats(producer.localId)\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n    }\r\n    _handleConsumer(consumer) {\r\n        consumer.on('@close', () => {\r\n            this._consumers.delete(consumer.id);\r\n            if (this._closed)\r\n                return;\r\n            this._awaitQueue.push(() => __awaiter(this, void 0, void 0, function* () { return this._handler.stopReceiving(consumer.localId); }))\r\n                .catch(() => { });\r\n        });\r\n        consumer.on('@getstats', (callback, errback) => {\r\n            if (this._closed)\r\n                return errback(new errors_1.InvalidStateError('closed'));\r\n            this._handler.getReceiverStats(consumer.localId)\r\n                .then(callback)\r\n                .catch(errback);\r\n        });\r\n    }\r\n    _handleDataProducer(dataProducer) {\r\n        dataProducer.on('@close', () => {\r\n            this._dataProducers.delete(dataProducer.id);\r\n        });\r\n    }\r\n    _handleDataConsumer(dataConsumer) {\r\n        dataConsumer.on('@close', () => {\r\n            this._dataConsumers.delete(dataConsumer.id);\r\n        });\r\n    }\r\n}\r\nexports.Transport = Transport;\r\n\n\n//# sourceURL=webpack:///./src/Transport.ts?");

/***/ }),

/***/ "./src/errors.ts":
/*!***********************!*\
  !*** ./src/errors.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass UnsupportedError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'UnsupportedError';\r\n        if (Error.hasOwnProperty('captureStackTrace')) {\r\n            Error.captureStackTrace(this, UnsupportedError);\r\n        }\r\n        else {\r\n            this.stack = (new Error(message)).stack;\r\n        }\r\n    }\r\n}\r\nexports.UnsupportedError = UnsupportedError;\r\nclass InvalidStateError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'InvalidStateError';\r\n        if (Error.hasOwnProperty('captureStackTrace')) {\r\n            Error.captureStackTrace(this, InvalidStateError);\r\n        }\r\n        else {\r\n            this.stack = (new Error(message)).stack;\r\n        }\r\n    }\r\n}\r\nexports.InvalidStateError = InvalidStateError;\r\n\n\n//# sourceURL=webpack:///./src/errors.ts?");

/***/ }),

/***/ "./src/handlers/Chrome55.ts":
/*!**********************************!*\
  !*** ./src/handlers/Chrome55.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"./src/handlers/sdp/planBUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Chrome55');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Chrome55 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._sendStream = new MediaStream();\r\n        this._mapSendLocalIdTrack = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._mapRecvLocalIdInfo = new Map();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Chrome55();\r\n    }\r\n    get name() {\r\n        return 'Chrome55';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'plan-b'\r\n            });\r\n            try {\r\n                const offer = yield pc.createOffer({\r\n                    offerToReceiveAudio: true,\r\n                    offerToReceiveVideo: true\r\n                });\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            planB: true\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (codec) {\r\n                logger.warn('send() | codec selection is not available in %s handler', this.name);\r\n            }\r\n            this._sendStream.addTrack(track);\r\n            this._pc.addStream(this._sendStream);\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (track.kind === 'video' && encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\r\n                sdpPlanBUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    track,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media\r\n                .find((m) => m.type === track.kind);\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            this._mapSendLocalIdTrack.set(localId, track);\r\n            return {\r\n                localId: localId,\r\n                rtpParameters: sendingRtpParameters\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const track = this._mapSendLocalIdTrack.get(localId);\r\n            if (!track)\r\n                throw new Error('track not found');\r\n            this._mapSendLocalIdTrack.delete(localId);\r\n            this._sendStream.removeTrack(track);\r\n            this._pc.addStream(this._sendStream);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            try {\r\n                yield this._pc.setLocalDescription(offer);\r\n            }\r\n            catch (error) {\r\n                if (this._sendStream.getTracks().length === 0) {\r\n                    logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n            if (this._pc.signalingState === 'stable')\r\n                return;\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError(' not implemented');\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not supported');\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = trackId;\r\n            const mid = kind;\r\n            const streamId = rtpParameters.rtcp.cname;\r\n            this._remoteSdp.receive({\r\n                mid,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === mid);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const stream = this._pc.getRemoteStreams()\r\n                .find((s) => s.id === streamId);\r\n            const track = stream.getTrackById(localId);\r\n            if (!track)\r\n                throw new Error('remote track not found');\r\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\r\n            return { localId, track };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            this._mapRecvLocalIdInfo.delete(localId);\r\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Chrome55 = Chrome55;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Chrome55.ts?");

/***/ }),

/***/ "./src/handlers/Chrome67.ts":
/*!**********************************!*\
  !*** ./src/handlers/Chrome67.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"./src/handlers/sdp/planBUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Chrome67');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Chrome67 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._sendStream = new MediaStream();\r\n        this._mapSendLocalIdRtpSender = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._mapRecvLocalIdInfo = new Map();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Chrome67();\r\n    }\r\n    get name() {\r\n        return 'Chrome67';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'plan-b'\r\n            });\r\n            try {\r\n                const offer = yield pc.createOffer({\r\n                    offerToReceiveAudio: true,\r\n                    offerToReceiveVideo: true\r\n                });\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            planB: true\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (codec) {\r\n                logger.warn('send() | codec selection is not available in %s handler', this.name);\r\n            }\r\n            this._sendStream.addTrack(track);\r\n            this._pc.addTrack(track, this._sendStream);\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (track.kind === 'video' && encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'video');\r\n                sdpPlanBUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    track,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media\r\n                .find((m) => m.type === track.kind);\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            const rtpSender = this._pc.getSenders()\r\n                .find((s) => s.track === track);\r\n            this._mapSendLocalIdRtpSender.set(localId, rtpSender);\r\n            return {\r\n                localId: localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            this._pc.removeTrack(rtpSender);\r\n            if (rtpSender.track)\r\n                this._sendStream.removeTrack(rtpSender.track);\r\n            this._mapSendLocalIdRtpSender.delete(localId);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            try {\r\n                yield this._pc.setLocalDescription(offer);\r\n            }\r\n            catch (error) {\r\n                if (this._sendStream.getTracks().length === 0) {\r\n                    logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n            if (this._pc.signalingState === 'stable')\r\n                return;\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const oldTrack = rtpSender.track;\r\n            yield rtpSender.replaceTrack(track);\r\n            if (oldTrack)\r\n                this._sendStream.removeTrack(oldTrack);\r\n            if (track)\r\n                this._sendStream.addTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            return rtpSender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = trackId;\r\n            const mid = kind;\r\n            this._remoteSdp.receive({\r\n                mid,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === mid);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const rtpReceiver = this._pc.getReceivers()\r\n                .find((r) => r.track && r.track.id === localId);\r\n            if (!rtpReceiver)\r\n                throw new Error('new RTCRtpReceiver not');\r\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });\r\n            return {\r\n                localId,\r\n                track: rtpReceiver.track,\r\n                rtpReceiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            this._mapRecvLocalIdInfo.delete(localId);\r\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            if (!rtpReceiver)\r\n                throw new Error('associated RTCRtpReceiver not found');\r\n            return rtpReceiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Chrome67 = Chrome67;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Chrome67.ts?");

/***/ }),

/***/ "./src/handlers/Chrome70.ts":
/*!**********************************!*\
  !*** ./src/handlers/Chrome70.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./src/handlers/sdp/unifiedPlanUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"./src/scalabilityModes.ts\");\r\nconst logger = new Logger_1.Logger('Chrome70');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Chrome70 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._mapMidTransceiver = new Map();\r\n        this._sendStream = new MediaStream();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Chrome70();\r\n    }\r\n    get name() {\r\n        return 'Chrome70';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'unified-plan'\r\n            });\r\n            try {\r\n                pc.addTransceiver('audio');\r\n                pc.addTransceiver('video');\r\n                const offer = yield pc.createOffer();\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\r\n            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\r\n            const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling legacy simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n                sdpUnifiedPlanUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            let hackVp9Svc = false;\r\n            const layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);\r\n            if (encodings &&\r\n                encodings.length === 1 &&\r\n                layers.spatialLayers > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\r\n                logger.debug('send() | enabling legacy simulcast for VP9 SVC');\r\n                hackVp9Svc = true;\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n                sdpUnifiedPlanUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    numStreams: layers.spatialLayers\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            if (encodings) {\r\n                logger.debug('send() | applying given encodings');\r\n                const parameters = transceiver.sender.getParameters();\r\n                for (let idx = 0; idx < (parameters.encodings || []).length; ++idx) {\r\n                    const encoding = parameters.encodings[idx];\r\n                    const desiredEncoding = encodings[idx];\r\n                    if (!desiredEncoding)\r\n                        break;\r\n                    parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);\r\n                }\r\n                yield transceiver.sender.setParameters(parameters);\r\n            }\r\n            const localId = transceiver.mid;\r\n            sendingRtpParameters.mid = localId;\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (hackVp9Svc) {\r\n                sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                reuseMid: mediaSectionIdx.reuseMid,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender: transceiver.sender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            transceiver.sender.replaceTrack(null);\r\n            this._pc.removeTrack(transceiver.sender);\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            yield transceiver.sender.replaceTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.sender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\r\n            this._remoteSdp.receive({\r\n                mid: localId,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === localId);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const transceiver = this._pc.getTransceivers()\r\n                .find((t) => t.mid === localId);\r\n            if (!transceiver)\r\n                throw new Error('new RTCRtpTransceiver not found');\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                track: transceiver.receiver.track,\r\n                rtpReceiver: transceiver.receiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.receiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation();\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Chrome70 = Chrome70;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Chrome70.ts?");

/***/ }),

/***/ "./src/handlers/Chrome74.ts":
/*!**********************************!*\
  !*** ./src/handlers/Chrome74.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./src/handlers/sdp/unifiedPlanUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst scalabilityModes_1 = __webpack_require__(/*! ../scalabilityModes */ \"./src/scalabilityModes.ts\");\r\nconst logger = new Logger_1.Logger('Chrome74');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Chrome74 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._mapMidTransceiver = new Map();\r\n        this._sendStream = new MediaStream();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Chrome74();\r\n    }\r\n    get name() {\r\n        return 'Chrome74';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'unified-plan'\r\n            });\r\n            try {\r\n                pc.addTransceiver('audio');\r\n                pc.addTransceiver('video');\r\n                const offer = yield pc.createOffer();\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (encodings && encodings.length > 1) {\r\n                encodings.forEach((encoding, idx) => {\r\n                    encoding.rid = `r${idx}`;\r\n                });\r\n            }\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\r\n            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\r\n            const transceiver = this._pc.addTransceiver(track, {\r\n                direction: 'sendonly',\r\n                streams: [this._sendStream],\r\n                sendEncodings: encodings\r\n            });\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            let hackVp9Svc = false;\r\n            const layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);\r\n            if (encodings &&\r\n                encodings.length === 1 &&\r\n                layers.spatialLayers > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {\r\n                logger.debug('send() | enabling legacy simulcast for VP9 SVC');\r\n                hackVp9Svc = true;\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n                sdpUnifiedPlanUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    numStreams: layers.spatialLayers\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const localId = transceiver.mid;\r\n            sendingRtpParameters.mid = localId;\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            if (!encodings) {\r\n                sendingRtpParameters.encodings =\r\n                    sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n            }\r\n            else if (encodings.length === 1) {\r\n                let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n                Object.assign(newEncodings[0], encodings[0]);\r\n                if (hackVp9Svc)\r\n                    newEncodings = [newEncodings[0]];\r\n                sendingRtpParameters.encodings = newEncodings;\r\n            }\r\n            else {\r\n                sendingRtpParameters.encodings = encodings;\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                reuseMid: mediaSectionIdx.reuseMid,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions,\r\n                extmapAllowMixed: true\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender: transceiver.sender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            transceiver.sender.replaceTrack(null);\r\n            this._pc.removeTrack(transceiver.sender);\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            yield transceiver.sender.replaceTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.sender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\r\n            this._remoteSdp.receive({\r\n                mid: localId,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === localId);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const transceiver = this._pc.getTransceivers()\r\n                .find((t) => t.mid === localId);\r\n            if (!transceiver)\r\n                throw new Error('new RTCRtpTransceiver not found');\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                track: transceiver.receiver.track,\r\n                rtpReceiver: transceiver.receiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.receiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation();\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Chrome74 = Chrome74;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Chrome74.ts?");

/***/ }),

/***/ "./src/handlers/Edge11.ts":
/*!********************************!*\
  !*** ./src/handlers/Edge11.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst edgeUtils = __importStar(__webpack_require__(/*! ./ortc/edgeUtils */ \"./src/handlers/ortc/edgeUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst logger = new Logger_1.Logger('Edge11');\r\nclass Edge11 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._rtpSenders = new Map();\r\n        this._rtpReceivers = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Edge11();\r\n    }\r\n    get name() {\r\n        return 'Edge11';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        try {\r\n            this._iceGatherer.close();\r\n        }\r\n        catch (error) { }\r\n        try {\r\n            this._iceTransport.stop();\r\n        }\r\n        catch (error) { }\r\n        try {\r\n            this._dtlsTransport.stop();\r\n        }\r\n        catch (error) { }\r\n        for (const rtpSender of this._rtpSenders.values()) {\r\n            try {\r\n                rtpSender.stop();\r\n            }\r\n            catch (error) { }\r\n        }\r\n        for (const rtpReceiver of this._rtpReceivers.values()) {\r\n            try {\r\n                rtpReceiver.stop();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            return edgeUtils.getCapabilities();\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: { OS: 0, MIS: 0 }\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._remoteIceParameters = iceParameters;\r\n        this._remoteIceCandidates = iceCandidates;\r\n        this._remoteDtlsParameters = dtlsParameters;\r\n        this._cname = `CNAME-${utils.generateRandomNumber()}`;\r\n        this._setIceGatherer({ iceServers, iceTransportPolicy });\r\n        this._setIceTransport();\r\n        this._setDtlsTransport();\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not supported');\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteIceParameters = iceParameters;\r\n            if (!this._transportReady)\r\n                return;\r\n            logger.debug('restartIce() | calling iceTransport.start()');\r\n            this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');\r\n            for (const candidate of this._remoteIceCandidates) {\r\n                this._iceTransport.addRemoteCandidate(candidate);\r\n            }\r\n            this._iceTransport.addRemoteCandidate({});\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._iceTransport.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server' });\r\n            logger.debug('send() | calling new RTCRtpSender()');\r\n            const rtpSender = new RTCRtpSender(track, this._dtlsTransport);\r\n            const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);\r\n            const useRtx = rtpParameters.codecs\r\n                .some((_codec) => /.+\\/rtx$/i.test(_codec.mimeType));\r\n            if (!encodings)\r\n                encodings = [{}];\r\n            for (const encoding of encodings) {\r\n                encoding.ssrc = utils.generateRandomNumber();\r\n                if (useRtx)\r\n                    encoding.rtx = { ssrc: utils.generateRandomNumber() };\r\n            }\r\n            rtpParameters.encodings = encodings;\r\n            rtpParameters.rtcp =\r\n                {\r\n                    cname: this._cname,\r\n                    reducedSize: true,\r\n                    mux: true\r\n                };\r\n            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\r\n            logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);\r\n            yield rtpSender.send(edgeRtpParameters);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            this._rtpSenders.set(localId, rtpSender);\r\n            return { localId, rtpParameters, rtpSender };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            this._rtpSenders.delete(localId);\r\n            try {\r\n                logger.debug('stopSending() | calling rtpSender.stop()');\r\n                rtpSender.stop();\r\n            }\r\n            catch (error) {\r\n                logger.warn('stopSending() | rtpSender.stop() failed:%o', error);\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            rtpSender.setTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings\r\n                .forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const rtpSender = this._rtpSenders.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('RTCRtpSender not found');\r\n            return rtpSender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel(options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server' });\r\n            logger.debug('receive() | calling new RTCRtpReceiver()');\r\n            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);\r\n            rtpReceiver.addEventListener('error', (event) => {\r\n                logger.error('rtpReceiver \"error\" event [event:%o]', event);\r\n            });\r\n            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);\r\n            logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);\r\n            yield rtpReceiver.receive(edgeRtpParameters);\r\n            const localId = trackId;\r\n            this._rtpReceivers.set(localId, rtpReceiver);\r\n            return {\r\n                localId,\r\n                track: rtpReceiver.track,\r\n                rtpReceiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const rtpReceiver = this._rtpReceivers.get(localId);\r\n            if (!rtpReceiver)\r\n                throw new Error('RTCRtpReceiver not found');\r\n            this._rtpReceivers.delete(localId);\r\n            try {\r\n                logger.debug('stopReceiving() | calling rtpReceiver.stop()');\r\n                rtpReceiver.stop();\r\n            }\r\n            catch (error) {\r\n                logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);\r\n            }\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const rtpReceiver = this._rtpReceivers.get(localId);\r\n            if (!rtpReceiver)\r\n                throw new Error('RTCRtpReceiver not found');\r\n            return rtpReceiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel(options) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    _setIceGatherer({ iceServers, iceTransportPolicy }) {\r\n        const iceGatherer = new RTCIceGatherer({\r\n            iceServers: iceServers || [],\r\n            gatherPolicy: iceTransportPolicy || 'all'\r\n        });\r\n        iceGatherer.addEventListener('error', (event) => {\r\n            logger.error('iceGatherer \"error\" event [event:%o]', event);\r\n        });\r\n        try {\r\n            iceGatherer.gather();\r\n        }\r\n        catch (error) {\r\n            logger.debug('_setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());\r\n        }\r\n        this._iceGatherer = iceGatherer;\r\n    }\r\n    _setIceTransport() {\r\n        const iceTransport = new RTCIceTransport(this._iceGatherer);\r\n        iceTransport.addEventListener('statechange', () => {\r\n            switch (iceTransport.state) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n        iceTransport.addEventListener('icestatechange', () => {\r\n            switch (iceTransport.state) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n        iceTransport.addEventListener('candidatepairchange', (event) => {\r\n            logger.debug('iceTransport \"candidatepairchange\" event [pair:%o]', event.pair);\r\n        });\r\n        this._iceTransport = iceTransport;\r\n    }\r\n    _setDtlsTransport() {\r\n        const dtlsTransport = new RTCDtlsTransport(this._iceTransport);\r\n        dtlsTransport.addEventListener('statechange', () => {\r\n            logger.debug('dtlsTransport \"statechange\" event [state:%s]', dtlsTransport.state);\r\n        });\r\n        dtlsTransport.addEventListener('dtlsstatechange', () => {\r\n            logger.debug('dtlsTransport \"dtlsstatechange\" event [state:%s]', dtlsTransport.state);\r\n            if (dtlsTransport.state === 'closed')\r\n                this.emit('@connectionstatechange', 'closed');\r\n        });\r\n        dtlsTransport.addEventListener('error', (event) => {\r\n            logger.error('dtlsTransport \"error\" event [event:%o]', event);\r\n        });\r\n        this._dtlsTransport = dtlsTransport;\r\n    }\r\n    _setupTransport({ localDtlsRole }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('_setupTransport()');\r\n            const dtlsParameters = this._dtlsTransport.getLocalParameters();\r\n            dtlsParameters.role = localDtlsRole;\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');\r\n            for (const candidate of this._remoteIceCandidates) {\r\n                this._iceTransport.addRemoteCandidate(candidate);\r\n            }\r\n            this._iceTransport.addRemoteCandidate({});\r\n            this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints\r\n                .filter((fingerprint) => {\r\n                return (fingerprint.algorithm === 'sha-256' ||\r\n                    fingerprint.algorithm === 'sha-384' ||\r\n                    fingerprint.algorithm === 'sha-512');\r\n            });\r\n            this._dtlsTransport.start(this._remoteDtlsParameters);\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n}\r\nexports.Edge11 = Edge11;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Edge11.ts?");

/***/ }),

/***/ "./src/handlers/Firefox60.ts":
/*!***********************************!*\
  !*** ./src/handlers/Firefox60.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./src/handlers/sdp/unifiedPlanUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Firefox60');\r\nconst SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };\r\nclass Firefox60 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._mapMidTransceiver = new Map();\r\n        this._sendStream = new MediaStream();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Firefox60();\r\n    }\r\n    get name() {\r\n        return 'Firefox60';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require'\r\n            });\r\n            const canvas = document.createElement('canvas');\r\n            canvas.getContext('2d');\r\n            const fakeStream = canvas.captureStream();\r\n            const fakeVideoTrack = fakeStream.getVideoTracks()[0];\r\n            try {\r\n                pc.addTransceiver('audio', { direction: 'sendrecv' });\r\n                const videoTransceiver = pc.addTransceiver(fakeVideoTrack, { direction: 'sendrecv' });\r\n                const parameters = videoTransceiver.sender.getParameters();\r\n                const encodings = [\r\n                    { rid: 'r0', maxBitrate: 100000 },\r\n                    { rid: 'r1', maxBitrate: 500000 }\r\n                ];\r\n                parameters.encodings = encodings;\r\n                yield videoTransceiver.sender.setParameters(parameters);\r\n                const offer = yield pc.createOffer();\r\n                try {\r\n                    canvas.remove();\r\n                }\r\n                catch (error) { }\r\n                try {\r\n                    fakeVideoTrack.stop();\r\n                }\r\n                catch (error) { }\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    canvas.remove();\r\n                }\r\n                catch (error2) { }\r\n                try {\r\n                    fakeVideoTrack.stop();\r\n                }\r\n                catch (error2) { }\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not supported');\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            let reverseEncodings;\r\n            if (encodings && encodings.length > 1) {\r\n                encodings.forEach((encoding, idx) => {\r\n                    encoding.rid = `r${idx}`;\r\n                });\r\n                reverseEncodings = utils.clone(encodings).reverse();\r\n            }\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\r\n            const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\r\n            if (reverseEncodings) {\r\n                const parameters = transceiver.sender.getParameters();\r\n                parameters.encodings = reverseEncodings;\r\n                yield transceiver.sender.setParameters(parameters);\r\n            }\r\n            const offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const localId = transceiver.mid;\r\n            sendingRtpParameters.mid = localId;\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            if (!encodings) {\r\n                sendingRtpParameters.encodings =\r\n                    sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n            }\r\n            else if (encodings.length === 1) {\r\n                const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n                Object.assign(newEncodings[0], encodings[0]);\r\n                sendingRtpParameters.encodings = newEncodings;\r\n            }\r\n            else {\r\n                sendingRtpParameters.encodings = encodings;\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions,\r\n                extmapAllowMixed: true\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender: transceiver.sender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated transceiver not found');\r\n            transceiver.sender.replaceTrack(null);\r\n            this._pc.removeTrack(transceiver.sender);\r\n            this._remoteSdp.disableMediaSection(transceiver.mid);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            yield transceiver.sender.replaceTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated transceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            spatialLayer = parameters.encodings.length - 1 - spatialLayer;\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx >= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.sender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\r\n            this._remoteSdp.receive({\r\n                mid: localId,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === localId);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const transceiver = this._pc.getTransceivers()\r\n                .find((t) => t.mid === localId);\r\n            if (!transceiver)\r\n                throw new Error('new RTCRtpTransceiver not found');\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                track: transceiver.receiver.track,\r\n                rtpReceiver: transceiver.receiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.receiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation();\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Firefox60 = Firefox60;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Firefox60.ts?");

/***/ }),

/***/ "./src/handlers/HandlerInterface.ts":
/*!******************************************!*\
  !*** ./src/handlers/HandlerInterface.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst EnhancedEventEmitter_1 = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./src/EnhancedEventEmitter.ts\");\r\nclass HandlerInterface extends EnhancedEventEmitter_1.EnhancedEventEmitter {\r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\nexports.HandlerInterface = HandlerInterface;\r\n\n\n//# sourceURL=webpack:///./src/handlers/HandlerInterface.ts?");

/***/ }),

/***/ "./src/handlers/ReactNative.ts":
/*!*************************************!*\
  !*** ./src/handlers/ReactNative.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst errors_1 = __webpack_require__(/*! ../errors */ \"./src/errors.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"./src/handlers/sdp/planBUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('ReactNative');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass ReactNative extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._sendStream = new MediaStream();\r\n        this._mapSendLocalIdTrack = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._mapRecvLocalIdInfo = new Map();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new ReactNative();\r\n    }\r\n    get name() {\r\n        return 'ReactNative';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'plan-b'\r\n            });\r\n            try {\r\n                const offer = yield pc.createOffer({\r\n                    offerToReceiveAudio: true,\r\n                    offerToReceiveVideo: true\r\n                });\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            planB: true\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (codec) {\r\n                logger.warn('send() | codec selection is not available in %s handler', this.name);\r\n            }\r\n            this._sendStream.addTrack(track);\r\n            this._pc.addStream(this._sendStream);\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (track.kind === 'video' && encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'video');\r\n                sdpPlanBUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    track,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media\r\n                .find((m) => m.type === track.kind);\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            this._mapSendLocalIdTrack.set(localId, track);\r\n            return {\r\n                localId: localId,\r\n                rtpParameters: sendingRtpParameters\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const track = this._mapSendLocalIdTrack.get(localId);\r\n            if (!track)\r\n                throw new Error('track not found');\r\n            this._mapSendLocalIdTrack.delete(localId);\r\n            this._sendStream.removeTrack(track);\r\n            this._pc.addStream(this._sendStream);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            try {\r\n                yield this._pc.setLocalDescription(offer);\r\n            }\r\n            catch (error) {\r\n                if (this._sendStream.getTracks().length === 0) {\r\n                    logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n            if (this._pc.signalingState === 'stable')\r\n                return;\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = trackId;\r\n            const mid = kind;\r\n            let streamId = rtpParameters.rtcp.cname;\r\n            logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');\r\n            streamId += `-hack-${utils.generateRandomNumber()}`;\r\n            this._remoteSdp.receive({\r\n                mid,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === mid);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const stream = this._pc.getRemoteStreams()\r\n                .find((s) => s.id === streamId);\r\n            const track = stream.getTrackById(localId);\r\n            if (!track)\r\n                throw new Error('remote track not found');\r\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });\r\n            return { localId, track };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            this._mapRecvLocalIdInfo.delete(localId);\r\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throw new errors_1.UnsupportedError('not implemented');\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmitTime: maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.ReactNative = ReactNative;\r\n\n\n//# sourceURL=webpack:///./src/handlers/ReactNative.ts?");

/***/ }),

/***/ "./src/handlers/Safari11.ts":
/*!**********************************!*\
  !*** ./src/handlers/Safari11.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpPlanBUtils = __importStar(__webpack_require__(/*! ./sdp/planBUtils */ \"./src/handlers/sdp/planBUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Safari11');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Safari11 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._sendStream = new MediaStream();\r\n        this._mapSendLocalIdRtpSender = new Map();\r\n        this._nextSendLocalId = 0;\r\n        this._mapRecvLocalIdInfo = new Map();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Safari11();\r\n    }\r\n    get name() {\r\n        return 'Safari11';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require',\r\n                sdpSemantics: 'plan-b'\r\n            });\r\n            try {\r\n                const offer = yield pc.createOffer({\r\n                    offerToReceiveAudio: true,\r\n                    offerToReceiveVideo: true\r\n                });\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters,\r\n            planB: true\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            if (codec) {\r\n                logger.warn('send() | codec selection is not available in %s handler', this.name);\r\n            }\r\n            this._sendStream.addTrack(track);\r\n            this._pc.addTrack(track, this._sendStream);\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (track.kind === 'video' && encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');\r\n                sdpPlanBUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    track,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media\r\n                .find((m) => m.type === track.kind);\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            const localId = String(this._nextSendLocalId);\r\n            this._nextSendLocalId++;\r\n            const rtpSender = this._pc.getSenders()\r\n                .find((s) => s.track === track);\r\n            this._mapSendLocalIdRtpSender.set(localId, rtpSender);\r\n            return {\r\n                localId: localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            if (rtpSender.track)\r\n                this._sendStream.removeTrack(rtpSender.track);\r\n            this._mapSendLocalIdRtpSender.delete(localId);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            try {\r\n                yield this._pc.setLocalDescription(offer);\r\n            }\r\n            catch (error) {\r\n                if (this._sendStream.getTracks().length === 0) {\r\n                    logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\r\n                    return;\r\n                }\r\n                throw error;\r\n            }\r\n            if (this._pc.signalingState === 'stable')\r\n                return;\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const oldTrack = rtpSender.track;\r\n            yield rtpSender.replaceTrack(track);\r\n            if (oldTrack)\r\n                this._sendStream.removeTrack(oldTrack);\r\n            if (track)\r\n                this._sendStream.addTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            const parameters = rtpSender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield rtpSender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\r\n            if (!rtpSender)\r\n                throw new Error('associated RTCRtpSender not found');\r\n            return rtpSender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = trackId;\r\n            const mid = kind;\r\n            this._remoteSdp.receive({\r\n                mid,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === mid);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const rtpReceiver = this._pc.getReceivers()\r\n                .find((r) => r.track && r.track.id === localId);\r\n            if (!rtpReceiver)\r\n                throw new Error('new RTCRtpReceiver not');\r\n            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });\r\n            return {\r\n                localId,\r\n                track: rtpReceiver.track,\r\n                rtpReceiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            this._mapRecvLocalIdInfo.delete(localId);\r\n            this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\r\n            if (!rtpReceiver)\r\n                throw new Error('associated RTCRtpReceiver not found');\r\n            return rtpReceiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Safari11 = Safari11;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Safari11.ts?");

/***/ }),

/***/ "./src/handlers/Safari12.ts":
/*!**********************************!*\
  !*** ./src/handlers/Safari12.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../Logger */ \"./src/Logger.ts\");\r\nconst utils = __importStar(__webpack_require__(/*! ../utils */ \"./src/utils.ts\"));\r\nconst ortc = __importStar(__webpack_require__(/*! ../ortc */ \"./src/ortc.ts\"));\r\nconst sdpCommonUtils = __importStar(__webpack_require__(/*! ./sdp/commonUtils */ \"./src/handlers/sdp/commonUtils.ts\"));\r\nconst sdpUnifiedPlanUtils = __importStar(__webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./src/handlers/sdp/unifiedPlanUtils.ts\"));\r\nconst HandlerInterface_1 = __webpack_require__(/*! ./HandlerInterface */ \"./src/handlers/HandlerInterface.ts\");\r\nconst RemoteSdp_1 = __webpack_require__(/*! ./sdp/RemoteSdp */ \"./src/handlers/sdp/RemoteSdp.ts\");\r\nconst logger = new Logger_1.Logger('Safari12');\r\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\r\nclass Safari12 extends HandlerInterface_1.HandlerInterface {\r\n    constructor() {\r\n        super();\r\n        this._mapMidTransceiver = new Map();\r\n        this._sendStream = new MediaStream();\r\n        this._hasDataChannelMediaSection = false;\r\n        this._nextSendSctpStreamId = 0;\r\n        this._transportReady = false;\r\n    }\r\n    static createFactory() {\r\n        return () => new Safari12();\r\n    }\r\n    get name() {\r\n        return 'Safari12';\r\n    }\r\n    close() {\r\n        logger.debug('close()');\r\n        if (this._pc) {\r\n            try {\r\n                this._pc.close();\r\n            }\r\n            catch (error) { }\r\n        }\r\n    }\r\n    getNativeRtpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeRtpCapabilities()');\r\n            const pc = new RTCPeerConnection({\r\n                iceServers: [],\r\n                iceTransportPolicy: 'all',\r\n                bundlePolicy: 'max-bundle',\r\n                rtcpMuxPolicy: 'require'\r\n            });\r\n            try {\r\n                pc.addTransceiver('audio');\r\n                pc.addTransceiver('video');\r\n                const offer = yield pc.createOffer();\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error) { }\r\n                const sdpObject = sdpTransform.parse(offer.sdp);\r\n                const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\r\n                return nativeRtpCapabilities;\r\n            }\r\n            catch (error) {\r\n                try {\r\n                    pc.close();\r\n                }\r\n                catch (error2) { }\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    getNativeSctpCapabilities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('getNativeSctpCapabilities()');\r\n            return {\r\n                numStreams: SCTP_NUM_STREAMS\r\n            };\r\n        });\r\n    }\r\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\r\n        logger.debug('run()');\r\n        this._direction = direction;\r\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\r\n            iceParameters,\r\n            iceCandidates,\r\n            dtlsParameters,\r\n            sctpParameters\r\n        });\r\n        this._sendingRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._sendingRemoteRtpParametersByKind =\r\n            {\r\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\r\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\r\n            };\r\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);\r\n        this._pc.addEventListener('iceconnectionstatechange', () => {\r\n            switch (this._pc.iceConnectionState) {\r\n                case 'checking':\r\n                    this.emit('@connectionstatechange', 'connecting');\r\n                    break;\r\n                case 'connected':\r\n                case 'completed':\r\n                    this.emit('@connectionstatechange', 'connected');\r\n                    break;\r\n                case 'failed':\r\n                    this.emit('@connectionstatechange', 'failed');\r\n                    break;\r\n                case 'disconnected':\r\n                    this.emit('@connectionstatechange', 'disconnected');\r\n                    break;\r\n                case 'closed':\r\n                    this.emit('@connectionstatechange', 'closed');\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateIceServers(iceServers) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('updateIceServers()');\r\n            const configuration = this._pc.getConfiguration();\r\n            configuration.iceServers = iceServers;\r\n            this._pc.setConfiguration(configuration);\r\n        });\r\n    }\r\n    restartIce(iceParameters) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            logger.debug('restartIce()');\r\n            this._remoteSdp.updateIceParameters(iceParameters);\r\n            if (!this._transportReady)\r\n                return;\r\n            if (this._direction === 'send') {\r\n                const offer = yield this._pc.createOffer({ iceRestart: true });\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n            }\r\n            else {\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n            }\r\n        });\r\n    }\r\n    getTransportStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this._pc.getStats();\r\n        });\r\n    }\r\n    send({ track, encodings, codecOptions, codec }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\r\n            const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);\r\n            sendingRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\r\n            const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);\r\n            sendingRemoteRtpParameters.codecs =\r\n                ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\r\n            const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();\r\n            const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\r\n            let offer = yield this._pc.createOffer();\r\n            let localSdpObject = sdpTransform.parse(offer.sdp);\r\n            let offerMediaObject;\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n            if (encodings && encodings.length > 1) {\r\n                logger.debug('send() | enabling legacy simulcast');\r\n                localSdpObject = sdpTransform.parse(offer.sdp);\r\n                offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n                sdpUnifiedPlanUtils.addLegacySimulcast({\r\n                    offerMediaObject,\r\n                    numStreams: encodings.length\r\n                });\r\n                offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\r\n            }\r\n            logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const localId = transceiver.mid;\r\n            sendingRtpParameters.mid = localId;\r\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];\r\n            sendingRtpParameters.rtcp.cname =\r\n                sdpCommonUtils.getCname({ offerMediaObject });\r\n            sendingRtpParameters.encodings =\r\n                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\r\n            if (encodings) {\r\n                for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\r\n                    if (encodings[idx])\r\n                        Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\r\n                }\r\n            }\r\n            if (sendingRtpParameters.encodings.length > 1 &&\r\n                (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\r\n                    sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\r\n                for (const encoding of sendingRtpParameters.encodings) {\r\n                    encoding.scalabilityMode = 'S1T3';\r\n                }\r\n            }\r\n            this._remoteSdp.send({\r\n                offerMediaObject,\r\n                reuseMid: mediaSectionIdx.reuseMid,\r\n                offerRtpParameters: sendingRtpParameters,\r\n                answerRtpParameters: sendingRemoteRtpParameters,\r\n                codecOptions\r\n            });\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                rtpParameters: sendingRtpParameters,\r\n                rtpSender: transceiver.sender\r\n            };\r\n        });\r\n    }\r\n    stopSending(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('stopSending() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            transceiver.sender.replaceTrack(null);\r\n            this._pc.removeTrack(transceiver.sender);\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = yield this._pc.createOffer();\r\n            logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n            yield this._pc.setLocalDescription(offer);\r\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n            yield this._pc.setRemoteDescription(answer);\r\n        });\r\n    }\r\n    replaceTrack(localId, track) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            if (track) {\r\n                logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\r\n            }\r\n            else {\r\n                logger.debug('replaceTrack() [localId:%s, no track]', localId);\r\n            }\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            yield transceiver.sender.replaceTrack(track);\r\n        });\r\n    }\r\n    setMaxSpatialLayer(localId, spatialLayer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                if (idx <= spatialLayer)\r\n                    encoding.active = true;\r\n                else\r\n                    encoding.active = false;\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    setRtpEncodingParameters(localId, params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            const parameters = transceiver.sender.getParameters();\r\n            parameters.encodings.forEach((encoding, idx) => {\r\n                parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\r\n            });\r\n            yield transceiver.sender.setParameters(parameters);\r\n        });\r\n    }\r\n    getSenderStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.sender.getStats();\r\n        });\r\n    }\r\n    sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertSendDirection();\r\n            const options = {\r\n                negotiated: true,\r\n                id: this._nextSendSctpStreamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol,\r\n                priority\r\n            };\r\n            logger.debug('sendDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            this._nextSendSctpStreamId =\r\n                ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\r\n            if (!this._hasDataChannelMediaSection) {\r\n                const offer = yield this._pc.createOffer();\r\n                const localSdpObject = sdpTransform.parse(offer.sdp);\r\n                const offerMediaObject = localSdpObject.media\r\n                    .find((m) => m.type === 'application');\r\n                if (!this._transportReady)\r\n                    yield this._setupTransport({ localDtlsRole: 'server', localSdpObject });\r\n                logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\r\n                yield this._pc.setLocalDescription(offer);\r\n                this._remoteSdp.sendSctpAssociation({ offerMediaObject });\r\n                const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setRemoteDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            const sctpStreamParameters = {\r\n                streamId: options.id,\r\n                ordered: options.ordered,\r\n                maxPacketLifeTime: options.maxPacketLifeTime,\r\n                maxRetransmits: options.maxRetransmits\r\n            };\r\n            return { dataChannel, sctpStreamParameters };\r\n        });\r\n    }\r\n    receive({ trackId, kind, rtpParameters }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\r\n            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\r\n            this._remoteSdp.receive({\r\n                mid: localId,\r\n                kind,\r\n                offerRtpParameters: rtpParameters,\r\n                streamId: rtpParameters.rtcp.cname,\r\n                trackId\r\n            });\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            let answer = yield this._pc.createAnswer();\r\n            const localSdpObject = sdpTransform.parse(answer.sdp);\r\n            const answerMediaObject = localSdpObject.media\r\n                .find((m) => String(m.mid) === localId);\r\n            sdpCommonUtils.applyCodecParameters({\r\n                offerRtpParameters: rtpParameters,\r\n                answerMediaObject\r\n            });\r\n            answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\r\n            if (!this._transportReady)\r\n                yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n            logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n            const transceiver = this._pc.getTransceivers()\r\n                .find((t) => t.mid === localId);\r\n            if (!transceiver)\r\n                throw new Error('new RTCRtpTransceiver not found');\r\n            this._mapMidTransceiver.set(localId, transceiver);\r\n            return {\r\n                localId,\r\n                track: transceiver.receiver.track,\r\n                rtpReceiver: transceiver.receiver\r\n            };\r\n        });\r\n    }\r\n    stopReceiving(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            logger.debug('stopReceiving() [localId:%s]', localId);\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            this._remoteSdp.closeMediaSection(transceiver.mid);\r\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n            logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n            yield this._pc.setRemoteDescription(offer);\r\n            const answer = yield this._pc.createAnswer();\r\n            logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\r\n            yield this._pc.setLocalDescription(answer);\r\n        });\r\n    }\r\n    getReceiverStats(localId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const transceiver = this._mapMidTransceiver.get(localId);\r\n            if (!transceiver)\r\n                throw new Error('associated RTCRtpTransceiver not found');\r\n            return transceiver.receiver.getStats();\r\n        });\r\n    }\r\n    receiveDataChannel({ sctpStreamParameters, label, protocol }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._assertRecvDirection();\r\n            const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\r\n            const options = {\r\n                negotiated: true,\r\n                id: streamId,\r\n                ordered,\r\n                maxPacketLifeTime,\r\n                maxRetransmits,\r\n                protocol\r\n            };\r\n            logger.debug('receiveDataChannel() [options:%o]', options);\r\n            const dataChannel = this._pc.createDataChannel(label, options);\r\n            if (!this._hasDataChannelMediaSection) {\r\n                this._remoteSdp.receiveSctpAssociation();\r\n                const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\r\n                yield this._pc.setRemoteDescription(offer);\r\n                const answer = yield this._pc.createAnswer();\r\n                if (!this._transportReady) {\r\n                    const localSdpObject = sdpTransform.parse(answer.sdp);\r\n                    yield this._setupTransport({ localDtlsRole: 'client', localSdpObject });\r\n                }\r\n                logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\r\n                yield this._pc.setLocalDescription(answer);\r\n                this._hasDataChannelMediaSection = true;\r\n            }\r\n            return { dataChannel };\r\n        });\r\n    }\r\n    _setupTransport({ localDtlsRole, localSdpObject }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!localSdpObject)\r\n                localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\r\n            const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\r\n            dtlsParameters.role = localDtlsRole;\r\n            this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\r\n            yield this.safeEmitAsPromise('@connect', { dtlsParameters });\r\n            this._transportReady = true;\r\n        });\r\n    }\r\n    _assertSendDirection() {\r\n        if (this._direction !== 'send') {\r\n            throw new Error('method can just be called for handlers with \"send\" direction');\r\n        }\r\n    }\r\n    _assertRecvDirection() {\r\n        if (this._direction !== 'recv') {\r\n            throw new Error('method can just be called for handlers with \"recv\" direction');\r\n        }\r\n    }\r\n}\r\nexports.Safari12 = Safari12;\r\n\n\n//# sourceURL=webpack:///./src/handlers/Safari12.ts?");

/***/ }),

/***/ "./src/handlers/ortc/edgeUtils.ts":
/*!****************************************!*\
  !*** ./src/handlers/ortc/edgeUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = __importStar(__webpack_require__(/*! ../../utils */ \"./src/utils.ts\"));\r\nfunction getCapabilities() {\r\n    const nativeCaps = RTCRtpReceiver.getCapabilities();\r\n    const caps = utils.clone(nativeCaps);\r\n    for (const codec of caps.codecs) {\r\n        codec.channels = codec.numChannels;\r\n        delete codec.numChannels;\r\n        codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;\r\n        if (codec.parameters) {\r\n            const parameters = codec.parameters;\r\n            if (parameters.apt)\r\n                parameters.apt = Number(parameters.apt);\r\n            if (parameters['packetization-mode'])\r\n                parameters['packetization-mode'] = Number(parameters['packetization-mode']);\r\n        }\r\n        for (const feedback of codec.rtcpFeedback || []) {\r\n            if (!feedback.parameter)\r\n                feedback.parameter = '';\r\n        }\r\n    }\r\n    return caps;\r\n}\r\nexports.getCapabilities = getCapabilities;\r\nfunction mangleRtpParameters(rtpParameters) {\r\n    const params = utils.clone(rtpParameters);\r\n    if (params.mid) {\r\n        params.muxId = params.mid;\r\n        delete params.mid;\r\n    }\r\n    for (const codec of params.codecs) {\r\n        if (codec.channels) {\r\n            codec.numChannels = codec.channels;\r\n            delete codec.channels;\r\n        }\r\n        if (codec.mimeType && !codec.name)\r\n            codec.name = codec.mimeType.split('/')[1];\r\n        delete codec.mimeType;\r\n    }\r\n    return params;\r\n}\r\nexports.mangleRtpParameters = mangleRtpParameters;\r\n\n\n//# sourceURL=webpack:///./src/handlers/ortc/edgeUtils.ts?");

/***/ }),

/***/ "./src/handlers/sdp/MediaSection.ts":
/*!******************************************!*\
  !*** ./src/handlers/sdp/MediaSection.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = __importStar(__webpack_require__(/*! ../../utils */ \"./src/utils.ts\"));\r\nclass MediaSection {\r\n    constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false }) {\r\n        this._mediaObject = {};\r\n        this._planB = planB;\r\n        if (iceParameters) {\r\n            this.setIceParameters(iceParameters);\r\n        }\r\n        if (iceCandidates) {\r\n            this._mediaObject.candidates = [];\r\n            for (const candidate of iceCandidates) {\r\n                const candidateObject = {};\r\n                candidateObject.component = 1;\r\n                candidateObject.foundation = candidate.foundation;\r\n                candidateObject.ip = candidate.ip;\r\n                candidateObject.port = candidate.port;\r\n                candidateObject.priority = candidate.priority;\r\n                candidateObject.transport = candidate.protocol;\r\n                candidateObject.type = candidate.type;\r\n                if (candidate.tcpType)\r\n                    candidateObject.tcptype = candidate.tcpType;\r\n                this._mediaObject.candidates.push(candidateObject);\r\n            }\r\n            this._mediaObject.endOfCandidates = 'end-of-candidates';\r\n            this._mediaObject.iceOptions = 'renomination';\r\n        }\r\n        if (dtlsParameters) {\r\n            this.setDtlsRole(dtlsParameters.role);\r\n        }\r\n    }\r\n    get mid() {\r\n        return String(this._mediaObject.mid);\r\n    }\r\n    get closed() {\r\n        return this._mediaObject.port === 0;\r\n    }\r\n    getObject() {\r\n        return this._mediaObject;\r\n    }\r\n    setIceParameters(iceParameters) {\r\n        this._mediaObject.iceUfrag = iceParameters.usernameFragment;\r\n        this._mediaObject.icePwd = iceParameters.password;\r\n    }\r\n    disable() {\r\n        this._mediaObject.direction = 'inactive';\r\n        delete this._mediaObject.ext;\r\n        delete this._mediaObject.ssrcs;\r\n        delete this._mediaObject.ssrcGroups;\r\n        delete this._mediaObject.simulcast;\r\n        delete this._mediaObject.simulcast_03;\r\n        delete this._mediaObject.rids;\r\n    }\r\n    close() {\r\n        this._mediaObject.direction = 'inactive';\r\n        this._mediaObject.port = 0;\r\n        delete this._mediaObject.ext;\r\n        delete this._mediaObject.ssrcs;\r\n        delete this._mediaObject.ssrcGroups;\r\n        delete this._mediaObject.simulcast;\r\n        delete this._mediaObject.simulcast_03;\r\n        delete this._mediaObject.rids;\r\n        delete this._mediaObject.extmapAllowMixed;\r\n    }\r\n}\r\nexports.MediaSection = MediaSection;\r\nclass AnswerMediaSection extends MediaSection {\r\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {\r\n        super({ iceParameters, iceCandidates, dtlsParameters, planB });\r\n        this._mediaObject.mid = String(offerMediaObject.mid);\r\n        this._mediaObject.type = offerMediaObject.type;\r\n        this._mediaObject.protocol = offerMediaObject.protocol;\r\n        if (!plainRtpParameters) {\r\n            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };\r\n            this._mediaObject.port = 7;\r\n        }\r\n        else {\r\n            this._mediaObject.connection =\r\n                {\r\n                    ip: plainRtpParameters.ip,\r\n                    version: plainRtpParameters.ipVersion\r\n                };\r\n            this._mediaObject.port = plainRtpParameters.port;\r\n        }\r\n        switch (offerMediaObject.type) {\r\n            case 'audio':\r\n            case 'video':\r\n                {\r\n                    this._mediaObject.direction = 'recvonly';\r\n                    this._mediaObject.rtp = [];\r\n                    this._mediaObject.rtcpFb = [];\r\n                    this._mediaObject.fmtp = [];\r\n                    for (const codec of answerRtpParameters.codecs) {\r\n                        const rtp = {\r\n                            payload: codec.payloadType,\r\n                            codec: getCodecName(codec),\r\n                            rate: codec.clockRate\r\n                        };\r\n                        if (codec.channels > 1)\r\n                            rtp.encoding = codec.channels;\r\n                        this._mediaObject.rtp.push(rtp);\r\n                        const codecParameters = utils.clone(codec.parameters || {});\r\n                        if (codecOptions) {\r\n                            const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusPtime, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;\r\n                            const offerCodec = offerRtpParameters.codecs\r\n                                .find((c) => (c.payloadType === codec.payloadType));\r\n                            switch (codec.mimeType.toLowerCase()) {\r\n                                case 'audio/opus':\r\n                                    {\r\n                                        if (opusStereo !== undefined) {\r\n                                            offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;\r\n                                            codecParameters.stereo = opusStereo ? 1 : 0;\r\n                                        }\r\n                                        if (opusFec !== undefined) {\r\n                                            offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;\r\n                                            codecParameters.useinbandfec = opusFec ? 1 : 0;\r\n                                        }\r\n                                        if (opusDtx !== undefined) {\r\n                                            offerCodec.parameters.usedtx = opusDtx ? 1 : 0;\r\n                                            codecParameters.usedtx = opusDtx ? 1 : 0;\r\n                                        }\r\n                                        if (opusMaxPlaybackRate !== undefined) {\r\n                                            codecParameters.maxplaybackrate = opusMaxPlaybackRate;\r\n                                        }\r\n                                        if (opusPtime !== undefined) {\r\n                                            offerCodec.parameters.ptime = opusPtime;\r\n                                            codecParameters.ptime = opusPtime;\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                case 'video/vp8':\r\n                                case 'video/vp9':\r\n                                case 'video/h264':\r\n                                case 'video/h265':\r\n                                    {\r\n                                        if (videoGoogleStartBitrate !== undefined)\r\n                                            codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;\r\n                                        if (videoGoogleMaxBitrate !== undefined)\r\n                                            codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;\r\n                                        if (videoGoogleMinBitrate !== undefined)\r\n                                            codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;\r\n                                        break;\r\n                                    }\r\n                            }\r\n                        }\r\n                        const fmtp = {\r\n                            payload: codec.payloadType,\r\n                            config: ''\r\n                        };\r\n                        for (const key of Object.keys(codecParameters)) {\r\n                            if (fmtp.config)\r\n                                fmtp.config += ';';\r\n                            fmtp.config += `${key}=${codecParameters[key]}`;\r\n                        }\r\n                        if (fmtp.config)\r\n                            this._mediaObject.fmtp.push(fmtp);\r\n                        for (const fb of codec.rtcpFeedback) {\r\n                            this._mediaObject.rtcpFb.push({\r\n                                payload: codec.payloadType,\r\n                                type: fb.type,\r\n                                subtype: fb.parameter\r\n                            });\r\n                        }\r\n                    }\r\n                    this._mediaObject.payloads = answerRtpParameters.codecs\r\n                        .map((codec) => codec.payloadType)\r\n                        .join(' ');\r\n                    this._mediaObject.ext = [];\r\n                    for (const ext of answerRtpParameters.headerExtensions) {\r\n                        const found = (offerMediaObject.ext || [])\r\n                            .some((localExt) => localExt.uri === ext.uri);\r\n                        if (!found)\r\n                            continue;\r\n                        this._mediaObject.ext.push({\r\n                            uri: ext.uri,\r\n                            value: ext.id\r\n                        });\r\n                    }\r\n                    if (extmapAllowMixed &&\r\n                        offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {\r\n                        this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';\r\n                    }\r\n                    if (offerMediaObject.simulcast) {\r\n                        this._mediaObject.simulcast =\r\n                            {\r\n                                dir1: 'recv',\r\n                                list1: offerMediaObject.simulcast.list1\r\n                            };\r\n                        this._mediaObject.rids = [];\r\n                        for (const rid of offerMediaObject.rids || []) {\r\n                            if (rid.direction !== 'send')\r\n                                continue;\r\n                            this._mediaObject.rids.push({\r\n                                id: rid.id,\r\n                                direction: 'recv'\r\n                            });\r\n                        }\r\n                    }\r\n                    else if (offerMediaObject.simulcast_03) {\r\n                        this._mediaObject.simulcast_03 =\r\n                            {\r\n                                value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')\r\n                            };\r\n                        this._mediaObject.rids = [];\r\n                        for (const rid of offerMediaObject.rids || []) {\r\n                            if (rid.direction !== 'send')\r\n                                continue;\r\n                            this._mediaObject.rids.push({\r\n                                id: rid.id,\r\n                                direction: 'recv'\r\n                            });\r\n                        }\r\n                    }\r\n                    this._mediaObject.rtcpMux = 'rtcp-mux';\r\n                    this._mediaObject.rtcpRsize = 'rtcp-rsize';\r\n                    if (this._planB && this._mediaObject.type === 'video')\r\n                        this._mediaObject.xGoogleFlag = 'conference';\r\n                    break;\r\n                }\r\n            case 'application':\r\n                {\r\n                    if (typeof offerMediaObject.sctpPort === 'number') {\r\n                        this._mediaObject.payloads = 'webrtc-datachannel';\r\n                        this._mediaObject.sctpPort = sctpParameters.port;\r\n                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\r\n                    }\r\n                    else if (offerMediaObject.sctpmap) {\r\n                        this._mediaObject.payloads = sctpParameters.port;\r\n                        this._mediaObject.sctpmap =\r\n                            {\r\n                                app: 'webrtc-datachannel',\r\n                                sctpmapNumber: sctpParameters.port,\r\n                                maxMessageSize: sctpParameters.maxMessageSize\r\n                            };\r\n                    }\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n    setDtlsRole(role) {\r\n        switch (role) {\r\n            case 'client':\r\n                this._mediaObject.setup = 'active';\r\n                break;\r\n            case 'server':\r\n                this._mediaObject.setup = 'passive';\r\n                break;\r\n            case 'auto':\r\n                this._mediaObject.setup = 'actpass';\r\n                break;\r\n        }\r\n    }\r\n}\r\nexports.AnswerMediaSection = AnswerMediaSection;\r\nclass OfferMediaSection extends MediaSection {\r\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false }) {\r\n        super({ iceParameters, iceCandidates, dtlsParameters, planB });\r\n        this._mediaObject.mid = String(mid);\r\n        this._mediaObject.type = kind;\r\n        if (!plainRtpParameters) {\r\n            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };\r\n            if (!sctpParameters)\r\n                this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';\r\n            else\r\n                this._mediaObject.protocol = 'UDP/DTLS/SCTP';\r\n            this._mediaObject.port = 7;\r\n        }\r\n        else {\r\n            this._mediaObject.connection =\r\n                {\r\n                    ip: plainRtpParameters.ip,\r\n                    version: plainRtpParameters.ipVersion\r\n                };\r\n            this._mediaObject.protocol = 'RTP/AVP';\r\n            this._mediaObject.port = plainRtpParameters.port;\r\n        }\r\n        switch (kind) {\r\n            case 'audio':\r\n            case 'video':\r\n                {\r\n                    this._mediaObject.direction = 'sendonly';\r\n                    this._mediaObject.rtp = [];\r\n                    this._mediaObject.rtcpFb = [];\r\n                    this._mediaObject.fmtp = [];\r\n                    if (!this._planB)\r\n                        this._mediaObject.msid = `${streamId || '-'} ${trackId}`;\r\n                    for (const codec of offerRtpParameters.codecs) {\r\n                        const rtp = {\r\n                            payload: codec.payloadType,\r\n                            codec: getCodecName(codec),\r\n                            rate: codec.clockRate\r\n                        };\r\n                        if (codec.channels > 1)\r\n                            rtp.encoding = codec.channels;\r\n                        this._mediaObject.rtp.push(rtp);\r\n                        const fmtp = {\r\n                            payload: codec.payloadType,\r\n                            config: ''\r\n                        };\r\n                        for (const key of Object.keys(codec.parameters)) {\r\n                            if (fmtp.config)\r\n                                fmtp.config += ';';\r\n                            fmtp.config += `${key}=${codec.parameters[key]}`;\r\n                        }\r\n                        if (fmtp.config)\r\n                            this._mediaObject.fmtp.push(fmtp);\r\n                        for (const fb of codec.rtcpFeedback) {\r\n                            this._mediaObject.rtcpFb.push({\r\n                                payload: codec.payloadType,\r\n                                type: fb.type,\r\n                                subtype: fb.parameter\r\n                            });\r\n                        }\r\n                    }\r\n                    this._mediaObject.payloads = offerRtpParameters.codecs\r\n                        .map((codec) => codec.payloadType)\r\n                        .join(' ');\r\n                    this._mediaObject.ext = [];\r\n                    for (const ext of offerRtpParameters.headerExtensions) {\r\n                        this._mediaObject.ext.push({\r\n                            uri: ext.uri,\r\n                            value: ext.id\r\n                        });\r\n                    }\r\n                    this._mediaObject.rtcpMux = 'rtcp-mux';\r\n                    this._mediaObject.rtcpRsize = 'rtcp-rsize';\r\n                    const encoding = offerRtpParameters.encodings[0];\r\n                    const ssrc = encoding.ssrc;\r\n                    const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\r\n                        ? encoding.rtx.ssrc\r\n                        : undefined;\r\n                    this._mediaObject.ssrcs = [];\r\n                    this._mediaObject.ssrcGroups = [];\r\n                    if (offerRtpParameters.rtcp.cname) {\r\n                        this._mediaObject.ssrcs.push({\r\n                            id: ssrc,\r\n                            attribute: 'cname',\r\n                            value: offerRtpParameters.rtcp.cname\r\n                        });\r\n                    }\r\n                    if (this._planB) {\r\n                        this._mediaObject.ssrcs.push({\r\n                            id: ssrc,\r\n                            attribute: 'msid',\r\n                            value: `${streamId || '-'} ${trackId}`\r\n                        });\r\n                    }\r\n                    if (rtxSsrc) {\r\n                        if (offerRtpParameters.rtcp.cname) {\r\n                            this._mediaObject.ssrcs.push({\r\n                                id: rtxSsrc,\r\n                                attribute: 'cname',\r\n                                value: offerRtpParameters.rtcp.cname\r\n                            });\r\n                        }\r\n                        if (this._planB) {\r\n                            this._mediaObject.ssrcs.push({\r\n                                id: rtxSsrc,\r\n                                attribute: 'msid',\r\n                                value: `${streamId || '-'} ${trackId}`\r\n                            });\r\n                        }\r\n                        this._mediaObject.ssrcGroups.push({\r\n                            semantics: 'FID',\r\n                            ssrcs: `${ssrc} ${rtxSsrc}`\r\n                        });\r\n                    }\r\n                    break;\r\n                }\r\n            case 'application':\r\n                {\r\n                    if (!oldDataChannelSpec) {\r\n                        this._mediaObject.payloads = 'webrtc-datachannel';\r\n                        this._mediaObject.sctpPort = sctpParameters.port;\r\n                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;\r\n                    }\r\n                    else {\r\n                        this._mediaObject.payloads = sctpParameters.port;\r\n                        this._mediaObject.sctpmap =\r\n                            {\r\n                                app: 'webrtc-datachannel',\r\n                                sctpmapNumber: sctpParameters.port,\r\n                                maxMessageSize: sctpParameters.maxMessageSize\r\n                            };\r\n                    }\r\n                    break;\r\n                }\r\n        }\r\n    }\r\n    setDtlsRole(role) {\r\n        this._mediaObject.setup = 'actpass';\r\n    }\r\n    planBReceive({ offerRtpParameters, streamId, trackId }) {\r\n        const encoding = offerRtpParameters.encodings[0];\r\n        const ssrc = encoding.ssrc;\r\n        const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\r\n            ? encoding.rtx.ssrc\r\n            : undefined;\r\n        if (offerRtpParameters.rtcp.cname) {\r\n            this._mediaObject.ssrcs.push({\r\n                id: ssrc,\r\n                attribute: 'cname',\r\n                value: offerRtpParameters.rtcp.cname\r\n            });\r\n        }\r\n        this._mediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'msid',\r\n            value: `${streamId || '-'} ${trackId}`\r\n        });\r\n        if (rtxSsrc) {\r\n            if (offerRtpParameters.rtcp.cname) {\r\n                this._mediaObject.ssrcs.push({\r\n                    id: rtxSsrc,\r\n                    attribute: 'cname',\r\n                    value: offerRtpParameters.rtcp.cname\r\n                });\r\n            }\r\n            this._mediaObject.ssrcs.push({\r\n                id: rtxSsrc,\r\n                attribute: 'msid',\r\n                value: `${streamId || '-'} ${trackId}`\r\n            });\r\n            this._mediaObject.ssrcGroups.push({\r\n                semantics: 'FID',\r\n                ssrcs: `${ssrc} ${rtxSsrc}`\r\n            });\r\n        }\r\n    }\r\n    planBStopReceiving({ offerRtpParameters }) {\r\n        const encoding = offerRtpParameters.encodings[0];\r\n        const ssrc = encoding.ssrc;\r\n        const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)\r\n            ? encoding.rtx.ssrc\r\n            : undefined;\r\n        this._mediaObject.ssrcs = this._mediaObject.ssrcs\r\n            .filter((s) => s.id !== ssrc && s.id !== rtxSsrc);\r\n        if (rtxSsrc) {\r\n            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups\r\n                .filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);\r\n        }\r\n    }\r\n}\r\nexports.OfferMediaSection = OfferMediaSection;\r\nfunction getCodecName(codec) {\r\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\r\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\r\n    if (!mimeTypeMatch)\r\n        throw new TypeError('invalid codec.mimeType');\r\n    return mimeTypeMatch[2];\r\n}\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/MediaSection.ts?");

/***/ }),

/***/ "./src/handlers/sdp/RemoteSdp.ts":
/*!***************************************!*\
  !*** ./src/handlers/sdp/RemoteSdp.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nconst Logger_1 = __webpack_require__(/*! ../../Logger */ \"./src/Logger.ts\");\r\nconst MediaSection_1 = __webpack_require__(/*! ./MediaSection */ \"./src/handlers/sdp/MediaSection.ts\");\r\nconst logger = new Logger_1.Logger('RemoteSdp');\r\nclass RemoteSdp {\r\n    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false }) {\r\n        this._mediaSections = [];\r\n        this._midToIndex = new Map();\r\n        this._iceParameters = iceParameters;\r\n        this._iceCandidates = iceCandidates;\r\n        this._dtlsParameters = dtlsParameters;\r\n        this._sctpParameters = sctpParameters;\r\n        this._plainRtpParameters = plainRtpParameters;\r\n        this._planB = planB;\r\n        this._sdpObject =\r\n            {\r\n                version: 0,\r\n                origin: {\r\n                    address: '0.0.0.0',\r\n                    ipVer: 4,\r\n                    netType: 'IN',\r\n                    sessionId: 10000,\r\n                    sessionVersion: 0,\r\n                    username: 'mediasoup-client'\r\n                },\r\n                name: '-',\r\n                timing: { start: 0, stop: 0 },\r\n                media: []\r\n            };\r\n        if (iceParameters && iceParameters.iceLite) {\r\n            this._sdpObject.icelite = 'ice-lite';\r\n        }\r\n        if (dtlsParameters) {\r\n            this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };\r\n            const numFingerprints = this._dtlsParameters.fingerprints.length;\r\n            this._sdpObject.fingerprint =\r\n                {\r\n                    type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,\r\n                    hash: dtlsParameters.fingerprints[numFingerprints - 1].value\r\n                };\r\n            this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];\r\n        }\r\n        if (plainRtpParameters) {\r\n            this._sdpObject.origin.address = plainRtpParameters.ip;\r\n            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;\r\n        }\r\n    }\r\n    updateIceParameters(iceParameters) {\r\n        logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);\r\n        this._iceParameters = iceParameters;\r\n        this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;\r\n        for (const mediaSection of this._mediaSections) {\r\n            mediaSection.setIceParameters(iceParameters);\r\n        }\r\n    }\r\n    updateDtlsRole(role) {\r\n        logger.debug('updateDtlsRole() [role:%s]', role);\r\n        this._dtlsParameters.role = role;\r\n        for (const mediaSection of this._mediaSections) {\r\n            mediaSection.setDtlsRole(role);\r\n        }\r\n    }\r\n    getNextMediaSectionIdx() {\r\n        for (let idx = 0; idx < this._mediaSections.length; ++idx) {\r\n            const mediaSection = this._mediaSections[idx];\r\n            if (mediaSection.closed)\r\n                return { idx, reuseMid: mediaSection.mid };\r\n        }\r\n        return { idx: this._mediaSections.length };\r\n    }\r\n    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {\r\n        const mediaSection = new MediaSection_1.AnswerMediaSection({\r\n            iceParameters: this._iceParameters,\r\n            iceCandidates: this._iceCandidates,\r\n            dtlsParameters: this._dtlsParameters,\r\n            plainRtpParameters: this._plainRtpParameters,\r\n            planB: this._planB,\r\n            offerMediaObject,\r\n            offerRtpParameters,\r\n            answerRtpParameters,\r\n            codecOptions,\r\n            extmapAllowMixed\r\n        });\r\n        if (reuseMid) {\r\n            this._replaceMediaSection(mediaSection, reuseMid);\r\n        }\r\n        else if (!this._midToIndex.has(mediaSection.mid)) {\r\n            this._addMediaSection(mediaSection);\r\n        }\r\n        else {\r\n            this._replaceMediaSection(mediaSection);\r\n        }\r\n    }\r\n    receive({ mid, kind, offerRtpParameters, streamId, trackId }) {\r\n        const idx = this._midToIndex.get(mid);\r\n        let mediaSection;\r\n        if (idx !== undefined)\r\n            mediaSection = this._mediaSections[idx];\r\n        if (!mediaSection) {\r\n            mediaSection = new MediaSection_1.OfferMediaSection({\r\n                iceParameters: this._iceParameters,\r\n                iceCandidates: this._iceCandidates,\r\n                dtlsParameters: this._dtlsParameters,\r\n                plainRtpParameters: this._plainRtpParameters,\r\n                planB: this._planB,\r\n                mid,\r\n                kind,\r\n                offerRtpParameters,\r\n                streamId,\r\n                trackId\r\n            });\r\n            this._addMediaSection(mediaSection);\r\n        }\r\n        else {\r\n            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });\r\n            this._replaceMediaSection(mediaSection);\r\n        }\r\n    }\r\n    disableMediaSection(mid) {\r\n        const idx = this._midToIndex.get(mid);\r\n        if (idx === undefined) {\r\n            throw new Error(`no media section found with mid '${mid}'`);\r\n        }\r\n        const mediaSection = this._mediaSections[idx];\r\n        mediaSection.disable();\r\n    }\r\n    closeMediaSection(mid) {\r\n        const idx = this._midToIndex.get(mid);\r\n        if (idx === undefined) {\r\n            throw new Error(`no media section found with mid '${mid}'`);\r\n        }\r\n        const mediaSection = this._mediaSections[idx];\r\n        if (mid === this._firstMid) {\r\n            logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);\r\n            this.disableMediaSection(mid);\r\n            return;\r\n        }\r\n        mediaSection.close();\r\n        this._regenerateBundleMids();\r\n    }\r\n    planBStopReceiving({ mid, offerRtpParameters }) {\r\n        const idx = this._midToIndex.get(mid);\r\n        if (idx === undefined) {\r\n            throw new Error(`no media section found with mid '${mid}'`);\r\n        }\r\n        const mediaSection = this._mediaSections[idx];\r\n        mediaSection.planBStopReceiving({ offerRtpParameters });\r\n        this._replaceMediaSection(mediaSection);\r\n    }\r\n    sendSctpAssociation({ offerMediaObject }) {\r\n        const mediaSection = new MediaSection_1.AnswerMediaSection({\r\n            iceParameters: this._iceParameters,\r\n            iceCandidates: this._iceCandidates,\r\n            dtlsParameters: this._dtlsParameters,\r\n            sctpParameters: this._sctpParameters,\r\n            plainRtpParameters: this._plainRtpParameters,\r\n            offerMediaObject\r\n        });\r\n        this._addMediaSection(mediaSection);\r\n    }\r\n    receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {\r\n        const mediaSection = new MediaSection_1.OfferMediaSection({\r\n            iceParameters: this._iceParameters,\r\n            iceCandidates: this._iceCandidates,\r\n            dtlsParameters: this._dtlsParameters,\r\n            sctpParameters: this._sctpParameters,\r\n            plainRtpParameters: this._plainRtpParameters,\r\n            mid: 'datachannel',\r\n            kind: 'application',\r\n            oldDataChannelSpec\r\n        });\r\n        this._addMediaSection(mediaSection);\r\n    }\r\n    getSdp() {\r\n        this._sdpObject.origin.sessionVersion++;\r\n        return sdpTransform.write(this._sdpObject);\r\n    }\r\n    _addMediaSection(newMediaSection) {\r\n        if (!this._firstMid)\r\n            this._firstMid = newMediaSection.mid;\r\n        this._mediaSections.push(newMediaSection);\r\n        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);\r\n        this._sdpObject.media.push(newMediaSection.getObject());\r\n        this._regenerateBundleMids();\r\n    }\r\n    _replaceMediaSection(newMediaSection, reuseMid) {\r\n        if (typeof reuseMid === 'string') {\r\n            const idx = this._midToIndex.get(reuseMid);\r\n            if (idx === undefined) {\r\n                throw new Error(`no media section found for reuseMid '${reuseMid}'`);\r\n            }\r\n            const oldMediaSection = this._mediaSections[idx];\r\n            this._mediaSections[idx] = newMediaSection;\r\n            this._midToIndex.delete(oldMediaSection.mid);\r\n            this._midToIndex.set(newMediaSection.mid, idx);\r\n            this._sdpObject.media[idx] = newMediaSection.getObject();\r\n            this._regenerateBundleMids();\r\n        }\r\n        else {\r\n            const idx = this._midToIndex.get(newMediaSection.mid);\r\n            if (idx === undefined) {\r\n                throw new Error(`no media section found with mid '${newMediaSection.mid}'`);\r\n            }\r\n            this._mediaSections[idx] = newMediaSection;\r\n            this._sdpObject.media[idx] = newMediaSection.getObject();\r\n        }\r\n    }\r\n    _regenerateBundleMids() {\r\n        if (!this._dtlsParameters)\r\n            return;\r\n        this._sdpObject.groups[0].mids = this._mediaSections\r\n            .filter((mediaSection) => !mediaSection.closed)\r\n            .map((mediaSection) => mediaSection.mid)\r\n            .join(' ');\r\n    }\r\n}\r\nexports.RemoteSdp = RemoteSdp;\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/RemoteSdp.ts?");

/***/ }),

/***/ "./src/handlers/sdp/commonUtils.ts":
/*!*****************************************!*\
  !*** ./src/handlers/sdp/commonUtils.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sdpTransform = __importStar(__webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\"));\r\nfunction extractRtpCapabilities({ sdpObject }) {\r\n    const codecsMap = new Map();\r\n    const headerExtensions = [];\r\n    let gotAudio = false;\r\n    let gotVideo = false;\r\n    for (const m of sdpObject.media) {\r\n        const kind = m.type;\r\n        switch (kind) {\r\n            case 'audio':\r\n                {\r\n                    if (gotAudio)\r\n                        continue;\r\n                    gotAudio = true;\r\n                    break;\r\n                }\r\n            case 'video':\r\n                {\r\n                    if (gotVideo)\r\n                        continue;\r\n                    gotVideo = true;\r\n                    break;\r\n                }\r\n            default:\r\n                {\r\n                    continue;\r\n                }\r\n        }\r\n        for (const rtp of m.rtp) {\r\n            const codec = {\r\n                kind: kind,\r\n                mimeType: `${kind}/${rtp.codec}`,\r\n                preferredPayloadType: rtp.payload,\r\n                clockRate: rtp.rate,\r\n                channels: rtp.encoding,\r\n                parameters: {},\r\n                rtcpFeedback: []\r\n            };\r\n            codecsMap.set(codec.preferredPayloadType, codec);\r\n        }\r\n        for (const fmtp of m.fmtp || []) {\r\n            const parameters = sdpTransform.parseParams(fmtp.config);\r\n            const codec = codecsMap.get(fmtp.payload);\r\n            if (!codec)\r\n                continue;\r\n            if (parameters && parameters['profile-level-id'])\r\n                parameters['profile-level-id'] = String(parameters['profile-level-id']);\r\n            codec.parameters = parameters;\r\n        }\r\n        for (const fb of m.rtcpFb || []) {\r\n            const codec = codecsMap.get(fb.payload);\r\n            if (!codec)\r\n                continue;\r\n            const feedback = {\r\n                type: fb.type,\r\n                parameter: fb.subtype\r\n            };\r\n            if (!feedback.parameter)\r\n                delete feedback.parameter;\r\n            codec.rtcpFeedback.push(feedback);\r\n        }\r\n        for (const ext of m.ext || []) {\r\n            if (ext['encrypt-uri'])\r\n                continue;\r\n            const headerExtension = {\r\n                kind: kind,\r\n                uri: ext.uri,\r\n                preferredId: ext.value\r\n            };\r\n            headerExtensions.push(headerExtension);\r\n        }\r\n    }\r\n    const rtpCapabilities = {\r\n        codecs: Array.from(codecsMap.values()),\r\n        headerExtensions: headerExtensions\r\n    };\r\n    return rtpCapabilities;\r\n}\r\nexports.extractRtpCapabilities = extractRtpCapabilities;\r\nfunction extractDtlsParameters({ sdpObject }) {\r\n    const mediaObject = (sdpObject.media || [])\r\n        .find((m) => (m.iceUfrag && m.port !== 0));\r\n    if (!mediaObject)\r\n        throw new Error('no active media section found');\r\n    const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\r\n    let role;\r\n    switch (mediaObject.setup) {\r\n        case 'active':\r\n            role = 'client';\r\n            break;\r\n        case 'passive':\r\n            role = 'server';\r\n            break;\r\n        case 'actpass':\r\n            role = 'auto';\r\n            break;\r\n    }\r\n    const dtlsParameters = {\r\n        role,\r\n        fingerprints: [\r\n            {\r\n                algorithm: fingerprint.type,\r\n                value: fingerprint.hash\r\n            }\r\n        ]\r\n    };\r\n    return dtlsParameters;\r\n}\r\nexports.extractDtlsParameters = extractDtlsParameters;\r\nfunction getCname({ offerMediaObject }) {\r\n    const ssrcCnameLine = (offerMediaObject.ssrcs || [])\r\n        .find((line) => line.attribute === 'cname');\r\n    if (!ssrcCnameLine)\r\n        return '';\r\n    return ssrcCnameLine.value;\r\n}\r\nexports.getCname = getCname;\r\nfunction applyCodecParameters({ offerRtpParameters, answerMediaObject }) {\r\n    for (const codec of offerRtpParameters.codecs) {\r\n        const mimeType = codec.mimeType.toLowerCase();\r\n        if (mimeType !== 'audio/opus')\r\n            continue;\r\n        const rtp = (answerMediaObject.rtp || [])\r\n            .find((r) => r.payload === codec.payloadType);\r\n        if (!rtp)\r\n            continue;\r\n        answerMediaObject.fmtp = answerMediaObject.fmtp || [];\r\n        let fmtp = answerMediaObject.fmtp\r\n            .find((f) => f.payload === codec.payloadType);\r\n        if (!fmtp) {\r\n            fmtp = { payload: codec.payloadType, config: '' };\r\n            answerMediaObject.fmtp.push(fmtp);\r\n        }\r\n        const parameters = sdpTransform.parseParams(fmtp.config);\r\n        switch (mimeType) {\r\n            case 'audio/opus':\r\n                {\r\n                    const spropStereo = codec.parameters['sprop-stereo'];\r\n                    if (spropStereo !== undefined)\r\n                        parameters.stereo = spropStereo ? 1 : 0;\r\n                    break;\r\n                }\r\n        }\r\n        fmtp.config = '';\r\n        for (const key of Object.keys(parameters)) {\r\n            if (fmtp.config)\r\n                fmtp.config += ';';\r\n            fmtp.config += `${key}=${parameters[key]}`;\r\n        }\r\n    }\r\n}\r\nexports.applyCodecParameters = applyCodecParameters;\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/commonUtils.ts?");

/***/ }),

/***/ "./src/handlers/sdp/planBUtils.ts":
/*!****************************************!*\
  !*** ./src/handlers/sdp/planBUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getRtpEncodings({ offerMediaObject, track }) {\r\n    let firstSsrc;\r\n    const ssrcs = new Set();\r\n    for (const line of offerMediaObject.ssrcs || []) {\r\n        if (line.attribute !== 'msid')\r\n            continue;\r\n        const trackId = line.value.split(' ')[1];\r\n        if (trackId === track.id) {\r\n            const ssrc = line.id;\r\n            ssrcs.add(ssrc);\r\n            if (!firstSsrc)\r\n                firstSsrc = ssrc;\r\n        }\r\n    }\r\n    if (ssrcs.size === 0)\r\n        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);\r\n    const ssrcToRtxSsrc = new Map();\r\n    for (const line of offerMediaObject.ssrcGroups || []) {\r\n        if (line.semantics !== 'FID')\r\n            continue;\r\n        let [ssrc, rtxSsrc] = line.ssrcs.split(/\\s+/);\r\n        ssrc = Number(ssrc);\r\n        rtxSsrc = Number(rtxSsrc);\r\n        if (ssrcs.has(ssrc)) {\r\n            ssrcs.delete(ssrc);\r\n            ssrcs.delete(rtxSsrc);\r\n            ssrcToRtxSsrc.set(ssrc, rtxSsrc);\r\n        }\r\n    }\r\n    for (const ssrc of ssrcs) {\r\n        ssrcToRtxSsrc.set(ssrc, null);\r\n    }\r\n    const encodings = [];\r\n    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {\r\n        const encoding = { ssrc };\r\n        if (rtxSsrc)\r\n            encoding.rtx = { ssrc: rtxSsrc };\r\n        encodings.push(encoding);\r\n    }\r\n    return encodings;\r\n}\r\nexports.getRtpEncodings = getRtpEncodings;\r\nfunction addLegacySimulcast({ offerMediaObject, track, numStreams }) {\r\n    if (numStreams <= 1)\r\n        throw new TypeError('numStreams must be greater than 1');\r\n    let firstSsrc;\r\n    let firstRtxSsrc;\r\n    let streamId;\r\n    const ssrcMsidLine = (offerMediaObject.ssrcs || [])\r\n        .find((line) => {\r\n        if (line.attribute !== 'msid')\r\n            return false;\r\n        const trackId = line.value.split(' ')[1];\r\n        if (trackId === track.id) {\r\n            firstSsrc = line.id;\r\n            streamId = line.value.split(' ')[0];\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    });\r\n    if (!ssrcMsidLine)\r\n        throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);\r\n    (offerMediaObject.ssrcGroups || [])\r\n        .some((line) => {\r\n        if (line.semantics !== 'FID')\r\n            return false;\r\n        const ssrcs = line.ssrcs.split(/\\s+/);\r\n        if (Number(ssrcs[0]) === firstSsrc) {\r\n            firstRtxSsrc = Number(ssrcs[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    });\r\n    const ssrcCnameLine = offerMediaObject.ssrcs\r\n        .find((line) => (line.attribute === 'cname' && line.id === firstSsrc));\r\n    if (!ssrcCnameLine)\r\n        throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);\r\n    const cname = ssrcCnameLine.value;\r\n    const ssrcs = [];\r\n    const rtxSsrcs = [];\r\n    for (let i = 0; i < numStreams; ++i) {\r\n        ssrcs.push(firstSsrc + i);\r\n        if (firstRtxSsrc)\r\n            rtxSsrcs.push(firstRtxSsrc + i);\r\n    }\r\n    offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];\r\n    offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];\r\n    offerMediaObject.ssrcGroups.push({\r\n        semantics: 'SIM',\r\n        ssrcs: ssrcs.join(' ')\r\n    });\r\n    for (let i = 0; i < ssrcs.length; ++i) {\r\n        const ssrc = ssrcs[i];\r\n        offerMediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'cname',\r\n            value: cname\r\n        });\r\n        offerMediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'msid',\r\n            value: `${streamId} ${track.id}`\r\n        });\r\n    }\r\n    for (let i = 0; i < rtxSsrcs.length; ++i) {\r\n        const ssrc = ssrcs[i];\r\n        const rtxSsrc = rtxSsrcs[i];\r\n        offerMediaObject.ssrcs.push({\r\n            id: rtxSsrc,\r\n            attribute: 'cname',\r\n            value: cname\r\n        });\r\n        offerMediaObject.ssrcs.push({\r\n            id: rtxSsrc,\r\n            attribute: 'msid',\r\n            value: `${streamId} ${track.id}`\r\n        });\r\n        offerMediaObject.ssrcGroups.push({\r\n            semantics: 'FID',\r\n            ssrcs: `${ssrc} ${rtxSsrc}`\r\n        });\r\n    }\r\n}\r\nexports.addLegacySimulcast = addLegacySimulcast;\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/planBUtils.ts?");

/***/ }),

/***/ "./src/handlers/sdp/unifiedPlanUtils.ts":
/*!**********************************************!*\
  !*** ./src/handlers/sdp/unifiedPlanUtils.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getRtpEncodings({ offerMediaObject }) {\r\n    const ssrcs = new Set();\r\n    for (const line of offerMediaObject.ssrcs || []) {\r\n        const ssrc = line.id;\r\n        ssrcs.add(ssrc);\r\n    }\r\n    if (ssrcs.size === 0)\r\n        throw new Error('no a=ssrc lines found');\r\n    const ssrcToRtxSsrc = new Map();\r\n    for (const line of offerMediaObject.ssrcGroups || []) {\r\n        if (line.semantics !== 'FID')\r\n            continue;\r\n        let [ssrc, rtxSsrc] = line.ssrcs.split(/\\s+/);\r\n        ssrc = Number(ssrc);\r\n        rtxSsrc = Number(rtxSsrc);\r\n        if (ssrcs.has(ssrc)) {\r\n            ssrcs.delete(ssrc);\r\n            ssrcs.delete(rtxSsrc);\r\n            ssrcToRtxSsrc.set(ssrc, rtxSsrc);\r\n        }\r\n    }\r\n    for (const ssrc of ssrcs) {\r\n        ssrcToRtxSsrc.set(ssrc, null);\r\n    }\r\n    const encodings = [];\r\n    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {\r\n        const encoding = { ssrc };\r\n        if (rtxSsrc)\r\n            encoding.rtx = { ssrc: rtxSsrc };\r\n        encodings.push(encoding);\r\n    }\r\n    return encodings;\r\n}\r\nexports.getRtpEncodings = getRtpEncodings;\r\nfunction addLegacySimulcast({ offerMediaObject, numStreams }) {\r\n    if (numStreams <= 1)\r\n        throw new TypeError('numStreams must be greater than 1');\r\n    const ssrcMsidLine = (offerMediaObject.ssrcs || [])\r\n        .find((line) => line.attribute === 'msid');\r\n    if (!ssrcMsidLine)\r\n        throw new Error('a=ssrc line with msid information not found');\r\n    const [streamId, trackId] = ssrcMsidLine.value.split(' ')[0];\r\n    const firstSsrc = ssrcMsidLine.id;\r\n    let firstRtxSsrc;\r\n    (offerMediaObject.ssrcGroups || [])\r\n        .some((line) => {\r\n        if (line.semantics !== 'FID')\r\n            return false;\r\n        const ssrcs = line.ssrcs.split(/\\s+/);\r\n        if (Number(ssrcs[0]) === firstSsrc) {\r\n            firstRtxSsrc = Number(ssrcs[1]);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    });\r\n    const ssrcCnameLine = offerMediaObject.ssrcs\r\n        .find((line) => line.attribute === 'cname');\r\n    if (!ssrcCnameLine)\r\n        throw new Error('a=ssrc line with cname information not found');\r\n    const cname = ssrcCnameLine.value;\r\n    const ssrcs = [];\r\n    const rtxSsrcs = [];\r\n    for (let i = 0; i < numStreams; ++i) {\r\n        ssrcs.push(firstSsrc + i);\r\n        if (firstRtxSsrc)\r\n            rtxSsrcs.push(firstRtxSsrc + i);\r\n    }\r\n    offerMediaObject.ssrcGroups = [];\r\n    offerMediaObject.ssrcs = [];\r\n    offerMediaObject.ssrcGroups.push({\r\n        semantics: 'SIM',\r\n        ssrcs: ssrcs.join(' ')\r\n    });\r\n    for (let i = 0; i < ssrcs.length; ++i) {\r\n        const ssrc = ssrcs[i];\r\n        offerMediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'cname',\r\n            value: cname\r\n        });\r\n        offerMediaObject.ssrcs.push({\r\n            id: ssrc,\r\n            attribute: 'msid',\r\n            value: `${streamId} ${trackId}`\r\n        });\r\n    }\r\n    for (let i = 0; i < rtxSsrcs.length; ++i) {\r\n        const ssrc = ssrcs[i];\r\n        const rtxSsrc = rtxSsrcs[i];\r\n        offerMediaObject.ssrcs.push({\r\n            id: rtxSsrc,\r\n            attribute: 'cname',\r\n            value: cname\r\n        });\r\n        offerMediaObject.ssrcs.push({\r\n            id: rtxSsrc,\r\n            attribute: 'msid',\r\n            value: `${streamId} ${trackId}`\r\n        });\r\n        offerMediaObject.ssrcGroups.push({\r\n            semantics: 'FID',\r\n            ssrcs: `${ssrc} ${rtxSsrc}`\r\n        });\r\n    }\r\n}\r\nexports.addLegacySimulcast = addLegacySimulcast;\r\n\n\n//# sourceURL=webpack:///./src/handlers/sdp/unifiedPlanUtils.ts?");

/***/ }),

/***/ "./src/mcs8Client.ts":
/*!***************************!*\
  !*** ./src/mcs8Client.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst protoo_client_1 = __importDefault(__webpack_require__(/*! protoo-client */ \"./node_modules/protoo-client/lib/index.js\"));\r\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\r\nconst blueimp_md5_1 = __importDefault(__webpack_require__(/*! blueimp-md5 */ \"./node_modules/blueimp-md5/js/md5.js\"));\r\nconst mediaClient_1 = __webpack_require__(/*! ./mediaClient */ \"./src/mediaClient.ts\");\r\nclass mcs8Client extends events_1.EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this._mediaClientList = new Map();\r\n    }\r\n    connect(setting) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._setting = setting;\r\n            let md5Pwd = blueimp_md5_1.default(this._setting.pwd);\r\n            let baseUrl = 'ws://';\r\n            if (this._setting.ssl == true) {\r\n                baseUrl = 'wss://';\r\n                this._setting.ssl = true;\r\n            }\r\n            if (baseUrl == 'ws://') {\r\n                if (window.location.protocol.indexOf(\"https\") != -1) {\r\n                    baseUrl = 'wss://';\r\n                    this._setting.ssl = true;\r\n                }\r\n            }\r\n            let _protooUrl = baseUrl + this._setting.host + ':' + this._setting.port + '?uid=' + this._setting.uid + '&pwd=' + md5Pwd + '&type=1';\r\n            const protooTransport = new protoo_client_1.default.WebSocketTransport(_protooUrl);\r\n            this._protoo = new protoo_client_1.default.Peer(protooTransport);\r\n            this._protoo.on('open', () => {\r\n                const _req = { request: true, errCode: 200, method: \"responseConnectGateway\", data: { ip: this._setting.host, port: this._setting.port } };\r\n                this.emit('OnManage', _req);\r\n                console.log('geteway:opened');\r\n            });\r\n            this._protoo.on('failed', () => {\r\n                const _req = { request: true, errCode: 502, method: \"responseConnectGateway\", data: { ip: this._setting.host, port: this._setting.port } };\r\n                this.emit('OnManage', _req);\r\n                console.log('geteway:failed');\r\n            });\r\n            this._protoo.on('disconnected', () => {\r\n                const _req = { request: true, errCode: 401, method: \"responseConnectGateway\", data: { ip: this._setting.host, port: this._setting.port } };\r\n                this.emit('OnManage', _req);\r\n                console.log('geteway:disconnected');\r\n            });\r\n            this._protoo.on('close', () => {\r\n                const _req = { request: true, errCode: 500, method: \"responseConnectGateway\", data: { ip: this._setting.host, port: this._setting.port } };\r\n                this.emit('OnManage', _req);\r\n                if (this._closed)\r\n                    return;\r\n                console.log('geteway:close');\r\n            });\r\n            this._protoo.on('request', (request, accept, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                this.onServerResponse(request, accept, reject);\r\n            }));\r\n            this._protoo.on('notification', (request, accept, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                this.onServerResponse(request, accept, reject);\r\n            }));\r\n        });\r\n    }\r\n    onServerResponse(request, accept, reject) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            console.log('proto \"request\" event [method:%s, data:%o]', request.method, request.data);\r\n            if (request.request == true) {\r\n                accept();\r\n            }\r\n            switch (request.method) {\r\n                case 'ConnecteInfo':\r\n                    {\r\n                        this._loginInfo = request.data;\r\n                        const connParam = { groupId: 'mcs8_admin', talkGroupType: TalkGroupType.none, temGroupType: TalkGroupType.VideoMonitoring_consumer, isCreator: 0, appdata: null };\r\n                        this.add2MediaGroup(connParam);\r\n                    }\r\n                    this.emit('OnManage', request);\r\n                    break;\r\n                default:\r\n                    const _req = { request: true, errCode: 200, method: request.method, \"data\": request.data };\r\n                    this.emit('OnManage', _req);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    add2MediaGroup({ groupId, talkGroupType, temGroupType, isCreator, appdata, istalk = false, did = '', devMeeting = false }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null || groupId == '') {\r\n                return 400;\r\n            }\r\n            const _client = this._mediaClientList.get(groupId);\r\n            if (_client != null) {\r\n                yield _client.close();\r\n            }\r\n            let _mediaPort = this._loginInfo.mediaPort;\r\n            let mediaIp = this._loginInfo.mediaIp;\r\n            if (this._setting.ssl == true) {\r\n                _mediaPort = this._loginInfo.mediaSslPort;\r\n                mediaIp = this._loginInfo.mediaDomain;\r\n            }\r\n            const serverInfo = {\r\n                mediaIp: mediaIp,\r\n                mediaPort: _mediaPort,\r\n                token: this._loginInfo.token,\r\n                ssl: this._setting.ssl,\r\n                rid: groupId,\r\n                userType: istalk == true ? 4 : this._loginInfo.userType,\r\n                did: this._loginInfo.devid,\r\n                talkGroupType,\r\n                temGroupType,\r\n                isCreator,\r\n                setting: this._setting,\r\n                appdata,\r\n                istalk,\r\n                devMeeting\r\n            };\r\n            const mediaClient = new mediaClient_1.mcs8MediaClient();\r\n            mediaClient.on('OnManage', (request) => __awaiter(this, void 0, void 0, function* () {\r\n                this.emit('OnManage', request);\r\n                switch (request.method) {\r\n                    case 'joinRoom':\r\n                        {\r\n                        }\r\n                        break;\r\n                    case 'connectTransport':\r\n                        {\r\n                        }\r\n                    case 'produce':\r\n                        if (mediaClient._isSendJoinRoomAndProduct == false) {\r\n                            if (serverInfo.isCreator == 1) {\r\n                                let destDevList = [];\r\n                                for (const devMoel of serverInfo.appdata) {\r\n                                    destDevList.push(devMoel.devId);\r\n                                }\r\n                                destDevList = yield this.DevListUnique(destDevList);\r\n                                const joinRoomParam = {\r\n                                    roomId: serverInfo.rid,\r\n                                    TalkGroupType: serverInfo.talkGroupType,\r\n                                    creatorId: this._loginInfo.devid,\r\n                                    devList: destDevList\r\n                                };\r\n                                this.requestMsg2GatewayServer('JoinRoomAndProduct', joinRoomParam);\r\n                                mediaClient._isSendJoinRoomAndProduct = true;\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n                console.log(JSON.stringify(request));\r\n            }));\r\n            this._mediaClientList.set(serverInfo.rid, mediaClient);\r\n            mediaClient.connectMedia(serverInfo, false);\r\n            return mediaClient;\r\n        });\r\n    }\r\n    DevListUnique(arr) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let newArr = [arr[0]];\r\n            for (let i = 1; i < arr.length; i++) {\r\n                let repeat = false;\r\n                for (let j = 0; j < newArr.length; j++) {\r\n                    if (arr[i] === newArr[j]) {\r\n                        repeat = true;\r\n                        break;\r\n                    }\r\n                    else {\r\n                    }\r\n                }\r\n                if (!repeat) {\r\n                    newArr.push(arr[i]);\r\n                }\r\n            }\r\n            return newArr;\r\n        });\r\n    }\r\n    joinMediaGroup(roomId, talkGroupType, devList) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const connParam = { groupId: roomId, talkGroupType: talkGroupType, temGroupType: TemGroupType.Group, isCreator: 0, appdata: devList };\r\n            yield this.add2MediaGroup(connParam);\r\n            if (devList != null) {\r\n                for (const devModel of devList) {\r\n                    if (devModel.devId != this._setting.uid) {\r\n                        var ShowObject = { groupId: roomId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n                        this.addShowObject(ShowObject);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    CreateTempMediaGroup(groupId, groupType, devList) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            if (groupType != 4 && groupType != 5 && groupType != 6) {\r\n                return 400;\r\n            }\r\n            const result = yield this.checkInputDevice(groupType);\r\n            if (result != 200) {\r\n                return result;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: groupType, temGroupType: TemGroupType.Group, isCreator: 1, appdata: devList };\r\n            yield this.add2MediaGroup(connParam);\r\n            if (devList != null) {\r\n                for (const devModel of devList) {\r\n                    var ShowObject = { groupId: groupId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n                    this.addShowObject(ShowObject);\r\n                }\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    CreateP2pMediaGroup(groupId, groupType, devModel) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            if (groupType != 4 && groupType != 5 && groupType != 6) {\r\n                return 400;\r\n            }\r\n            const result = yield this.checkInputDevice(groupType);\r\n            if (result != 200) {\r\n                return result;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: groupType, temGroupType: TemGroupType.p2p, isCreator: 1, appdata: [devModel] };\r\n            yield this.add2MediaGroup(connParam);\r\n            var ShowObject = { groupId: groupId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n            this.addShowObject(ShowObject);\r\n            return 200;\r\n        });\r\n    }\r\n    CreateDevMeeting(groupId, groupType, devList) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            const result = yield this.checkInputDevice(groupType);\r\n            if (result != 200) {\r\n                return result;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: groupType, temGroupType: TemGroupType.Group, isCreator: 1, appdata: devList, devMeeting: true };\r\n            yield this.add2MediaGroup(connParam);\r\n            if (devList != null) {\r\n                for (const devModel of devList) {\r\n                    var ShowObject = { groupId: groupId, devId: devModel.devId, kind: devModel.kind, showObj: devModel.showObj };\r\n                    this.addShowObject(ShowObject);\r\n                }\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    checkInputDevice(groupType) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const InputVideoAudio = yield this.GetAudioAndVideo();\r\n            if (groupType == 5) {\r\n                if (InputVideoAudio.videoinput == false && InputVideoAudio.audioinput == false) {\r\n                    const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { devices: InputVideoAudio, content: \"Input device not found\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return 404;\r\n                }\r\n            }\r\n            else {\r\n                if (InputVideoAudio.audioinput == false) {\r\n                    const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { devices: InputVideoAudio, content: \"Input device not found\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return 404;\r\n                }\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    GetAudioAndVideo() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const resultModel = { videoinput: false, audioinput: false, audiooutput: false };\r\n            if (navigator.mediaDevices != null) {\r\n                const mediadevList = yield navigator.mediaDevices.enumerateDevices();\r\n                for (const omediadev of mediadevList) {\r\n                    if (omediadev.kind == 'audioinput') {\r\n                        resultModel.audioinput = true;\r\n                    }\r\n                    if (omediadev.kind == 'audiooutput') {\r\n                        resultModel.audiooutput = true;\r\n                    }\r\n                    if (omediadev.kind == 'videoinput') {\r\n                        resultModel.videoinput = true;\r\n                    }\r\n                }\r\n            }\r\n            return resultModel;\r\n        });\r\n    }\r\n    openDeviceTalk(devId, groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.setDeviceTalk(devId, groupId, false);\r\n        });\r\n    }\r\n    closeDeviceTalk(devId, groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.setDeviceTalk(devId, groupId, true);\r\n        });\r\n    }\r\n    setDeviceTalk(devId, groupId, isPause) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let resultModel = { errorCode: 500, content: '', talkId: '' };\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                resultModel.errorCode = 404;\r\n                resultModel.content = 'can not found ' + groupId;\r\n                return resultModel;\r\n            }\r\n            const requestParam = { devId, kind: 'audio', isPause, talkId: this._loginInfo.devid };\r\n            const result = yield mediaClient.requestMsg('setDevMediaConsumer', requestParam);\r\n            resultModel.errorCode = result.errorCode;\r\n            resultModel.talkId = resultModel.talkId;\r\n            return resultModel;\r\n        });\r\n    }\r\n    startTalk(devId, groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null || groupId == '') {\r\n                const roomModel = yield this.requestMsg2GatewayServer('getRoomIdByDevId', { devId });\r\n                if (roomModel == null) {\r\n                    return 400;\r\n                }\r\n                groupId = roomModel.roomId;\r\n            }\r\n            if (groupId == null) {\r\n                return 400;\r\n            }\r\n            if (groupId == '') {\r\n                return 400;\r\n            }\r\n            const connParam = { groupId: groupId, talkGroupType: 3, temGroupType: 0, isCreator: 0, appdata: [devId], istalk: true, did: devId };\r\n            yield this.add2MediaGroup(connParam);\r\n            return 200;\r\n        });\r\n    }\r\n    stopTalk(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (groupId == null || groupId == '') {\r\n                let resultError = 404;\r\n                for (const mediaClient of this._mediaClientList.values()) {\r\n                    if (mediaClient._loginInfo.istalk == true) {\r\n                        yield mediaClient.close();\r\n                        resultError = 200;\r\n                    }\r\n                }\r\n                return resultError;\r\n            }\r\n            else {\r\n                return yield this.closeGroup(groupId);\r\n            }\r\n        });\r\n    }\r\n    openVideo(_devId, _showObj, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                const connParam = { groupId: 'mcs8_admin', talkGroupType: TalkGroupType.none, temGroupType: TalkGroupType.VideoMonitoring_consumer, isCreator: 0, appdata: null };\r\n                mediaClient = yield this.add2MediaGroup(connParam);\r\n            }\r\n            if (mediaClient == null) {\r\n                return 500;\r\n            }\r\n            var chanId = channelId;\r\n            if (chanId == null) {\r\n                chanId = \"\";\r\n            }\r\n            const param = { kind: 'video', devId: _devId, streamType: 2, showObj: _showObj, channelId: chanId };\r\n            return yield mediaClient.openVideo(param);\r\n        });\r\n    }\r\n    closeVideo(_devId, channelId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            var chanId = channelId;\r\n            if (chanId == null) {\r\n                chanId = \"\";\r\n            }\r\n            const param = { kind: 'video', devId: _devId, streamType: 2, channelId: chanId };\r\n            return yield mediaClient.stopVideo(param);\r\n        });\r\n    }\r\n    openAudio(_devId, _showObj) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const param = { kind: 'audio', devId: _devId, streamType: 0, showObj: _showObj };\r\n            return yield mediaClient.openVideo(param);\r\n        });\r\n    }\r\n    closeAudio(_devId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient('mcs8_admin');\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const param = { kind: 'audio', devId: _devId, streamType: 0 };\r\n            return yield mediaClient.stopVideo(param);\r\n        });\r\n    }\r\n    startSendVideo(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const sendMedioObj = { kind: 'video', streamType: 2, showObj: this._setting.localVideo, stream: null };\r\n            return mediaClient.sendMedia(sendMedioObj);\r\n        });\r\n    }\r\n    stopSendVideo(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            return mediaClient.closeSendMdia('video');\r\n        });\r\n    }\r\n    startSendAudio(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            const sendMedioObj = { kind: 'audio', streamType: 0, showObj: this._setting.localVideo, stream: null };\r\n            return mediaClient.sendMedia(sendMedioObj);\r\n        });\r\n    }\r\n    stopSendAudio(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            return mediaClient.closeSendMdia('audio');\r\n        });\r\n    }\r\n    applyTalk(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = yield this.requestMsg2MediaServer(groupId, 'applyTalk', null);\r\n            if (result.status == 1) {\r\n                let mediaClient = yield this.getMediaClient(groupId);\r\n                if (mediaClient != null) {\r\n                    mediaClient.resume('audio');\r\n                }\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    pause(groupId, kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient != null) {\r\n                mediaClient.pause(kind);\r\n            }\r\n        });\r\n    }\r\n    resume(groupId, kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient != null) {\r\n                mediaClient.resume(kind);\r\n            }\r\n        });\r\n    }\r\n    freeTalker(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = this.requestMsg2MediaServer(groupId, 'freeTalker', null);\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient != null) {\r\n                mediaClient.pause('audio');\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    addShowObject({ groupId, devId, kind, showObj }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            mediaClient.addShowObject({ groupId, devId, kind, showObj });\r\n            return 200;\r\n        });\r\n    }\r\n    requestMsg2GatewayServer(method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._protoo == null) {\r\n                return 500;\r\n            }\r\n            return yield this._protoo.request(method, data);\r\n        });\r\n    }\r\n    notifyMsg2GatewayServer(method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._protoo.request == null) {\r\n                return 500;\r\n            }\r\n            this._protoo.notify(method, data);\r\n            return 200;\r\n        });\r\n    }\r\n    requestMsg2MediaServer(groupId, method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            return mediaClient.requestMsg(method, data);\r\n        });\r\n    }\r\n    notifyMsg2MediaServer(groupId, method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let mediaClient = yield this.getMediaClient(groupId);\r\n            if (mediaClient == null) {\r\n                return 404;\r\n            }\r\n            return mediaClient.notifyMsg(method, data);\r\n        });\r\n    }\r\n    getMediaClient(GroupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let meidaClient = this._mediaClientList.get(GroupId);\r\n            return meidaClient;\r\n        });\r\n    }\r\n    closeGroup(groupId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const meidaClient = yield this.getMediaClient(groupId);\r\n                if (meidaClient == null) {\r\n                    return 404;\r\n                }\r\n                yield meidaClient.close();\r\n                return 200;\r\n            }\r\n            catch (ex) {\r\n            }\r\n            return 500;\r\n        });\r\n    }\r\n    close() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            for (const key of this._mediaClientList.keys()) {\r\n                yield this.closeGroup(key);\r\n            }\r\n            if (this._protoo != null) {\r\n                yield this._protoo.close();\r\n            }\r\n        });\r\n    }\r\n    setLocalVideoOrAudioObject({ localVideo, localAudio, groupId }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (localAudio != null) {\r\n                this._setting.localVideo = localVideo;\r\n            }\r\n            if (localVideo != null) {\r\n                this._setting.localAudio = localAudio;\r\n            }\r\n            if (groupId != null) {\r\n                let meidaClient = yield this.getMediaClient(groupId);\r\n                if (meidaClient != null) {\r\n                    meidaClient.setLocalVideoOrAudioObject({ localVideo, localAudio });\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.mcs8Client = mcs8Client;\r\nconst TemGroupType = {\r\n    none: 0,\r\n    p2p: 1,\r\n    Group: 2\r\n};\r\nconst TalkGroupType = {\r\n    none: 0,\r\n    Company: 1,\r\n    DevGroup: 3,\r\n    AudioDispatch: 4,\r\n    VideoDispatch: 5,\r\n    AudioTalk: 6,\r\n    VideoMonitoring_procuct: 7,\r\n    AudioMonitoring_product: 8,\r\n    VideoMonitoring_consumer: 9,\r\n    AudioMonitoring_consumer: 10,\r\n};\r\n\n\n//# sourceURL=webpack:///./src/mcs8Client.ts?");

/***/ }),

/***/ "./src/mediaClient.ts":
/*!****************************!*\
  !*** ./src/mediaClient.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Device_1 = __webpack_require__(/*! ./Device */ \"./src/Device.ts\");\r\nconst Logger_1 = __webpack_require__(/*! ./Logger */ \"./src/Logger.ts\");\r\nconst protoo_client_1 = __importDefault(__webpack_require__(/*! protoo-client */ \"./node_modules/protoo-client/lib/index.js\"));\r\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\r\nconst logger = new Logger_1.Logger('mcs8MediaClient');\r\nclass mcs8MediaClient extends events_1.EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this._device = new Device_1.Device();\r\n        this._isSendJoinRoomAndProduct = false;\r\n        this._consumerList = new Map();\r\n        this._showVideoList = new Map();\r\n        this._showAudioList = new Map();\r\n        this._sendMediaList = new Map();\r\n    }\r\n    connectMedia(_serverInfo, isSubTalk) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._loginInfo = _serverInfo;\r\n            let baseUrl = 'ws://';\r\n            if (_serverInfo.ssl == true) {\r\n                baseUrl = 'wss://';\r\n            }\r\n            let _userType = _serverInfo.userType;\r\n            let talkGroupType = _serverInfo.talkGroupType;\r\n            if (_serverInfo.devMeeting == true) {\r\n                talkGroupType = 11;\r\n            }\r\n            let url = baseUrl + _serverInfo.mediaIp + ':' + _serverInfo.mediaPort + '/?token=' + _serverInfo.token + '&did=' + _serverInfo.did + '&rid=' + _serverInfo.rid + '&t=' + _userType + '&ct=' + _serverInfo.temGroupType + '&gt=' + talkGroupType + '&o=' + _serverInfo.isCreator;\r\n            const protooTransport = new protoo_client_1.default.WebSocketTransport(url);\r\n            this._protoo = new protoo_client_1.default.Peer(protooTransport);\r\n            this._protoo.on('open', () => __awaiter(this, void 0, void 0, function* () {\r\n                const routerRtpCapabilities = yield this._protoo.request('getRouterRtpCapabilities', { roomId: _serverInfo.rid });\r\n                yield this._device.load({ routerRtpCapabilities });\r\n                const _req = { request: true, errCode: 200, method: \"responseConnectMedia\", data: { ip: _serverInfo.mediaIp, port: _serverInfo.mediaPort } };\r\n                this.emit('OnManage', _req);\r\n                if (this._device == null) {\r\n                    const _reqJoin = { request: true, errCode: 400, method: \"loadRtpCapabilities\", data: { content: \"Inload server error\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return;\r\n                }\r\n                const localRtpCapabilitie = yield this._device.getNativeRtpCapabilities();\r\n                this.emit('OnManage', { request: true, errCode: 200, method: \"localRtpCapabilitie\", data: localRtpCapabilitie });\r\n                const { rtpCapabilities } = this._device;\r\n                this.emit('OnManage', { request: true, errCode: 200, method: \"rtpCapabilities\", data: rtpCapabilities });\r\n                if (isSubTalk != true) {\r\n                    yield this.createConsumer();\r\n                }\r\n                const joinRoomParam = { displayName: 'browser', device: { flag: this._device._handlerName, name: this._device._handlerName, version: \"78.0.3904.97\" }, rtpCapabilities };\r\n                const joinroomResult = yield this._protoo.request('join', joinRoomParam);\r\n                const _reqJoin = { request: true, errCode: 200, method: \"joinRoom\", data: joinroomResult };\r\n                this.emit('OnManage', _reqJoin);\r\n                if (this._loginInfo.rid != 'mcs8_admin') {\r\n                    let _LocalTransport = yield this.createProduct();\r\n                    if (_LocalTransport != null) {\r\n                        const productParam = { kind: 'audio', streamType: 0, showObj: this._loginInfo.setting.localAudio };\r\n                        switch (_serverInfo.talkGroupType) {\r\n                            case 3:\r\n                            case 4:\r\n                                {\r\n                                    const result = yield this.sendMedia(productParam);\r\n                                    if (result == 200 && this._audioProduct != null) {\r\n                                        if (this._loginInfo.istalk == true) {\r\n                                            const { errorCode } = yield this.requestMsg('canSubTalk', { devId: _serverInfo.appdata[0] });\r\n                                            if (errorCode == 200) {\r\n                                                this.requestMsg('setSubTalk', { peerId: _serverInfo.appdata[0], devId: _serverInfo.appdata[0], roomId: _serverInfo.rid });\r\n                                                yield this._audioProduct.resume();\r\n                                            }\r\n                                            const _startTalk = { request: true, errCode: errorCode, method: \"startTalk\" };\r\n                                            this.emit('OnManage', _startTalk);\r\n                                        }\r\n                                        else {\r\n                                            this._audioProduct.pause();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case 5:\r\n                            case 11:\r\n                                {\r\n                                    let result = yield this.sendMedia(productParam);\r\n                                    if (result == 200 && this._audioProduct != null) {\r\n                                        this._audioProduct.pause();\r\n                                    }\r\n                                    productParam.kind = 'video';\r\n                                    productParam.streamType = 2;\r\n                                    productParam.showObj = this._loginInfo.setting.localVideo;\r\n                                    result = yield this.sendMedia(productParam);\r\n                                    if (result == 200 && this._videoProduct != null) {\r\n                                        this._videoProduct.setMaxSpatialLayer(3);\r\n                                        this._videoProduct.resume();\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case 6:\r\n                                {\r\n                                    let result = yield this.sendMedia(productParam);\r\n                                    if (result == 200 && this._audioProduct != null) {\r\n                                        this._audioProduct.resume();\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            }));\r\n            this._protoo.on('failed', () => __awaiter(this, void 0, void 0, function* () {\r\n                const _req = { request: true, errCode: 502, method: 'responseConnectMedia', data: { ip: _serverInfo.mediaIp, port: _serverInfo.mediaPort } };\r\n                this.emit('OnManage', _req);\r\n            }));\r\n            this._protoo.on('disconnected', () => __awaiter(this, void 0, void 0, function* () {\r\n                const _req = { request: true, errCode: 401, method: \"responseConnectMedia\", data: { ip: _serverInfo.mediaIp, port: _serverInfo.mediaPort } };\r\n                this.emit('OnManage', _req);\r\n            }));\r\n            this._protoo.on('close', () => __awaiter(this, void 0, void 0, function* () {\r\n                const _req = { request: true, errCode: 500, method: \"responseConnectMedia\", data: { ip: _serverInfo.mediaIp, port: _serverInfo.mediaPort } };\r\n                this.emit('OnManage', _req);\r\n            }));\r\n            this._protoo.on('request', (request, accept, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                this.onServerResponse(request, accept, reject);\r\n            }));\r\n            this._protoo.on('notification', (request, accept, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                this.onServerResponse(request, accept, reject);\r\n            }));\r\n        });\r\n    }\r\n    connect({ ip, port, token, ssl, roomId, devId, localVideo, localAudio }, isSubtalk) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let _roomId = 'mcs8_admin';\r\n            let _userType = 6;\r\n            let _did = 'admin';\r\n            let _talkGroupType = 0;\r\n            if (isSubtalk == true) {\r\n                _userType = 4;\r\n                _roomId = roomId;\r\n                _did = yield this.getGuid();\r\n                _talkGroupType = 3;\r\n            }\r\n            const serverInfo = {\r\n                mediaIp: ip,\r\n                mediaPort: port,\r\n                token,\r\n                ssl,\r\n                rid: _roomId,\r\n                userType: _userType,\r\n                did: _did,\r\n                talkGroupType: _talkGroupType,\r\n                temGroupType: 0,\r\n                isCreator: 0,\r\n                setting: { localVideo: localVideo, localAudio: localAudio },\r\n                appdata: [devId],\r\n                istalk: isSubtalk == true ? true : false\r\n            };\r\n            return this.connectMedia(serverInfo, serverInfo.istalk);\r\n        });\r\n    }\r\n    getGuid() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let id = \"\";\r\n            for (let i = 0; i < 4; i++) {\r\n                id += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n            }\r\n            return id;\r\n        });\r\n    }\r\n    onServerResponse(request, accept, reject) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            console.log('proto \"request\" event [method:%s, data:%o]', request.method, request.data);\r\n            if (request.request == true) {\r\n                accept();\r\n            }\r\n            switch (request.method) {\r\n                case 'newPeer':\r\n                    {\r\n                    }\r\n                    break;\r\n                case 'newConsumer':\r\n                    {\r\n                        const { peerId, id, kind, producerId, rtpParameters } = request.data;\r\n                        let _log = { request: true, method: \"TrackingLog\", data: request.data };\r\n                        this.emit('OnManage', _log);\r\n                        const ShowRemoteObj = yield this.getShowObj(kind, peerId);\r\n                        if (ShowRemoteObj == null && this._loginInfo.rid == 'mcs8_admin') {\r\n                            return;\r\n                        }\r\n                        const consumer = yield this._consumerTransport.consume({\r\n                            id,\r\n                            producerId,\r\n                            kind,\r\n                            rtpParameters,\r\n                            codecOptions: {},\r\n                            appData: { devId: peerId }\r\n                        });\r\n                        if (ShowRemoteObj != null) {\r\n                            const stream = new MediaStream();\r\n                            stream.addTrack(consumer.track);\r\n                            ShowRemoteObj.srcObject = stream;\r\n                            _log = { request: true, method: \"TrackingLog\", data: { content: \"add consumer.track to ShowRemoteObj\" } };\r\n                            this.emit('OnManage', _log);\r\n                        }\r\n                        consumer.on('close', () => __awaiter(this, void 0, void 0, function* () {\r\n                            this._consumerList.delete(id);\r\n                        }));\r\n                        this._consumerList.set(id, consumer);\r\n                    }\r\n                    break;\r\n                case 'peerClosed':\r\n                    {\r\n                    }\r\n                    break;\r\n                case 'DeviceStatus':\r\n                    {\r\n                    }\r\n                    break;\r\n                case 'consumerAllProduct':\r\n                    {\r\n                        if (this._loginInfo.devMeeting == true) {\r\n                            const { devId, devType } = request.data;\r\n                            if (devType == 1) {\r\n                                yield this.requestMsg('updateDevAllMediaConsumer', { devId, kind: 'audio', isPause: true });\r\n                                yield this.requestMsg('updateDevAllMediaConsumer', { devId, kind: 'video', isPause: true });\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            const _req = { request: true, errCode: 200, method: request.method, data: request.data };\r\n            this.emit('OnManage', _req);\r\n        });\r\n    }\r\n    getStats() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._consumerTransport != null) {\r\n                return this._consumerTransport.getStats();\r\n            }\r\n        });\r\n    }\r\n    getShowObj(kind, peerId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let ShowRemoteObj = null;\r\n            if (kind == 'video') {\r\n                let oVideoObj = this._showVideoList.get(peerId);\r\n                if (oVideoObj != null) {\r\n                    ShowRemoteObj = oVideoObj.showObj;\r\n                }\r\n            }\r\n            if (kind == 'audio') {\r\n                let oAudioObj = this._showAudioList.get(peerId);\r\n                if (oAudioObj != null) {\r\n                    ShowRemoteObj = oAudioObj.showObj;\r\n                }\r\n                if (oAudioObj == null) {\r\n                    if (this._loginInfo.talkGroupType == 5) {\r\n                        return this.getShowObj('video', peerId);\r\n                    }\r\n                }\r\n            }\r\n            return ShowRemoteObj;\r\n        });\r\n    }\r\n    createConsumer() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const TransportParam = { forceTcp: false, producing: false, consuming: true };\r\n            const LocalTransport = yield this.createTransport(TransportParam, false);\r\n            LocalTransport.on('connect', ({ dtlsParameters }, callback, errback) => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    this._protoo.request(\"connectWebRtcTransport\", {\r\n                        transportId: LocalTransport.id,\r\n                        dtlsParameters\r\n                    });\r\n                    callback();\r\n                }\r\n                catch (error) {\r\n                    errback(error);\r\n                }\r\n            }));\r\n            LocalTransport.on('connectionstatechange', (state) => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    switch (state) {\r\n                        case 'connecting':\r\n                            break;\r\n                        case 'connected':\r\n                            {\r\n                                const _req = { request: true, errCode: 200, method: \"createConsumer\" };\r\n                                this.emit('OnManage', _req);\r\n                            }\r\n                            break;\r\n                        case 'failed':\r\n                            {\r\n                                const _req = { request: true, errCode: 500, method: \"createConsumer\" };\r\n                                this.emit('OnManage', _req);\r\n                            }\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n                catch (error) { }\r\n            }));\r\n            LocalTransport.on('getstats', function () {\r\n                console.log('getstats');\r\n            });\r\n            LocalTransport.on('close', function () {\r\n            });\r\n            this._consumerTransport = LocalTransport;\r\n        });\r\n    }\r\n    createProduct() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const TransportParam = { forceTcp: false, producing: true, consuming: false };\r\n            const LocalTransport = yield this.createTransport(TransportParam, true);\r\n            LocalTransport.on('connect', ({ dtlsParameters }, callback, errback) => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    yield this._protoo.request(\"connectWebRtcTransport\", {\r\n                        transportId: LocalTransport.id,\r\n                        dtlsParameters\r\n                    });\r\n                    callback();\r\n                    const _req = { request: true, errCode: 200, method: \"connectTransport\" };\r\n                    this.emit('OnManage', _req);\r\n                }\r\n                catch (error) {\r\n                    errback(error);\r\n                }\r\n            }));\r\n            LocalTransport.on('produce', ({ kind, rtpParameters, appData }, callback, errback) => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    const { id } = yield this._protoo.request('produce', {\r\n                        transportId: LocalTransport.id,\r\n                        kind,\r\n                        rtpParameters,\r\n                        appData\r\n                    });\r\n                    callback({ id });\r\n                    const _req = { request: true, errCode: 200, method: \"produce\", data: { productId: id, kind, groupId: this._loginInfo.rid } };\r\n                    this.emit('OnManage', _req);\r\n                }\r\n                catch (error) {\r\n                    errback(error);\r\n                }\r\n            }));\r\n            this._producerTransport = LocalTransport;\r\n            return LocalTransport;\r\n        });\r\n    }\r\n    createTransport(TransportParam, isSend) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const transport = yield this._protoo.request('createWebRtcTransport', TransportParam);\r\n            const { id, iceParameters, iceCandidates, dtlsParameters, sctpParameters } = transport;\r\n            let LocalTransport;\r\n            if (isSend) {\r\n                LocalTransport = yield this._device.createSendTransport({\r\n                    id,\r\n                    iceParameters,\r\n                    iceCandidates,\r\n                    dtlsParameters,\r\n                    sctpParameters\r\n                });\r\n            }\r\n            else {\r\n                LocalTransport = yield this._device.createRecvTransport({\r\n                    id,\r\n                    iceParameters,\r\n                    iceCandidates,\r\n                    dtlsParameters,\r\n                    sctpParameters\r\n                });\r\n            }\r\n            return LocalTransport;\r\n        });\r\n    }\r\n    openVideo({ kind, devId, streamType, showObj, channelId }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (kind == \"video\") {\r\n                var chanId = channelId;\r\n                if (chanId == null) {\r\n                    chanId = \"-1\";\r\n                }\r\n                this._showVideoList.set(devId, { kind, devId, streamType, showObj, channelId: chanId });\r\n                yield this._protoo.request('mediaMonitor', { kind, devId, streamType, channelId: chanId });\r\n            }\r\n            if (kind == \"audio\") {\r\n                this._showAudioList.set(devId, { kind, devId, streamType, showObj });\r\n                yield this._protoo.request('mediaMonitor', { kind, devId, streamType });\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    stopVideo({ kind, devId, streamType, channelId }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const mediaObj = yield this.getShowObj(kind, devId);\r\n            let tracks = null;\r\n            var chanId = channelId;\r\n            if (chanId == null) {\r\n                chanId = \"-1\";\r\n            }\r\n            const result = yield this._protoo.request('closeMediaMonitor', { kind, devId, streamType, channelId: chanId });\r\n            if (kind == \"video\") {\r\n                this._showVideoList.delete(devId);\r\n                if (mediaObj != null && mediaObj.srcObject != null) {\r\n                    tracks = mediaObj.srcObject.getVideoTracks();\r\n                }\r\n            }\r\n            if (kind == \"audio\") {\r\n                if (mediaObj != null && mediaObj.srcObject != null) {\r\n                    tracks = mediaObj.srcObject.getAudioTracks();\r\n                }\r\n                this._showAudioList.delete(devId);\r\n            }\r\n            if (tracks != null && tracks.length > 0) {\r\n                for (const track of tracks) {\r\n                    mediaObj.srcObject.removeTrack(track);\r\n                    track.stop();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getModelByDevId(kind, devId) {\r\n        if (kind == 'video') {\r\n            return this._showVideoList.get(devId);\r\n        }\r\n        if (kind == 'audio') {\r\n            return this._showAudioList.get(devId);\r\n        }\r\n        return null;\r\n    }\r\n    sendMedia({ kind, streamType, showObj }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (showObj == null) {\r\n                return 401;\r\n            }\r\n            const sendMedioObj = { kind, streamType, showObj, stream: null };\r\n            const mediaObj = this._sendMediaList.get(kind);\r\n            if (mediaObj != null) {\r\n                this.closeSendMdia(kind);\r\n            }\r\n            if (kind == 'audio') {\r\n                if (!this._device.canProduce('audio')) {\r\n                    return;\r\n                }\r\n                try {\r\n                    const stream = yield this.getMediaStream(kind);\r\n                    if (stream == null) {\r\n                        const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { kind: \"audio\", content: \"Input device not found\" } };\r\n                        this.emit('OnManage', _reqJoin);\r\n                        return 404;\r\n                    }\r\n                    const audioTrack = stream.getAudioTracks()[0];\r\n                    audioTrack.enabled = false;\r\n                    this._audioProduct = yield this._producerTransport.produce({\r\n                        track: audioTrack,\r\n                        codecOptions: {\r\n                            opusStereo: 1,\r\n                            opusDtx: 1\r\n                        }\r\n                    });\r\n                    this._audioProduct.on('transportclose', () => {\r\n                        this._audioProduct = null;\r\n                    });\r\n                    this._audioProduct.on('trackended', () => {\r\n                        this.closeSendMdia('audio');\r\n                    });\r\n                    sendMedioObj.stream = stream;\r\n                    this._sendMediaList.set(kind, sendMedioObj);\r\n                }\r\n                catch (ex) {\r\n                    const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { kind: \"audio\", content: \"Input device not found\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return;\r\n                }\r\n            }\r\n            if (kind == 'video') {\r\n                try {\r\n                    const stream = yield this.getMediaStream(kind);\r\n                    if (stream == null) {\r\n                        const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { kind: \"audio\", content: \"Input device not found\" } };\r\n                        this.emit('OnManage', _reqJoin);\r\n                        return 404;\r\n                    }\r\n                    const videoTrack = stream.getVideoTracks()[0];\r\n                    this._videoProduct = yield this._producerTransport.produce({ track: videoTrack });\r\n                    this._videoProduct.on('transportclose', () => {\r\n                        this._videoProduct = null;\r\n                    });\r\n                    this._videoProduct.on('trackended', () => {\r\n                        this.closeSendMdia('video');\r\n                    });\r\n                    sendMedioObj.stream = stream;\r\n                    this._sendMediaList.set(kind, sendMedioObj);\r\n                    sendMedioObj.showObj.srcObject = stream;\r\n                }\r\n                catch (ex) {\r\n                    const _reqJoin = { request: true, errCode: 404, method: \"InputDevice\", data: { kind: \"video\", content: \"Input device not found\" } };\r\n                    this.emit('OnManage', _reqJoin);\r\n                    return;\r\n                }\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    getMediaStream(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return new Promise((pResolve, pReject) => __awaiter(this, void 0, void 0, function* () {\r\n                if (kind == 'audio') {\r\n                    if (navigator.mediaDevices != null) {\r\n                        const stream = yield navigator.mediaDevices.getUserMedia({ audio: true });\r\n                        pResolve(stream);\r\n                    }\r\n                    else {\r\n                        navigator.getUserMedia({ audio: true }, function (stream) { pResolve(stream); }, function (err) { pReject(err); });\r\n                    }\r\n                }\r\n                if (kind == 'video') {\r\n                    if (navigator.mediaDevices != null) {\r\n                        const stream = yield navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });\r\n                        pResolve(stream);\r\n                    }\r\n                    else {\r\n                        navigator.getUserMedia({ video: { width: 320, height: 240 } }, function (stream) { pResolve(stream); }, function (err) { pReject(err); });\r\n                    }\r\n                }\r\n            }));\r\n        });\r\n    }\r\n    closeSendMdia(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let productId = null;\r\n            if (kind == 'audio') {\r\n                if (this._audioProduct != null) {\r\n                    productId = this._audioProduct.id;\r\n                    this._audioProduct.close();\r\n                }\r\n                this._audioProduct = null;\r\n            }\r\n            if (kind == 'video') {\r\n                if (this._videoProduct != null) {\r\n                    productId = this._videoProduct.id;\r\n                    this._videoProduct.close();\r\n                }\r\n                this._videoProduct = null;\r\n            }\r\n            if (productId != null) {\r\n                yield this._protoo.request('closeProducer', { producerId: productId });\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    pause(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (kind == 'video') {\r\n                if (this._videoProduct == null) {\r\n                    return 401;\r\n                }\r\n                this._videoProduct.pause();\r\n                return 200;\r\n            }\r\n            if (kind == 'audio') {\r\n                if (this._audioProduct == null) {\r\n                    return 401;\r\n                }\r\n                this._audioProduct.pause();\r\n                return 200;\r\n            }\r\n            return 404;\r\n        });\r\n    }\r\n    resume(kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let proId = '';\r\n            if (kind == 'video') {\r\n                if (this._videoProduct == null) {\r\n                    return 401;\r\n                }\r\n                this._videoProduct.resume();\r\n                return 200;\r\n            }\r\n            if (kind == 'audio') {\r\n                if (this._audioProduct == null) {\r\n                    return 401;\r\n                }\r\n                this._audioProduct.resume();\r\n                return 200;\r\n            }\r\n            return 404;\r\n        });\r\n    }\r\n    addShowObject({ kind, devId, showObj }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (showObj.srcObject == null) {\r\n                showObj.srcObject = new MediaStream();\r\n            }\r\n            if (kind == \"video\") {\r\n                this._showVideoList.set(devId, { kind, devId, streamType: 2, showObj });\r\n            }\r\n            if (kind == \"audio\") {\r\n                this._showAudioList.set(devId, { kind, devId, streamType: 2, showObj });\r\n            }\r\n            const _consumer = yield this.getConsumer(devId, kind);\r\n            if (_consumer != null) {\r\n                yield this.removeTrack(showObj, kind);\r\n                showObj.srcObject.addTrack(_consumer.track);\r\n            }\r\n            return 200;\r\n        });\r\n    }\r\n    getConsumer(devId, kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let resultConsumer;\r\n            for (const _consumer of this._consumerList.values()) {\r\n                if (_consumer.appData.devId == devId && _consumer.kind == kind) {\r\n                    resultConsumer = _consumer;\r\n                    break;\r\n                }\r\n            }\r\n            return resultConsumer;\r\n        });\r\n    }\r\n    removeTrack(showObj, kind) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (showObj == null) {\r\n                return 400;\r\n            }\r\n            if (showObj.stream == null) {\r\n                return 400;\r\n            }\r\n            const tracks = showObj.stream.getTracks();\r\n            if (tracks == null) {\r\n                return 400;\r\n            }\r\n            if (tracks.length <= 0) {\r\n                return 400;\r\n            }\r\n            for (const _track of tracks) {\r\n                if (_track.kind == kind) {\r\n                    showObj.stream.removeTrack(_track);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    requestMsg(method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._protoo.request == null) {\r\n                return 500;\r\n            }\r\n            return yield this._protoo.request(method, data);\r\n        });\r\n    }\r\n    notifyMsg(method, data) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._protoo.request == null) {\r\n                return 500;\r\n            }\r\n            this._protoo.notify(method, data);\r\n            return 200;\r\n        });\r\n    }\r\n    close() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this._consumerList != null) {\r\n                for (const consumer of this._consumerList.values()) {\r\n                    consumer.close();\r\n                }\r\n            }\r\n            this.closeSendMdia('video');\r\n            this.closeSendMdia('audio');\r\n            if (this._audioProduct != null) {\r\n                this._audioProduct.close();\r\n            }\r\n            if (this._videoProduct != null) {\r\n                this._videoProduct.close();\r\n            }\r\n            if (this._consumerTransport != null) {\r\n                this._consumerTransport.close();\r\n            }\r\n            if (this._producerTransport != null) {\r\n                this._producerTransport.close();\r\n            }\r\n            this._consumerList.clear();\r\n            this._showVideoList.clear();\r\n            this._showAudioList.clear();\r\n            this._sendMediaList.clear();\r\n            if (this._protoo != null) {\r\n                this._protoo.close();\r\n            }\r\n        });\r\n    }\r\n    setLocalVideoOrAudioObject({ localVideo, localAudio }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (localVideo != null) {\r\n                this._loginInfo.setting.localVideo = localVideo;\r\n            }\r\n            if (localAudio != null) {\r\n                this._loginInfo.setting.localAudio = localAudio;\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.mcs8MediaClient = mcs8MediaClient;\r\n\n\n//# sourceURL=webpack:///./src/mediaClient.ts?");

/***/ }),

/***/ "./src/ortc.ts":
/*!*********************!*\
  !*** ./src/ortc.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst h264 = __importStar(__webpack_require__(/*! h264-profile-level-id */ \"./node_modules/h264-profile-level-id/index.js\"));\r\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\r\nconst RTP_PROBATOR_MID = 'probator';\r\nconst RTP_PROBATOR_SSRC = 1234;\r\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\r\nfunction validateRtpCapabilities(caps) {\r\n    if (typeof caps !== 'object')\r\n        throw new TypeError('caps is not an object');\r\n    if (caps.codecs && !Array.isArray(caps.codecs))\r\n        throw new TypeError('caps.codecs is not an array');\r\n    else if (!caps.codecs)\r\n        caps.codecs = [];\r\n    for (const codec of caps.codecs) {\r\n        validateRtpCodecCapability(codec);\r\n    }\r\n    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions))\r\n        throw new TypeError('caps.headerExtensions is not an array');\r\n    else if (!caps.headerExtensions)\r\n        caps.headerExtensions = [];\r\n    for (const ext of caps.headerExtensions) {\r\n        validateRtpHeaderExtension(ext);\r\n    }\r\n}\r\nexports.validateRtpCapabilities = validateRtpCapabilities;\r\nfunction validateRtpCodecCapability(codec) {\r\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\r\n    if (typeof codec !== 'object')\r\n        throw new TypeError('codec is not an object');\r\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\r\n        throw new TypeError('missing codec.mimeType');\r\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\r\n    if (!mimeTypeMatch)\r\n        throw new TypeError('invalid codec.mimeType');\r\n    codec.kind = mimeTypeMatch[1].toLowerCase();\r\n    if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number')\r\n        throw new TypeError('invalid codec.preferredPayloadType');\r\n    if (typeof codec.clockRate !== 'number')\r\n        throw new TypeError('missing codec.clockRate');\r\n    if (codec.kind === 'audio') {\r\n        if (typeof codec.channels !== 'number')\r\n            codec.channels = 1;\r\n    }\r\n    else {\r\n        delete codec.channels;\r\n    }\r\n    if (!codec.parameters || typeof codec.parameters !== 'object')\r\n        codec.parameters = {};\r\n    for (const key of Object.keys(codec.parameters)) {\r\n        let value = codec.parameters[key];\r\n        if (value === undefined) {\r\n            codec.parameters[key] = '';\r\n            value = '';\r\n        }\r\n        if (typeof value !== 'string' && typeof value !== 'number') {\r\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\r\n        }\r\n        if (key === 'apt') {\r\n            if (typeof value !== 'number')\r\n                throw new TypeError('invalid codec apt parameter');\r\n        }\r\n    }\r\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\r\n        codec.rtcpFeedback = [];\r\n    for (const fb of codec.rtcpFeedback) {\r\n        validateRtcpFeedback(fb);\r\n    }\r\n}\r\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\r\nfunction validateRtcpFeedback(fb) {\r\n    if (typeof fb !== 'object')\r\n        throw new TypeError('fb is not an object');\r\n    if (!fb.type || typeof fb.type !== 'string')\r\n        throw new TypeError('missing fb.type');\r\n    if (!fb.parameter || typeof fb.parameter !== 'string')\r\n        fb.parameter = '';\r\n}\r\nexports.validateRtcpFeedback = validateRtcpFeedback;\r\nfunction validateRtpHeaderExtension(ext) {\r\n    if (typeof ext !== 'object')\r\n        throw new TypeError('ext is not an object');\r\n    if (!ext.kind || typeof ext.kind !== 'string')\r\n        ext.kind = '';\r\n    if (ext.kind !== '' && ext.kind !== 'audio' && ext.kind !== 'video')\r\n        throw new TypeError('invalid ext.kind');\r\n    if (!ext.uri || typeof ext.uri !== 'string')\r\n        throw new TypeError('missing ext.uri');\r\n    if (typeof ext.preferredId !== 'number')\r\n        throw new TypeError('missing ext.preferredId');\r\n    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean')\r\n        throw new TypeError('invalid ext.preferredEncrypt');\r\n    else if (!ext.preferredEncrypt)\r\n        ext.preferredEncrypt = false;\r\n    if (ext.direction && typeof ext.direction !== 'string')\r\n        throw new TypeError('invalid ext.direction');\r\n    else if (!ext.direction)\r\n        ext.direction = 'sendrecv';\r\n}\r\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\r\nfunction validateRtpParameters(params) {\r\n    if (typeof params !== 'object')\r\n        throw new TypeError('params is not an object');\r\n    if (params.mid && typeof params.mid !== 'string')\r\n        throw new TypeError('params.mid is not a string');\r\n    if (!Array.isArray(params.codecs))\r\n        throw new TypeError('missing params.codecs');\r\n    for (const codec of params.codecs) {\r\n        validateRtpCodecParameters(codec);\r\n    }\r\n    if (params.headerExtensions && !Array.isArray(params.headerExtensions))\r\n        throw new TypeError('params.headerExtensions is not an array');\r\n    else if (!params.headerExtensions)\r\n        params.headerExtensions = [];\r\n    for (const ext of params.headerExtensions) {\r\n        validateRtpHeaderExtensionParameters(ext);\r\n    }\r\n    if (params.encodings && !Array.isArray(params.encodings))\r\n        throw new TypeError('params.encodings is not an array');\r\n    else if (!params.encodings)\r\n        params.encodings = [];\r\n    for (const encoding of params.encodings) {\r\n        validateRtpEncodingParameters(encoding);\r\n    }\r\n    if (params.rtcp && typeof params.rtcp !== 'object')\r\n        throw new TypeError('params.rtcp is not an object');\r\n    else if (!params.rtcp)\r\n        params.rtcp = {};\r\n    validateRtcpParameters(params.rtcp);\r\n}\r\nexports.validateRtpParameters = validateRtpParameters;\r\nfunction validateRtpCodecParameters(codec) {\r\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\r\n    if (typeof codec !== 'object')\r\n        throw new TypeError('codec is not an object');\r\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\r\n        throw new TypeError('missing codec.mimeType');\r\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\r\n    if (!mimeTypeMatch)\r\n        throw new TypeError('invalid codec.mimeType');\r\n    if (typeof codec.payloadType !== 'number')\r\n        throw new TypeError('missing codec.payloadType');\r\n    if (typeof codec.clockRate !== 'number')\r\n        throw new TypeError('missing codec.clockRate');\r\n    const kind = mimeTypeMatch[1].toLowerCase();\r\n    if (kind === 'audio') {\r\n        if (typeof codec.channels !== 'number')\r\n            codec.channels = 1;\r\n    }\r\n    else {\r\n        delete codec.channels;\r\n    }\r\n    if (!codec.parameters || typeof codec.parameters !== 'object')\r\n        codec.parameters = {};\r\n    for (const key of Object.keys(codec.parameters)) {\r\n        let value = codec.parameters[key];\r\n        if (value === undefined) {\r\n            codec.parameters[key] = '';\r\n            value = '';\r\n        }\r\n        if (typeof value !== 'string' && typeof value !== 'number') {\r\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\r\n        }\r\n        if (key === 'apt') {\r\n            if (typeof value !== 'number')\r\n                throw new TypeError('invalid codec apt parameter');\r\n        }\r\n    }\r\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\r\n        codec.rtcpFeedback = [];\r\n    for (const fb of codec.rtcpFeedback) {\r\n        validateRtcpFeedback(fb);\r\n    }\r\n}\r\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\r\nfunction validateRtpHeaderExtensionParameters(ext) {\r\n    if (typeof ext !== 'object')\r\n        throw new TypeError('ext is not an object');\r\n    if (!ext.uri || typeof ext.uri !== 'string')\r\n        throw new TypeError('missing ext.uri');\r\n    if (typeof ext.id !== 'number')\r\n        throw new TypeError('missing ext.id');\r\n    if (ext.encrypt && typeof ext.encrypt !== 'boolean')\r\n        throw new TypeError('invalid ext.encrypt');\r\n    else if (!ext.encrypt)\r\n        ext.encrypt = false;\r\n    if (!ext.parameters || typeof ext.parameters !== 'object')\r\n        ext.parameters = {};\r\n    for (const key of Object.keys(ext.parameters)) {\r\n        let value = ext.parameters[key];\r\n        if (value === undefined) {\r\n            ext.parameters[key] = '';\r\n            value = '';\r\n        }\r\n        if (typeof value !== 'string' && typeof value !== 'number')\r\n            throw new TypeError('invalid header extension parameter');\r\n    }\r\n}\r\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\r\nfunction validateRtpEncodingParameters(encoding) {\r\n    if (typeof encoding !== 'object')\r\n        throw new TypeError('encoding is not an object');\r\n    if (encoding.ssrc && typeof encoding.ssrc !== 'number')\r\n        throw new TypeError('invalid encoding.ssrc');\r\n    if (encoding.rid && typeof encoding.rid !== 'string')\r\n        throw new TypeError('invalid encoding.rid');\r\n    if (encoding.rtx && typeof encoding.rtx !== 'object') {\r\n        throw new TypeError('invalid encoding.rtx');\r\n    }\r\n    else if (encoding.rtx) {\r\n        if (typeof encoding.rtx.ssrc !== 'number')\r\n            throw new TypeError('missing encoding.rtx.ssrc');\r\n    }\r\n    if (!encoding.dtx || typeof encoding.dtx !== 'boolean')\r\n        encoding.dtx = false;\r\n    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string')\r\n        throw new TypeError('invalid encoding.scalabilityMode');\r\n}\r\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\r\nfunction validateRtcpParameters(rtcp) {\r\n    if (typeof rtcp !== 'object')\r\n        throw new TypeError('rtcp is not an object');\r\n    if (rtcp.cname && typeof rtcp.cname !== 'string')\r\n        throw new TypeError('invalid rtcp.cname');\r\n    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean')\r\n        rtcp.reducedSize = true;\r\n}\r\nexports.validateRtcpParameters = validateRtcpParameters;\r\nfunction validateSctpCapabilities(caps) {\r\n    if (typeof caps !== 'object')\r\n        throw new TypeError('caps is not an object');\r\n    if (!caps.numStreams || typeof caps.numStreams !== 'object')\r\n        throw new TypeError('missing caps.numStreams');\r\n    validateNumSctpStreams(caps.numStreams);\r\n}\r\nexports.validateSctpCapabilities = validateSctpCapabilities;\r\nfunction validateNumSctpStreams(numStreams) {\r\n    if (typeof numStreams !== 'object')\r\n        throw new TypeError('numStreams is not an object');\r\n    if (typeof numStreams.OS !== 'number')\r\n        throw new TypeError('missing numStreams.OS');\r\n    if (typeof numStreams.MIS !== 'number')\r\n        throw new TypeError('missing numStreams.MIS');\r\n}\r\nexports.validateNumSctpStreams = validateNumSctpStreams;\r\nfunction validateSctpParameters(params) {\r\n    if (typeof params !== 'object')\r\n        throw new TypeError('params is not an object');\r\n    if (typeof params.port !== 'number')\r\n        throw new TypeError('missing params.port');\r\n    if (typeof params.OS !== 'number')\r\n        throw new TypeError('missing params.OS');\r\n    if (typeof params.MIS !== 'number')\r\n        throw new TypeError('missing params.MIS');\r\n    if (typeof params.maxMessageSize !== 'number')\r\n        throw new TypeError('missing params.maxMessageSize');\r\n}\r\nexports.validateSctpParameters = validateSctpParameters;\r\nfunction validateSctpStreamParameters(params) {\r\n    if (typeof params !== 'object')\r\n        throw new TypeError('params is not an object');\r\n    if (typeof params.streamId !== 'number')\r\n        throw new TypeError('missing params.streamId');\r\n    let orderedGiven = false;\r\n    if (typeof params.ordered === 'boolean')\r\n        orderedGiven = true;\r\n    else\r\n        params.ordered = true;\r\n    if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number')\r\n        throw new TypeError('invalid params.maxPacketLifeTime');\r\n    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number')\r\n        throw new TypeError('invalid params.maxRetransmits');\r\n    if (params.maxPacketLifeTime && params.maxRetransmits)\r\n        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\r\n    if (orderedGiven &&\r\n        params.ordered &&\r\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\r\n        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\r\n    }\r\n    else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\r\n        params.ordered = false;\r\n    }\r\n    if (params.priority && typeof params.priority !== 'string')\r\n        throw new TypeError('invalid params.priority');\r\n    if (params.label && typeof params.label !== 'string')\r\n        throw new TypeError('invalid params.label');\r\n    if (params.protocol && typeof params.protocol !== 'string')\r\n        throw new TypeError('invalid params.protocol');\r\n}\r\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\r\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\r\n    const extendedRtpCapabilities = {\r\n        codecs: [],\r\n        headerExtensions: []\r\n    };\r\n    for (const remoteCodec of remoteCaps.codecs || []) {\r\n        if (isRtxCodec(remoteCodec))\r\n            continue;\r\n        const matchingLocalCodec = (localCaps.codecs || [])\r\n            .find((localCodec) => (matchCodecs(localCodec, remoteCodec, { strict: true, modify: true })));\r\n        if (!matchingLocalCodec)\r\n            continue;\r\n        const extendedCodec = {\r\n            mimeType: matchingLocalCodec.mimeType,\r\n            kind: matchingLocalCodec.kind,\r\n            clockRate: matchingLocalCodec.clockRate,\r\n            channels: matchingLocalCodec.channels,\r\n            localPayloadType: matchingLocalCodec.preferredPayloadType,\r\n            localRtxPayloadType: undefined,\r\n            remotePayloadType: remoteCodec.preferredPayloadType,\r\n            remoteRtxPayloadType: undefined,\r\n            localParameters: matchingLocalCodec.parameters,\r\n            remoteParameters: remoteCodec.parameters,\r\n            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\r\n        };\r\n        extendedRtpCapabilities.codecs.push(extendedCodec);\r\n    }\r\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\r\n        const matchingLocalRtxCodec = localCaps.codecs\r\n            .find((localCodec) => (isRtxCodec(localCodec) &&\r\n            localCodec.parameters.apt === extendedCodec.localPayloadType));\r\n        const matchingRemoteRtxCodec = remoteCaps.codecs\r\n            .find((remoteCodec) => (isRtxCodec(remoteCodec) &&\r\n            remoteCodec.parameters.apt === extendedCodec.remotePayloadType));\r\n        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\r\n            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\r\n            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\r\n        }\r\n    }\r\n    for (const remoteExt of remoteCaps.headerExtensions) {\r\n        const matchingLocalExt = localCaps.headerExtensions\r\n            .find((localExt) => (matchHeaderExtensions(localExt, remoteExt)));\r\n        if (!matchingLocalExt)\r\n            continue;\r\n        const extendedExt = {\r\n            kind: remoteExt.kind,\r\n            uri: remoteExt.uri,\r\n            sendId: matchingLocalExt.preferredId,\r\n            recvId: remoteExt.preferredId,\r\n            encrypt: matchingLocalExt.preferredEncrypt,\r\n            direction: 'sendrecv'\r\n        };\r\n        switch (remoteExt.direction) {\r\n            case 'sendrecv':\r\n                extendedExt.direction = 'sendrecv';\r\n                break;\r\n            case 'recvonly':\r\n                extendedExt.direction = 'sendonly';\r\n                break;\r\n            case 'sendonly':\r\n                extendedExt.direction = 'recvonly';\r\n                break;\r\n            case 'inactive':\r\n                extendedExt.direction = 'inactive';\r\n                break;\r\n        }\r\n        extendedRtpCapabilities.headerExtensions.push(extendedExt);\r\n    }\r\n    return extendedRtpCapabilities;\r\n}\r\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\r\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\r\n    const rtpCapabilities = {\r\n        codecs: [],\r\n        headerExtensions: []\r\n    };\r\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\r\n        const codec = {\r\n            mimeType: extendedCodec.mimeType,\r\n            kind: extendedCodec.kind,\r\n            preferredPayloadType: extendedCodec.remotePayloadType,\r\n            clockRate: extendedCodec.clockRate,\r\n            channels: extendedCodec.channels,\r\n            parameters: extendedCodec.localParameters,\r\n            rtcpFeedback: extendedCodec.rtcpFeedback\r\n        };\r\n        rtpCapabilities.codecs.push(codec);\r\n        if (!extendedCodec.remoteRtxPayloadType)\r\n            continue;\r\n        const rtxCodec = {\r\n            mimeType: `${extendedCodec.kind}/rtx`,\r\n            kind: extendedCodec.kind,\r\n            preferredPayloadType: extendedCodec.remoteRtxPayloadType,\r\n            clockRate: extendedCodec.clockRate,\r\n            parameters: {\r\n                apt: extendedCodec.remotePayloadType\r\n            },\r\n            rtcpFeedback: []\r\n        };\r\n        rtpCapabilities.codecs.push(rtxCodec);\r\n    }\r\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\r\n        if (extendedExtension.direction !== 'sendrecv' &&\r\n            extendedExtension.direction !== 'recvonly') {\r\n            continue;\r\n        }\r\n        const ext = {\r\n            kind: extendedExtension.kind,\r\n            uri: extendedExtension.uri,\r\n            preferredId: extendedExtension.recvId,\r\n            preferredEncrypt: extendedExtension.encrypt,\r\n            direction: extendedExtension.direction\r\n        };\r\n        rtpCapabilities.headerExtensions.push(ext);\r\n    }\r\n    return rtpCapabilities;\r\n}\r\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\r\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\r\n    const rtpParameters = {\r\n        mid: undefined,\r\n        codecs: [],\r\n        headerExtensions: [],\r\n        encodings: [],\r\n        rtcp: {}\r\n    };\r\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\r\n        if (extendedCodec.kind !== kind)\r\n            continue;\r\n        const codec = {\r\n            mimeType: extendedCodec.mimeType,\r\n            payloadType: extendedCodec.localPayloadType,\r\n            clockRate: extendedCodec.clockRate,\r\n            channels: extendedCodec.channels,\r\n            parameters: extendedCodec.localParameters,\r\n            rtcpFeedback: extendedCodec.rtcpFeedback\r\n        };\r\n        rtpParameters.codecs.push(codec);\r\n        if (extendedCodec.localRtxPayloadType) {\r\n            const rtxCodec = {\r\n                mimeType: `${extendedCodec.kind}/rtx`,\r\n                payloadType: extendedCodec.localRtxPayloadType,\r\n                clockRate: extendedCodec.clockRate,\r\n                parameters: {\r\n                    apt: extendedCodec.localPayloadType\r\n                },\r\n                rtcpFeedback: []\r\n            };\r\n            rtpParameters.codecs.push(rtxCodec);\r\n        }\r\n    }\r\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\r\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\r\n            (extendedExtension.direction !== 'sendrecv' &&\r\n                extendedExtension.direction !== 'sendonly')) {\r\n            continue;\r\n        }\r\n        const ext = {\r\n            uri: extendedExtension.uri,\r\n            id: extendedExtension.sendId,\r\n            encrypt: extendedExtension.encrypt,\r\n            parameters: {}\r\n        };\r\n        rtpParameters.headerExtensions.push(ext);\r\n    }\r\n    return rtpParameters;\r\n}\r\nexports.getSendingRtpParameters = getSendingRtpParameters;\r\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\r\n    const rtpParameters = {\r\n        mid: undefined,\r\n        codecs: [],\r\n        headerExtensions: [],\r\n        encodings: [],\r\n        rtcp: {}\r\n    };\r\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\r\n        if (extendedCodec.kind !== kind)\r\n            continue;\r\n        const codec = {\r\n            mimeType: extendedCodec.mimeType,\r\n            payloadType: extendedCodec.localPayloadType,\r\n            clockRate: extendedCodec.clockRate,\r\n            channels: extendedCodec.channels,\r\n            parameters: extendedCodec.remoteParameters,\r\n            rtcpFeedback: extendedCodec.rtcpFeedback\r\n        };\r\n        rtpParameters.codecs.push(codec);\r\n        if (extendedCodec.localRtxPayloadType) {\r\n            const rtxCodec = {\r\n                mimeType: `${extendedCodec.kind}/rtx`,\r\n                payloadType: extendedCodec.localRtxPayloadType,\r\n                clockRate: extendedCodec.clockRate,\r\n                parameters: {\r\n                    apt: extendedCodec.localPayloadType\r\n                },\r\n                rtcpFeedback: []\r\n            };\r\n            rtpParameters.codecs.push(rtxCodec);\r\n        }\r\n    }\r\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\r\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\r\n            (extendedExtension.direction !== 'sendrecv' &&\r\n                extendedExtension.direction !== 'sendonly')) {\r\n            continue;\r\n        }\r\n        const ext = {\r\n            uri: extendedExtension.uri,\r\n            id: extendedExtension.sendId,\r\n            encrypt: extendedExtension.encrypt,\r\n            parameters: {}\r\n        };\r\n        rtpParameters.headerExtensions.push(ext);\r\n    }\r\n    if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01'))) {\r\n        for (const codec of rtpParameters.codecs) {\r\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\r\n                .filter((fb) => fb.type !== 'goog-remb');\r\n        }\r\n    }\r\n    else if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time'))) {\r\n        for (const codec of rtpParameters.codecs) {\r\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\r\n                .filter((fb) => fb.type !== 'transport-cc');\r\n        }\r\n    }\r\n    else {\r\n        for (const codec of rtpParameters.codecs) {\r\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\r\n                .filter((fb) => (fb.type !== 'transport-cc' &&\r\n                fb.type !== 'goog-remb'));\r\n        }\r\n    }\r\n    return rtpParameters;\r\n}\r\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\r\nfunction reduceCodecs(codecs, capCodec) {\r\n    const filteredCodecs = [];\r\n    if (!capCodec) {\r\n        filteredCodecs.push(codecs[0]);\r\n        if (isRtxCodec(codecs[1]))\r\n            filteredCodecs.push(codecs[1]);\r\n    }\r\n    else {\r\n        for (let idx = 0; idx < codecs.length; ++idx) {\r\n            if (matchCodecs(codecs[idx], capCodec)) {\r\n                filteredCodecs.push(codecs[idx]);\r\n                if (isRtxCodec(codecs[idx + 1]))\r\n                    filteredCodecs.push(codecs[idx + 1]);\r\n                break;\r\n            }\r\n        }\r\n        if (filteredCodecs.length === 0)\r\n            throw new TypeError('no matching codec found');\r\n    }\r\n    return filteredCodecs;\r\n}\r\nexports.reduceCodecs = reduceCodecs;\r\nfunction generateProbatorRtpParameters(videoRtpParameters) {\r\n    videoRtpParameters = utils_1.clone(videoRtpParameters);\r\n    validateRtpParameters(videoRtpParameters);\r\n    const rtpParameters = {\r\n        mid: RTP_PROBATOR_MID,\r\n        codecs: [],\r\n        headerExtensions: [],\r\n        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],\r\n        rtcp: { cname: 'probator' }\r\n    };\r\n    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\r\n    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\r\n    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\r\n    return rtpParameters;\r\n}\r\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\r\nfunction canSend(kind, extendedRtpCapabilities) {\r\n    return extendedRtpCapabilities.codecs.\r\n        some((codec) => codec.kind === kind);\r\n}\r\nexports.canSend = canSend;\r\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\r\n    validateRtpParameters(rtpParameters);\r\n    if (rtpParameters.codecs.length === 0)\r\n        return false;\r\n    const firstMediaCodec = rtpParameters.codecs[0];\r\n    return extendedRtpCapabilities.codecs\r\n        .some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);\r\n}\r\nexports.canReceive = canReceive;\r\nfunction isRtxCodec(codec) {\r\n    if (!codec)\r\n        return false;\r\n    return /.+\\/rtx$/i.test(codec.mimeType);\r\n}\r\nfunction matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {\r\n    const aMimeType = aCodec.mimeType.toLowerCase();\r\n    const bMimeType = bCodec.mimeType.toLowerCase();\r\n    if (aMimeType !== bMimeType)\r\n        return false;\r\n    if (aCodec.clockRate !== bCodec.clockRate)\r\n        return false;\r\n    if (aCodec.channels !== bCodec.channels)\r\n        return false;\r\n    switch (aMimeType) {\r\n        case 'video/h264':\r\n            {\r\n                const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\r\n                const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\r\n                if (aPacketizationMode !== bPacketizationMode)\r\n                    return false;\r\n                if (strict) {\r\n                    if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters))\r\n                        return false;\r\n                    let selectedProfileLevelId;\r\n                    try {\r\n                        selectedProfileLevelId =\r\n                            h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\r\n                    }\r\n                    catch (error) {\r\n                        return false;\r\n                    }\r\n                    if (modify) {\r\n                        if (selectedProfileLevelId)\r\n                            aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\r\n                        else\r\n                            delete aCodec.parameters['profile-level-id'];\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        case 'video/vp9':\r\n            {\r\n                if (strict) {\r\n                    const aProfileId = aCodec.parameters['profile-id'] || 0;\r\n                    const bProfileId = bCodec.parameters['profile-id'] || 0;\r\n                    if (aProfileId !== bProfileId)\r\n                        return false;\r\n                }\r\n                break;\r\n            }\r\n    }\r\n    return true;\r\n}\r\nfunction matchHeaderExtensions(aExt, bExt) {\r\n    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind)\r\n        return false;\r\n    if (aExt.uri !== bExt.uri)\r\n        return false;\r\n    return true;\r\n}\r\nfunction reduceRtcpFeedback(codecA, codecB) {\r\n    const reducedRtcpFeedback = [];\r\n    for (const aFb of codecA.rtcpFeedback || []) {\r\n        const matchingBFb = (codecB.rtcpFeedback || [])\r\n            .find((bFb) => (bFb.type === aFb.type &&\r\n            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter))));\r\n        if (matchingBFb)\r\n            reducedRtcpFeedback.push(matchingBFb);\r\n    }\r\n    return reducedRtcpFeedback;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/ortc.ts?");

/***/ }),

/***/ "./src/scalabilityModes.ts":
/*!*********************************!*\
  !*** ./src/scalabilityModes.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\\\d{0,1})T([1-9]\\\\d{0,1})');\r\nfunction parse(scalabilityMode) {\r\n    const match = ScalabilityModeRegex.exec(scalabilityMode || '');\r\n    if (match) {\r\n        return {\r\n            spatialLayers: Number(match[1]),\r\n            temporalLayers: Number(match[2])\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            spatialLayers: 1,\r\n            temporalLayers: 1\r\n        };\r\n    }\r\n}\r\nexports.parse = parse;\r\n\n\n//# sourceURL=webpack:///./src/scalabilityModes.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction clone(data) {\r\n    if (typeof data !== 'object')\r\n        return {};\r\n    return JSON.parse(JSON.stringify(data));\r\n}\r\nexports.clone = clone;\r\nfunction generateRandomNumber() {\r\n    return Math.round(Math.random() * 10000000);\r\n}\r\nexports.generateRandomNumber = generateRandomNumber;\r\n\n\n//# sourceURL=webpack:///./src/utils.ts?");

/***/ })

/******/ });
});